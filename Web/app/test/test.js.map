{"version":3,"file":"..\\Web\\app\\test\\test.js","sources":["test/vendor/scripts/chai-1.5.0.js","test/vendor/scripts/mocha-1.8.2.js","test/vendor/scripts/sinon-1.6.0.js","test/vendor/scripts/sinon-chai-2.3.1.js","test/vendor/scripts/test-helper.js","test/initialize.coffee","test/views/header-view-test.coffee","test/views/home-page-view-test.coffee","test/views/site-view-test.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC55HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC7tKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC/nIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC7GA;AACA;AACA;AACA;AACA;AACA;A,CCLA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;A,CCAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;;A,CCAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;;A,CCAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;A","sourcesContent":["!function (name, context, definition) {\r\n  if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\r\n    module.exports = definition();\r\n  } else if (typeof define === 'function' && typeof define.amd  === 'object') {\r\n    define(function () {\r\n      return definition();\r\n    });\r\n  } else {\r\n    context[name] = definition();\r\n  }\r\n}('chai', this, function () {\r\n\r\n  function require(p) {\r\n    var path = require.resolve(p)\r\n      , mod = require.modules[path];\r\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\r\n    if (!mod.exports) {\r\n      mod.exports = {};\r\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\r\n    }\r\n    return mod.exports;\r\n  }\r\n\r\n  require.modules = {};\r\n\r\n  require.resolve = function (path) {\r\n    var orig = path\r\n      , reg = path + '.js'\r\n      , index = path + '/index.js';\r\n    return require.modules[reg] && reg\r\n      || require.modules[index] && index\r\n      || orig;\r\n  };\r\n\r\n  require.register = function (path, fn) {\r\n    require.modules[path] = fn;\r\n  };\r\n\r\n  require.relative = function (parent) {\r\n    return function(p){\r\n      if ('.' != p.charAt(0)) return require(p);\r\n\r\n      var path = parent.split('/')\r\n        , segs = p.split('/');\r\n      path.pop();\r\n\r\n      for (var i = 0; i < segs.length; i++) {\r\n        var seg = segs[i];\r\n        if ('..' == seg) path.pop();\r\n        else if ('.' != seg) path.push(seg);\r\n      }\r\n\r\n      return require(path.join('/'));\r\n    };\r\n  };\r\n\r\n  require.alias = function (from, to) {\r\n    var fn = require.modules[from];\r\n    require.modules[to] = fn;\r\n  };\r\n\r\n\r\n  require.register(\"chai.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    var used = []\r\n      , exports = module.exports = {};\r\n\r\n    /*!\r\n     * Chai version\r\n     */\r\n\r\n    exports.version = '1.5.0';\r\n\r\n    /*!\r\n     * Primary `Assertion` prototype\r\n     */\r\n\r\n    exports.Assertion = require('./chai/assertion');\r\n\r\n    /*!\r\n     * Assertion Error\r\n     */\r\n\r\n    exports.AssertionError = require('./chai/error');\r\n\r\n    /*!\r\n     * Utils for plugins (not exported)\r\n     */\r\n\r\n    var util = require('./chai/utils');\r\n\r\n    /**\r\n     * # .use(function)\r\n     *\r\n     * Provides a way to extend the internals of Chai\r\n     *\r\n     * @param {Function}\r\n     * @returns {this} for chaining\r\n     * @api public\r\n     */\r\n\r\n    exports.use = function (fn) {\r\n      if (!~used.indexOf(fn)) {\r\n        fn(this, util);\r\n        used.push(fn);\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\n    /*!\r\n     * Core Assertions\r\n     */\r\n\r\n    var core = require('./chai/core/assertions');\r\n    exports.use(core);\r\n\r\n    /*!\r\n     * Expect interface\r\n     */\r\n\r\n    var expect = require('./chai/interface/expect');\r\n    exports.use(expect);\r\n\r\n    /*!\r\n     * Should interface\r\n     */\r\n\r\n    var should = require('./chai/interface/should');\r\n    exports.use(should);\r\n\r\n    /*!\r\n     * Assert interface\r\n     */\r\n\r\n    var assert = require('./chai/interface/assert');\r\n    exports.use(assert);\r\n\r\n  }); // module: chai.js\r\n\r\n  require.register(\"chai/assertion.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * http://chaijs.com\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Module dependencies.\r\n     */\r\n\r\n    var AssertionError = require('./error')\r\n      , util = require('./utils')\r\n      , flag = util.flag;\r\n\r\n    /*!\r\n     * Module export.\r\n     */\r\n\r\n    module.exports = Assertion;\r\n\r\n\r\n    /*!\r\n     * Assertion Constructor\r\n     *\r\n     * Creates object for chaining.\r\n     *\r\n     * @api private\r\n     */\r\n\r\n    function Assertion (obj, msg, stack) {\r\n      flag(this, 'ssfi', stack || arguments.callee);\r\n      flag(this, 'object', obj);\r\n      flag(this, 'message', msg);\r\n    }\r\n\r\n    /*!\r\n      * ### Assertion.includeStack\r\n      *\r\n      * User configurable property, influences whether stack trace\r\n      * is included in Assertion error message. Default of false\r\n      * suppresses stack trace in the error message\r\n      *\r\n      *     Assertion.includeStack = true;  // enable stack on error\r\n      *\r\n      * @api public\r\n      */\r\n\r\n    Assertion.includeStack = false;\r\n\r\n    /*!\r\n     * ### Assertion.showDiff\r\n     *\r\n     * User configurable property, influences whether or not\r\n     * the `showDiff` flag should be included in the thrown\r\n     * AssertionErrors. `false` will always be `false`; `true`\r\n     * will be true when the assertion has requested a diff\r\n     * be shown.\r\n     *\r\n     * @api public\r\n     */\r\n\r\n    Assertion.showDiff = true;\r\n\r\n    Assertion.addProperty = function (name, fn) {\r\n      util.addProperty(this.prototype, name, fn);\r\n    };\r\n\r\n    Assertion.addMethod = function (name, fn) {\r\n      util.addMethod(this.prototype, name, fn);\r\n    };\r\n\r\n    Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\r\n      util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\r\n    };\r\n\r\n    Assertion.overwriteProperty = function (name, fn) {\r\n      util.overwriteProperty(this.prototype, name, fn);\r\n    };\r\n\r\n    Assertion.overwriteMethod = function (name, fn) {\r\n      util.overwriteMethod(this.prototype, name, fn);\r\n    };\r\n\r\n    /*!\r\n     * ### .assert(expression, message, negateMessage, expected, actual)\r\n     *\r\n     * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\r\n     *\r\n     * @name assert\r\n     * @param {Philosophical} expression to be tested\r\n     * @param {String} message to display if fails\r\n     * @param {String} negatedMessage to display if negated expression fails\r\n     * @param {Mixed} expected value (remember to check for negation)\r\n     * @param {Mixed} actual (optional) will default to `this.obj`\r\n     * @api private\r\n     */\r\n\r\n    Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\r\n      var ok = util.test(this, arguments);\r\n      if (true !== showDiff) showDiff = false;\r\n      if (true !== Assertion.showDiff) showDiff = false;\r\n\r\n      if (!ok) {\r\n        var msg = util.getMessage(this, arguments)\r\n          , actual = util.getActual(this, arguments);\r\n        throw new AssertionError({\r\n            message: msg\r\n          , actual: actual\r\n          , expected: expected\r\n          , stackStartFunction: (Assertion.includeStack) ? this.assert : flag(this, 'ssfi')\r\n          , showDiff: showDiff\r\n        });\r\n      }\r\n    };\r\n\r\n    /*!\r\n     * ### ._obj\r\n     *\r\n     * Quick reference to stored `actual` value for plugin developers.\r\n     *\r\n     * @api private\r\n     */\r\n\r\n    Object.defineProperty(Assertion.prototype, '_obj',\r\n      { get: function () {\r\n          return flag(this, 'object');\r\n        }\r\n      , set: function (val) {\r\n          flag(this, 'object', val);\r\n        }\r\n    });\r\n\r\n  }); // module: chai/assertion.js\r\n\r\n  require.register(\"chai/core/assertions.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * http://chaijs.com\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    module.exports = function (chai, _) {\r\n      var Assertion = chai.Assertion\r\n        , toString = Object.prototype.toString\r\n        , flag = _.flag;\r\n\r\n      /**\r\n       * ### Language Chains\r\n       *\r\n       * The following are provide as chainable getters to\r\n       * improve the readability of your assertions. They\r\n       * do not provide an testing capability unless they\r\n       * have been overwritten by a plugin.\r\n       *\r\n       * **Chains**\r\n       *\r\n       * - to\r\n       * - be\r\n       * - been\r\n       * - is\r\n       * - that\r\n       * - and\r\n       * - have\r\n       * - with\r\n       * - at\r\n       * - of\r\n       *\r\n       * @name language chains\r\n       * @api public\r\n       */\r\n\r\n      [ 'to', 'be', 'been'\r\n      , 'is', 'and', 'have'\r\n      , 'with', 'that', 'at'\r\n      , 'of' ].forEach(function (chain) {\r\n        Assertion.addProperty(chain, function () {\r\n          return this;\r\n        });\r\n      });\r\n\r\n      /**\r\n       * ### .not\r\n       *\r\n       * Negates any of assertions following in the chain.\r\n       *\r\n       *     expect(foo).to.not.equal('bar');\r\n       *     expect(goodFn).to.not.throw(Error);\r\n       *     expect({ foo: 'baz' }).to.have.property('foo')\r\n       *       .and.not.equal('bar');\r\n       *\r\n       * @name not\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('not', function () {\r\n        flag(this, 'negate', true);\r\n      });\r\n\r\n      /**\r\n       * ### .deep\r\n       *\r\n       * Sets the `deep` flag, later used by the `equal` and\r\n       * `property` assertions.\r\n       *\r\n       *     expect(foo).to.deep.equal({ bar: 'baz' });\r\n       *     expect({ foo: { bar: { baz: 'quux' } } })\r\n       *       .to.have.deep.property('foo.bar.baz', 'quux');\r\n       *\r\n       * @name deep\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('deep', function () {\r\n        flag(this, 'deep', true);\r\n      });\r\n\r\n      /**\r\n       * ### .a(type)\r\n       *\r\n       * The `a` and `an` assertions are aliases that can be\r\n       * used either as language chains or to assert a value's\r\n       * type.\r\n       *\r\n       *     // typeof\r\n       *     expect('test').to.be.a('string');\r\n       *     expect({ foo: 'bar' }).to.be.an('object');\r\n       *     expect(null).to.be.a('null');\r\n       *     expect(undefined).to.be.an('undefined');\r\n       *\r\n       *     // language chain\r\n       *     expect(foo).to.be.an.instanceof(Foo);\r\n       *\r\n       * @name a\r\n       * @alias an\r\n       * @param {String} type\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function an (type, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        type = type.toLowerCase();\r\n        var obj = flag(this, 'object')\r\n          , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\r\n\r\n        this.assert(\r\n            type === _.type(obj)\r\n          , 'expected #{this} to be ' + article + type\r\n          , 'expected #{this} not to be ' + article + type\r\n        );\r\n      }\r\n\r\n      Assertion.addChainableMethod('an', an);\r\n      Assertion.addChainableMethod('a', an);\r\n\r\n      /**\r\n       * ### .include(value)\r\n       *\r\n       * The `include` and `contain` assertions can be used as either property\r\n       * based language chains or as methods to assert the inclusion of an object\r\n       * in an array or a substring in a string. When used as language chains,\r\n       * they toggle the `contain` flag for the `keys` assertion.\r\n       *\r\n       *     expect([1,2,3]).to.include(2);\r\n       *     expect('foobar').to.contain('foo');\r\n       *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\r\n       *\r\n       * @name include\r\n       * @alias contain\r\n       * @param {Object|String|Number} obj\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function includeChainingBehavior () {\r\n        flag(this, 'contains', true);\r\n      }\r\n\r\n      function include (val, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object')\r\n        this.assert(\r\n            ~obj.indexOf(val)\r\n          , 'expected #{this} to include ' + _.inspect(val)\r\n          , 'expected #{this} to not include ' + _.inspect(val));\r\n      }\r\n\r\n      Assertion.addChainableMethod('include', include, includeChainingBehavior);\r\n      Assertion.addChainableMethod('contain', include, includeChainingBehavior);\r\n\r\n      /**\r\n       * ### .ok\r\n       *\r\n       * Asserts that the target is truthy.\r\n       *\r\n       *     expect('everthing').to.be.ok;\r\n       *     expect(1).to.be.ok;\r\n       *     expect(false).to.not.be.ok;\r\n       *     expect(undefined).to.not.be.ok;\r\n       *     expect(null).to.not.be.ok;\r\n       *\r\n       * @name ok\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('ok', function () {\r\n        this.assert(\r\n            flag(this, 'object')\r\n          , 'expected #{this} to be truthy'\r\n          , 'expected #{this} to be falsy');\r\n      });\r\n\r\n      /**\r\n       * ### .true\r\n       *\r\n       * Asserts that the target is `true`.\r\n       *\r\n       *     expect(true).to.be.true;\r\n       *     expect(1).to.not.be.true;\r\n       *\r\n       * @name true\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('true', function () {\r\n        this.assert(\r\n            true === flag(this, 'object')\r\n          , 'expected #{this} to be true'\r\n          , 'expected #{this} to be false'\r\n          , this.negate ? false : true\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .false\r\n       *\r\n       * Asserts that the target is `false`.\r\n       *\r\n       *     expect(false).to.be.false;\r\n       *     expect(0).to.not.be.false;\r\n       *\r\n       * @name false\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('false', function () {\r\n        this.assert(\r\n            false === flag(this, 'object')\r\n          , 'expected #{this} to be false'\r\n          , 'expected #{this} to be true'\r\n          , this.negate ? true : false\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .null\r\n       *\r\n       * Asserts that the target is `null`.\r\n       *\r\n       *     expect(null).to.be.null;\r\n       *     expect(undefined).not.to.be.null;\r\n       *\r\n       * @name null\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('null', function () {\r\n        this.assert(\r\n            null === flag(this, 'object')\r\n          , 'expected #{this} to be null'\r\n          , 'expected #{this} not to be null'\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .undefined\r\n       *\r\n       * Asserts that the target is `undefined`.\r\n       *\r\n       *      expect(undefined).to.be.undefined;\r\n       *      expect(null).to.not.be.undefined;\r\n       *\r\n       * @name undefined\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('undefined', function () {\r\n        this.assert(\r\n            undefined === flag(this, 'object')\r\n          , 'expected #{this} to be undefined'\r\n          , 'expected #{this} not to be undefined'\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .exist\r\n       *\r\n       * Asserts that the target is neither `null` nor `undefined`.\r\n       *\r\n       *     var foo = 'hi'\r\n       *       , bar = null\r\n       *       , baz;\r\n       *\r\n       *     expect(foo).to.exist;\r\n       *     expect(bar).to.not.exist;\r\n       *     expect(baz).to.not.exist;\r\n       *\r\n       * @name exist\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('exist', function () {\r\n        this.assert(\r\n            null != flag(this, 'object')\r\n          , 'expected #{this} to exist'\r\n          , 'expected #{this} to not exist'\r\n        );\r\n      });\r\n\r\n\r\n      /**\r\n       * ### .empty\r\n       *\r\n       * Asserts that the target's length is `0`. For arrays, it checks\r\n       * the `length` property. For objects, it gets the count of\r\n       * enumerable keys.\r\n       *\r\n       *     expect([]).to.be.empty;\r\n       *     expect('').to.be.empty;\r\n       *     expect({}).to.be.empty;\r\n       *\r\n       * @name empty\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('empty', function () {\r\n        var obj = flag(this, 'object')\r\n          , expected = obj;\r\n\r\n        if (Array.isArray(obj) || 'string' === typeof object) {\r\n          expected = obj.length;\r\n        } else if (typeof obj === 'object') {\r\n          expected = Object.keys(obj).length;\r\n        }\r\n\r\n        this.assert(\r\n            !expected\r\n          , 'expected #{this} to be empty'\r\n          , 'expected #{this} not to be empty'\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .arguments\r\n       *\r\n       * Asserts that the target is an arguments object.\r\n       *\r\n       *     function test () {\r\n       *       expect(arguments).to.be.arguments;\r\n       *     }\r\n       *\r\n       * @name arguments\r\n       * @alias Arguments\r\n       * @api public\r\n       */\r\n\r\n      function checkArguments () {\r\n        var obj = flag(this, 'object')\r\n          , type = Object.prototype.toString.call(obj);\r\n        this.assert(\r\n            '[object Arguments]' === type\r\n          , 'expected #{this} to be arguments but got ' + type\r\n          , 'expected #{this} to not be arguments'\r\n        );\r\n      }\r\n\r\n      Assertion.addProperty('arguments', checkArguments);\r\n      Assertion.addProperty('Arguments', checkArguments);\r\n\r\n      /**\r\n       * ### .equal(value)\r\n       *\r\n       * Asserts that the target is strictly equal (`===`) to `value`.\r\n       * Alternately, if the `deep` flag is set, asserts that\r\n       * the target is deeply equal to `value`.\r\n       *\r\n       *     expect('hello').to.equal('hello');\r\n       *     expect(42).to.equal(42);\r\n       *     expect(1).to.not.equal(true);\r\n       *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\r\n       *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\r\n       *\r\n       * @name equal\r\n       * @alias equals\r\n       * @alias eq\r\n       * @alias deep.equal\r\n       * @param {Mixed} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertEqual (val, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        if (flag(this, 'deep')) {\r\n          return this.eql(val);\r\n        } else {\r\n          this.assert(\r\n              val === obj\r\n            , 'expected #{this} to equal #{exp}'\r\n            , 'expected #{this} to not equal #{exp}'\r\n            , val\r\n            , this._obj\r\n            , true\r\n          );\r\n        }\r\n      }\r\n\r\n      Assertion.addMethod('equal', assertEqual);\r\n      Assertion.addMethod('equals', assertEqual);\r\n      Assertion.addMethod('eq', assertEqual);\r\n\r\n      /**\r\n       * ### .eql(value)\r\n       *\r\n       * Asserts that the target is deeply equal to `value`.\r\n       *\r\n       *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\r\n       *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\r\n       *\r\n       * @name eql\r\n       * @alias eqls\r\n       * @param {Mixed} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertEql(obj, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        this.assert(\r\n            _.eql(obj, flag(this, 'object'))\r\n          , 'expected #{this} to deeply equal #{exp}'\r\n          , 'expected #{this} to not deeply equal #{exp}'\r\n          , obj\r\n          , this._obj\r\n          , true\r\n        );\r\n      }\r\n\r\n      Assertion.addMethod('eql', assertEql);\r\n      Assertion.addMethod('eqls', assertEql);\r\n\r\n      /**\r\n       * ### .above(value)\r\n       *\r\n       * Asserts that the target is greater than `value`.\r\n       *\r\n       *     expect(10).to.be.above(5);\r\n       *\r\n       * Can also be used in conjunction with `length` to\r\n       * assert a minimum length. The benefit being a\r\n       * more informative error message than if the length\r\n       * was supplied directly.\r\n       *\r\n       *     expect('foo').to.have.length.above(2);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.above(2);\r\n       *\r\n       * @name above\r\n       * @alias gt\r\n       * @alias greaterThan\r\n       * @param {Number} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertAbove (n, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        if (flag(this, 'doLength')) {\r\n          new Assertion(obj, msg).to.have.property('length');\r\n          var len = obj.length;\r\n          this.assert(\r\n              len > n\r\n            , 'expected #{this} to have a length above #{exp} but got #{act}'\r\n            , 'expected #{this} to not have a length above #{exp}'\r\n            , n\r\n            , len\r\n          );\r\n        } else {\r\n          this.assert(\r\n              obj > n\r\n            , 'expected #{this} to be above ' + n\r\n            , 'expected #{this} to be at most ' + n\r\n          );\r\n        }\r\n      }\r\n\r\n      Assertion.addMethod('above', assertAbove);\r\n      Assertion.addMethod('gt', assertAbove);\r\n      Assertion.addMethod('greaterThan', assertAbove);\r\n\r\n      /**\r\n       * ### .least(value)\r\n       *\r\n       * Asserts that the target is greater than or equal to `value`.\r\n       *\r\n       *     expect(10).to.be.at.least(10);\r\n       *\r\n       * Can also be used in conjunction with `length` to\r\n       * assert a minimum length. The benefit being a\r\n       * more informative error message than if the length\r\n       * was supplied directly.\r\n       *\r\n       *     expect('foo').to.have.length.of.at.least(2);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\r\n       *\r\n       * @name least\r\n       * @alias gte\r\n       * @param {Number} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertLeast (n, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        if (flag(this, 'doLength')) {\r\n          new Assertion(obj, msg).to.have.property('length');\r\n          var len = obj.length;\r\n          this.assert(\r\n              len >= n\r\n            , 'expected #{this} to have a length at least #{exp} but got #{act}'\r\n            , 'expected #{this} to have a length below #{exp}'\r\n            , n\r\n            , len\r\n          );\r\n        } else {\r\n          this.assert(\r\n              obj >= n\r\n            , 'expected #{this} to be at least ' + n\r\n            , 'expected #{this} to be below ' + n\r\n          );\r\n        }\r\n      }\r\n\r\n      Assertion.addMethod('least', assertLeast);\r\n      Assertion.addMethod('gte', assertLeast);\r\n\r\n      /**\r\n       * ### .below(value)\r\n       *\r\n       * Asserts that the target is less than `value`.\r\n       *\r\n       *     expect(5).to.be.below(10);\r\n       *\r\n       * Can also be used in conjunction with `length` to\r\n       * assert a maximum length. The benefit being a\r\n       * more informative error message than if the length\r\n       * was supplied directly.\r\n       *\r\n       *     expect('foo').to.have.length.below(4);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.below(4);\r\n       *\r\n       * @name below\r\n       * @alias lt\r\n       * @alias lessThan\r\n       * @param {Number} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertBelow (n, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        if (flag(this, 'doLength')) {\r\n          new Assertion(obj, msg).to.have.property('length');\r\n          var len = obj.length;\r\n          this.assert(\r\n              len < n\r\n            , 'expected #{this} to have a length below #{exp} but got #{act}'\r\n            , 'expected #{this} to not have a length below #{exp}'\r\n            , n\r\n            , len\r\n          );\r\n        } else {\r\n          this.assert(\r\n              obj < n\r\n            , 'expected #{this} to be below ' + n\r\n            , 'expected #{this} to be at least ' + n\r\n          );\r\n        }\r\n      }\r\n\r\n      Assertion.addMethod('below', assertBelow);\r\n      Assertion.addMethod('lt', assertBelow);\r\n      Assertion.addMethod('lessThan', assertBelow);\r\n\r\n      /**\r\n       * ### .most(value)\r\n       *\r\n       * Asserts that the target is less than or equal to `value`.\r\n       *\r\n       *     expect(5).to.be.at.most(5);\r\n       *\r\n       * Can also be used in conjunction with `length` to\r\n       * assert a maximum length. The benefit being a\r\n       * more informative error message than if the length\r\n       * was supplied directly.\r\n       *\r\n       *     expect('foo').to.have.length.of.at.most(4);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\r\n       *\r\n       * @name most\r\n       * @alias lte\r\n       * @param {Number} value\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertMost (n, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        if (flag(this, 'doLength')) {\r\n          new Assertion(obj, msg).to.have.property('length');\r\n          var len = obj.length;\r\n          this.assert(\r\n              len <= n\r\n            , 'expected #{this} to have a length at most #{exp} but got #{act}'\r\n            , 'expected #{this} to have a length above #{exp}'\r\n            , n\r\n            , len\r\n          );\r\n        } else {\r\n          this.assert(\r\n              obj <= n\r\n            , 'expected #{this} to be at most ' + n\r\n            , 'expected #{this} to be above ' + n\r\n          );\r\n        }\r\n      }\r\n\r\n      Assertion.addMethod('most', assertMost);\r\n      Assertion.addMethod('lte', assertMost);\r\n\r\n      /**\r\n       * ### .within(start, finish)\r\n       *\r\n       * Asserts that the target is within a range.\r\n       *\r\n       *     expect(7).to.be.within(5,10);\r\n       *\r\n       * Can also be used in conjunction with `length` to\r\n       * assert a length range. The benefit being a\r\n       * more informative error message than if the length\r\n       * was supplied directly.\r\n       *\r\n       *     expect('foo').to.have.length.within(2,4);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\r\n       *\r\n       * @name within\r\n       * @param {Number} start lowerbound inclusive\r\n       * @param {Number} finish upperbound inclusive\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('within', function (start, finish, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object')\r\n          , range = start + '..' + finish;\r\n        if (flag(this, 'doLength')) {\r\n          new Assertion(obj, msg).to.have.property('length');\r\n          var len = obj.length;\r\n          this.assert(\r\n              len >= start && len <= finish\r\n            , 'expected #{this} to have a length within ' + range\r\n            , 'expected #{this} to not have a length within ' + range\r\n          );\r\n        } else {\r\n          this.assert(\r\n              obj >= start && obj <= finish\r\n            , 'expected #{this} to be within ' + range\r\n            , 'expected #{this} to not be within ' + range\r\n          );\r\n        }\r\n      });\r\n\r\n      /**\r\n       * ### .instanceof(constructor)\r\n       *\r\n       * Asserts that the target is an instance of `constructor`.\r\n       *\r\n       *     var Tea = function (name) { this.name = name; }\r\n       *       , Chai = new Tea('chai');\r\n       *\r\n       *     expect(Chai).to.be.an.instanceof(Tea);\r\n       *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\r\n       *\r\n       * @name instanceof\r\n       * @param {Constructor} constructor\r\n       * @param {String} message _optional_\r\n       * @alias instanceOf\r\n       * @api public\r\n       */\r\n\r\n      function assertInstanceOf (constructor, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var name = _.getName(constructor);\r\n        this.assert(\r\n            flag(this, 'object') instanceof constructor\r\n          , 'expected #{this} to be an instance of ' + name\r\n          , 'expected #{this} to not be an instance of ' + name\r\n        );\r\n      };\r\n\r\n      Assertion.addMethod('instanceof', assertInstanceOf);\r\n      Assertion.addMethod('instanceOf', assertInstanceOf);\r\n\r\n      /**\r\n       * ### .property(name, [value])\r\n       *\r\n       * Asserts that the target has a property `name`, optionally asserting that\r\n       * the value of that property is strictly equal to  `value`.\r\n       * If the `deep` flag is set, you can use dot- and bracket-notation for deep\r\n       * references into objects and arrays.\r\n       *\r\n       *     // simple referencing\r\n       *     var obj = { foo: 'bar' };\r\n       *     expect(obj).to.have.property('foo');\r\n       *     expect(obj).to.have.property('foo', 'bar');\r\n       *\r\n       *     // deep referencing\r\n       *     var deepObj = {\r\n       *         green: { tea: 'matcha' }\r\n       *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\r\n       *     };\r\n\r\n       *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\r\n       *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\r\n       *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\r\n       *\r\n       * You can also use an array as the starting point of a `deep.property`\r\n       * assertion, or traverse nested arrays.\r\n       *\r\n       *     var arr = [\r\n       *         [ 'chai', 'matcha', 'konacha' ]\r\n       *       , [ { tea: 'chai' }\r\n       *         , { tea: 'matcha' }\r\n       *         , { tea: 'konacha' } ]\r\n       *     ];\r\n       *\r\n       *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\r\n       *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\r\n       *\r\n       * Furthermore, `property` changes the subject of the assertion\r\n       * to be the value of that property from the original object. This\r\n       * permits for further chainable assertions on that property.\r\n       *\r\n       *     expect(obj).to.have.property('foo')\r\n       *       .that.is.a('string');\r\n       *     expect(deepObj).to.have.property('green')\r\n       *       .that.is.an('object')\r\n       *       .that.deep.equals({ tea: 'matcha' });\r\n       *     expect(deepObj).to.have.property('teas')\r\n       *       .that.is.an('array')\r\n       *       .with.deep.property('[2]')\r\n       *         .that.deep.equals({ tea: 'konacha' });\r\n       *\r\n       * @name property\r\n       * @alias deep.property\r\n       * @param {String} name\r\n       * @param {Mixed} value (optional)\r\n       * @param {String} message _optional_\r\n       * @returns value of property for chaining\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('property', function (name, val, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n\r\n        var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '\r\n          , negate = flag(this, 'negate')\r\n          , obj = flag(this, 'object')\r\n          , value = flag(this, 'deep')\r\n            ? _.getPathValue(name, obj)\r\n            : obj[name];\r\n\r\n        if (negate && undefined !== val) {\r\n          if (undefined === value) {\r\n            msg = (msg != null) ? msg + ': ' : '';\r\n            throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\r\n          }\r\n        } else {\r\n          this.assert(\r\n              undefined !== value\r\n            , 'expected #{this} to have a ' + descriptor + _.inspect(name)\r\n            , 'expected #{this} to not have ' + descriptor + _.inspect(name));\r\n        }\r\n\r\n        if (undefined !== val) {\r\n          this.assert(\r\n              val === value\r\n            , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\r\n            , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\r\n            , val\r\n            , value\r\n          );\r\n        }\r\n\r\n        flag(this, 'object', value);\r\n      });\r\n\r\n\r\n      /**\r\n       * ### .ownProperty(name)\r\n       *\r\n       * Asserts that the target has an own property `name`.\r\n       *\r\n       *     expect('test').to.have.ownProperty('length');\r\n       *\r\n       * @name ownProperty\r\n       * @alias haveOwnProperty\r\n       * @param {String} name\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertOwnProperty (name, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        this.assert(\r\n            obj.hasOwnProperty(name)\r\n          , 'expected #{this} to have own property ' + _.inspect(name)\r\n          , 'expected #{this} to not have own property ' + _.inspect(name)\r\n        );\r\n      }\r\n\r\n      Assertion.addMethod('ownProperty', assertOwnProperty);\r\n      Assertion.addMethod('haveOwnProperty', assertOwnProperty);\r\n\r\n      /**\r\n       * ### .length(value)\r\n       *\r\n       * Asserts that the target's `length` property has\r\n       * the expected value.\r\n       *\r\n       *     expect([ 1, 2, 3]).to.have.length(3);\r\n       *     expect('foobar').to.have.length(6);\r\n       *\r\n       * Can also be used as a chain precursor to a value\r\n       * comparison for the length property.\r\n       *\r\n       *     expect('foo').to.have.length.above(2);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.above(2);\r\n       *     expect('foo').to.have.length.below(4);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.below(4);\r\n       *     expect('foo').to.have.length.within(2,4);\r\n       *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\r\n       *\r\n       * @name length\r\n       * @alias lengthOf\r\n       * @param {Number} length\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      function assertLengthChain () {\r\n        flag(this, 'doLength', true);\r\n      }\r\n\r\n      function assertLength (n, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        new Assertion(obj, msg).to.have.property('length');\r\n        var len = obj.length;\r\n\r\n        this.assert(\r\n            len == n\r\n          , 'expected #{this} to have a length of #{exp} but got #{act}'\r\n          , 'expected #{this} to not have a length of #{act}'\r\n          , n\r\n          , len\r\n        );\r\n      }\r\n\r\n      Assertion.addChainableMethod('length', assertLength, assertLengthChain);\r\n      Assertion.addMethod('lengthOf', assertLength, assertLengthChain);\r\n\r\n      /**\r\n       * ### .match(regexp)\r\n       *\r\n       * Asserts that the target matches a regular expression.\r\n       *\r\n       *     expect('foobar').to.match(/^foo/);\r\n       *\r\n       * @name match\r\n       * @param {RegExp} RegularExpression\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('match', function (re, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        this.assert(\r\n            re.exec(obj)\r\n          , 'expected #{this} to match ' + re\r\n          , 'expected #{this} not to match ' + re\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .string(string)\r\n       *\r\n       * Asserts that the string target contains another string.\r\n       *\r\n       *     expect('foobar').to.have.string('bar');\r\n       *\r\n       * @name string\r\n       * @param {String} string\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('string', function (str, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        new Assertion(obj, msg).is.a('string');\r\n\r\n        this.assert(\r\n            ~obj.indexOf(str)\r\n          , 'expected #{this} to contain ' + _.inspect(str)\r\n          , 'expected #{this} to not contain ' + _.inspect(str)\r\n        );\r\n      });\r\n\r\n\r\n      /**\r\n       * ### .keys(key1, [key2], [...])\r\n       *\r\n       * Asserts that the target has exactly the given keys, or\r\n       * asserts the inclusion of some keys when using the\r\n       * `include` or `contain` modifiers.\r\n       *\r\n       *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);\r\n       *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');\r\n       *\r\n       * @name keys\r\n       * @alias key\r\n       * @param {String...|Array} keys\r\n       * @api public\r\n       */\r\n\r\n      function assertKeys (keys) {\r\n        var obj = flag(this, 'object')\r\n          , str\r\n          , ok = true;\r\n\r\n        keys = keys instanceof Array\r\n          ? keys\r\n          : Array.prototype.slice.call(arguments);\r\n\r\n        if (!keys.length) throw new Error('keys required');\r\n\r\n        var actual = Object.keys(obj)\r\n          , len = keys.length;\r\n\r\n        // Inclusion\r\n        ok = keys.every(function(key){\r\n          return ~actual.indexOf(key);\r\n        });\r\n\r\n        // Strict\r\n        if (!flag(this, 'negate') && !flag(this, 'contains')) {\r\n          ok = ok && keys.length == actual.length;\r\n        }\r\n\r\n        // Key string\r\n        if (len > 1) {\r\n          keys = keys.map(function(key){\r\n            return _.inspect(key);\r\n          });\r\n          var last = keys.pop();\r\n          str = keys.join(', ') + ', and ' + last;\r\n        } else {\r\n          str = _.inspect(keys[0]);\r\n        }\r\n\r\n        // Form\r\n        str = (len > 1 ? 'keys ' : 'key ') + str;\r\n\r\n        // Have / include\r\n        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\r\n\r\n        // Assertion\r\n        this.assert(\r\n            ok\r\n          , 'expected #{this} to ' + str\r\n          , 'expected #{this} to not ' + str\r\n        );\r\n      }\r\n\r\n      Assertion.addMethod('keys', assertKeys);\r\n      Assertion.addMethod('key', assertKeys);\r\n\r\n      /**\r\n       * ### .throw(constructor)\r\n       *\r\n       * Asserts that the function target will throw a specific error, or specific type of error\r\n       * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\r\n       * for the error's message.\r\n       *\r\n       *     var err = new ReferenceError('This is a bad function.');\r\n       *     var fn = function () { throw err; }\r\n       *     expect(fn).to.throw(ReferenceError);\r\n       *     expect(fn).to.throw(Error);\r\n       *     expect(fn).to.throw(/bad function/);\r\n       *     expect(fn).to.not.throw('good function');\r\n       *     expect(fn).to.throw(ReferenceError, /bad function/);\r\n       *     expect(fn).to.throw(err);\r\n       *     expect(fn).to.not.throw(new RangeError('Out of range.'));\r\n       *\r\n       * Please note that when a throw expectation is negated, it will check each\r\n       * parameter independently, starting with error constructor type. The appropriate way\r\n       * to check for the existence of a type of error but for a message that does not match\r\n       * is to use `and`.\r\n       *\r\n       *     expect(fn).to.throw(ReferenceError)\r\n       *        .and.not.throw(/good function/);\r\n       *\r\n       * @name throw\r\n       * @alias throws\r\n       * @alias Throw\r\n       * @param {ErrorConstructor} constructor\r\n       * @param {String|RegExp} expected error message\r\n       * @param {String} message _optional_\r\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n       * @api public\r\n       */\r\n\r\n      function assertThrows (constructor, errMsg, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        new Assertion(obj, msg).is.a('function');\r\n\r\n        var thrown = false\r\n          , desiredError = null\r\n          , name = null\r\n          , thrownError = null;\r\n\r\n        if (arguments.length === 0) {\r\n          errMsg = null;\r\n          constructor = null;\r\n        } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\r\n          errMsg = constructor;\r\n          constructor = null;\r\n        } else if (constructor && constructor instanceof Error) {\r\n          desiredError = constructor;\r\n          constructor = null;\r\n          errMsg = null;\r\n        } else if (typeof constructor === 'function') {\r\n          name = (new constructor()).name;\r\n        } else {\r\n          constructor = null;\r\n        }\r\n\r\n        try {\r\n          obj();\r\n        } catch (err) {\r\n          // first, check desired error\r\n          if (desiredError) {\r\n            this.assert(\r\n                err === desiredError\r\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\r\n              , 'expected #{this} to not throw #{exp}'\r\n              , desiredError\r\n              , err\r\n            );\r\n\r\n            return this;\r\n          }\r\n          // next, check constructor\r\n          if (constructor) {\r\n            this.assert(\r\n                err instanceof constructor\r\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\r\n              , 'expected #{this} to not throw #{exp} but #{act} was thrown'\r\n              , name\r\n              , err\r\n            );\r\n\r\n            if (!errMsg) return this;\r\n          }\r\n          // next, check message\r\n          var message = 'object' === _.type(err) && \"message\" in err\r\n            ? err.message\r\n            : '' + err;\r\n\r\n          if ((message != null) && errMsg && errMsg instanceof RegExp) {\r\n            this.assert(\r\n                errMsg.exec(message)\r\n              , 'expected #{this} to throw error matching #{exp} but got #{act}'\r\n              , 'expected #{this} to throw error not matching #{exp}'\r\n              , errMsg\r\n              , message\r\n            );\r\n\r\n            return this;\r\n          } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\r\n            this.assert(\r\n                ~message.indexOf(errMsg)\r\n              , 'expected #{this} to throw error including #{exp} but got #{act}'\r\n              , 'expected #{this} to throw error not including #{act}'\r\n              , errMsg\r\n              , message\r\n            );\r\n\r\n            return this;\r\n          } else {\r\n            thrown = true;\r\n            thrownError = err;\r\n          }\r\n        }\r\n\r\n        var actuallyGot = ''\r\n          , expectedThrown = name !== null\r\n            ? name\r\n            : desiredError\r\n              ? '#{exp}' //_.inspect(desiredError)\r\n              : 'an error';\r\n\r\n        if (thrown) {\r\n          actuallyGot = ' but #{act} was thrown'\r\n        }\r\n\r\n        this.assert(\r\n            thrown === true\r\n          , 'expected #{this} to throw ' + expectedThrown + actuallyGot\r\n          , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\r\n          , desiredError\r\n          , thrownError\r\n        );\r\n      };\r\n\r\n      Assertion.addMethod('throw', assertThrows);\r\n      Assertion.addMethod('throws', assertThrows);\r\n      Assertion.addMethod('Throw', assertThrows);\r\n\r\n      /**\r\n       * ### .respondTo(method)\r\n       *\r\n       * Asserts that the object or class target will respond to a method.\r\n       *\r\n       *     Klass.prototype.bar = function(){};\r\n       *     expect(Klass).to.respondTo('bar');\r\n       *     expect(obj).to.respondTo('bar');\r\n       *\r\n       * To check if a constructor will respond to a static function,\r\n       * set the `itself` flag.\r\n       *\r\n       *    Klass.baz = function(){};\r\n       *    expect(Klass).itself.to.respondTo('baz');\r\n       *\r\n       * @name respondTo\r\n       * @param {String} method\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('respondTo', function (method, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object')\r\n          , itself = flag(this, 'itself')\r\n          , context = ('function' === _.type(obj) && !itself)\r\n            ? obj.prototype[method]\r\n            : obj[method];\r\n\r\n        this.assert(\r\n            'function' === typeof context\r\n          , 'expected #{this} to respond to ' + _.inspect(method)\r\n          , 'expected #{this} to not respond to ' + _.inspect(method)\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .itself\r\n       *\r\n       * Sets the `itself` flag, later used by the `respondTo` assertion.\r\n       *\r\n       *    function Foo() {}\r\n       *    Foo.bar = function() {}\r\n       *    Foo.prototype.baz = function() {}\r\n       *\r\n       *    expect(Foo).itself.to.respondTo('bar');\r\n       *    expect(Foo).itself.not.to.respondTo('baz');\r\n       *\r\n       * @name itself\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addProperty('itself', function () {\r\n        flag(this, 'itself', true);\r\n      });\r\n\r\n      /**\r\n       * ### .satisfy(method)\r\n       *\r\n       * Asserts that the target passes a given truth test.\r\n       *\r\n       *     expect(1).to.satisfy(function(num) { return num > 0; });\r\n       *\r\n       * @name satisfy\r\n       * @param {Function} matcher\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('satisfy', function (matcher, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        this.assert(\r\n            matcher(obj)\r\n          , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\r\n          , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\r\n          , this.negate ? false : true\r\n          , matcher(obj)\r\n        );\r\n      });\r\n\r\n      /**\r\n       * ### .closeTo(expected, delta)\r\n       *\r\n       * Asserts that the target is equal `expected`, to within a +/- `delta` range.\r\n       *\r\n       *     expect(1.5).to.be.closeTo(1, 0.5);\r\n       *\r\n       * @name closeTo\r\n       * @param {Number} expected\r\n       * @param {Number} delta\r\n       * @param {String} message _optional_\r\n       * @api public\r\n       */\r\n\r\n      Assertion.addMethod('closeTo', function (expected, delta, msg) {\r\n        if (msg) flag(this, 'message', msg);\r\n        var obj = flag(this, 'object');\r\n        this.assert(\r\n            Math.abs(obj - expected) <= delta\r\n          , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\r\n          , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\r\n        );\r\n      });\r\n\r\n    };\r\n\r\n  }); // module: chai/core/assertions.js\r\n\r\n  require.register(\"chai/error.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Main export\r\n     */\r\n\r\n    module.exports = AssertionError;\r\n\r\n    /**\r\n     * # AssertionError (constructor)\r\n     *\r\n     * Create a new assertion error based on the Javascript\r\n     * `Error` prototype.\r\n     *\r\n     * **Options**\r\n     * - message\r\n     * - actual\r\n     * - expected\r\n     * - operator\r\n     * - startStackFunction\r\n     *\r\n     * @param {Object} options\r\n     * @api public\r\n     */\r\n\r\n    function AssertionError (options) {\r\n      options = options || {};\r\n      this.message = options.message;\r\n      this.actual = options.actual;\r\n      this.expected = options.expected;\r\n      this.operator = options.operator;\r\n      this.showDiff = options.showDiff;\r\n\r\n      if (options.stackStartFunction && Error.captureStackTrace) {\r\n        var stackStartFunction = options.stackStartFunction;\r\n        Error.captureStackTrace(this, stackStartFunction);\r\n      }\r\n    }\r\n\r\n    /*!\r\n     * Inherit from Error\r\n     */\r\n\r\n    AssertionError.prototype = Object.create(Error.prototype);\r\n    AssertionError.prototype.name = 'AssertionError';\r\n    AssertionError.prototype.constructor = AssertionError;\r\n\r\n    /**\r\n     * # toString()\r\n     *\r\n     * Override default to string method\r\n     */\r\n\r\n    AssertionError.prototype.toString = function() {\r\n      return this.message;\r\n    };\r\n\r\n  }); // module: chai/error.js\r\n\r\n  require.register(\"chai/interface/assert.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n\r\n    module.exports = function (chai, util) {\r\n\r\n      /*!\r\n       * Chai dependencies.\r\n       */\r\n\r\n      var Assertion = chai.Assertion\r\n        , flag = util.flag;\r\n\r\n      /*!\r\n       * Module export.\r\n       */\r\n\r\n      /**\r\n       * ### assert(expression, message)\r\n       *\r\n       * Write your own test expressions.\r\n       *\r\n       *     assert('foo' !== 'bar', 'foo is not bar');\r\n       *     assert(Array.isArray([]), 'empty arrays are arrays');\r\n       *\r\n       * @param {Mixed} expression to test for truthiness\r\n       * @param {String} message to display on error\r\n       * @name assert\r\n       * @api public\r\n       */\r\n\r\n      var assert = chai.assert = function (express, errmsg) {\r\n        var test = new Assertion(null);\r\n        test.assert(\r\n            express\r\n          , errmsg\r\n          , '[ negation message unavailable ]'\r\n        );\r\n      };\r\n\r\n      /**\r\n       * ### .fail(actual, expected, [message], [operator])\r\n       *\r\n       * Throw a failure. Node.js `assert` module-compatible.\r\n       *\r\n       * @name fail\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @param {String} operator\r\n       * @api public\r\n       */\r\n\r\n      assert.fail = function (actual, expected, message, operator) {\r\n        throw new chai.AssertionError({\r\n            actual: actual\r\n          , expected: expected\r\n          , message: message\r\n          , operator: operator\r\n          , stackStartFunction: assert.fail\r\n        });\r\n      };\r\n\r\n      /**\r\n       * ### .ok(object, [message])\r\n       *\r\n       * Asserts that `object` is truthy.\r\n       *\r\n       *     assert.ok('everything', 'everything is ok');\r\n       *     assert.ok(false, 'this will fail');\r\n       *\r\n       * @name ok\r\n       * @param {Mixed} object to test\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.ok = function (val, msg) {\r\n        new Assertion(val, msg).is.ok;\r\n      };\r\n\r\n      /**\r\n       * ### .equal(actual, expected, [message])\r\n       *\r\n       * Asserts non-strict equality (`==`) of `actual` and `expected`.\r\n       *\r\n       *     assert.equal(3, '3', '== coerces values to strings');\r\n       *\r\n       * @name equal\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.equal = function (act, exp, msg) {\r\n        var test = new Assertion(act, msg);\r\n\r\n        test.assert(\r\n            exp == flag(test, 'object')\r\n          , 'expected #{this} to equal #{exp}'\r\n          , 'expected #{this} to not equal #{act}'\r\n          , exp\r\n          , act\r\n        );\r\n      };\r\n\r\n      /**\r\n       * ### .notEqual(actual, expected, [message])\r\n       *\r\n       * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\r\n       *\r\n       *     assert.notEqual(3, 4, 'these numbers are not equal');\r\n       *\r\n       * @name notEqual\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notEqual = function (act, exp, msg) {\r\n        var test = new Assertion(act, msg);\r\n\r\n        test.assert(\r\n            exp != flag(test, 'object')\r\n          , 'expected #{this} to not equal #{exp}'\r\n          , 'expected #{this} to equal #{act}'\r\n          , exp\r\n          , act\r\n        );\r\n      };\r\n\r\n      /**\r\n       * ### .strictEqual(actual, expected, [message])\r\n       *\r\n       * Asserts strict equality (`===`) of `actual` and `expected`.\r\n       *\r\n       *     assert.strictEqual(true, true, 'these booleans are strictly equal');\r\n       *\r\n       * @name strictEqual\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.strictEqual = function (act, exp, msg) {\r\n        new Assertion(act, msg).to.equal(exp);\r\n      };\r\n\r\n      /**\r\n       * ### .notStrictEqual(actual, expected, [message])\r\n       *\r\n       * Asserts strict inequality (`!==`) of `actual` and `expected`.\r\n       *\r\n       *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\r\n       *\r\n       * @name notStrictEqual\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notStrictEqual = function (act, exp, msg) {\r\n        new Assertion(act, msg).to.not.equal(exp);\r\n      };\r\n\r\n      /**\r\n       * ### .deepEqual(actual, expected, [message])\r\n       *\r\n       * Asserts that `actual` is deeply equal to `expected`.\r\n       *\r\n       *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\r\n       *\r\n       * @name deepEqual\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.deepEqual = function (act, exp, msg) {\r\n        new Assertion(act, msg).to.eql(exp);\r\n      };\r\n\r\n      /**\r\n       * ### .notDeepEqual(actual, expected, [message])\r\n       *\r\n       * Assert that `actual` is not deeply equal to `expected`.\r\n       *\r\n       *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\r\n       *\r\n       * @name notDeepEqual\r\n       * @param {Mixed} actual\r\n       * @param {Mixed} expected\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notDeepEqual = function (act, exp, msg) {\r\n        new Assertion(act, msg).to.not.eql(exp);\r\n      };\r\n\r\n      /**\r\n       * ### .isTrue(value, [message])\r\n       *\r\n       * Asserts that `value` is true.\r\n       *\r\n       *     var teaServed = true;\r\n       *     assert.isTrue(teaServed, 'the tea has been served');\r\n       *\r\n       * @name isTrue\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isTrue = function (val, msg) {\r\n        new Assertion(val, msg).is['true'];\r\n      };\r\n\r\n      /**\r\n       * ### .isFalse(value, [message])\r\n       *\r\n       * Asserts that `value` is false.\r\n       *\r\n       *     var teaServed = false;\r\n       *     assert.isFalse(teaServed, 'no tea yet? hmm...');\r\n       *\r\n       * @name isFalse\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isFalse = function (val, msg) {\r\n        new Assertion(val, msg).is['false'];\r\n      };\r\n\r\n      /**\r\n       * ### .isNull(value, [message])\r\n       *\r\n       * Asserts that `value` is null.\r\n       *\r\n       *     assert.isNull(err, 'there was no error');\r\n       *\r\n       * @name isNull\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNull = function (val, msg) {\r\n        new Assertion(val, msg).to.equal(null);\r\n      };\r\n\r\n      /**\r\n       * ### .isNotNull(value, [message])\r\n       *\r\n       * Asserts that `value` is not null.\r\n       *\r\n       *     var tea = 'tasty chai';\r\n       *     assert.isNotNull(tea, 'great, time for tea!');\r\n       *\r\n       * @name isNotNull\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotNull = function (val, msg) {\r\n        new Assertion(val, msg).to.not.equal(null);\r\n      };\r\n\r\n      /**\r\n       * ### .isUndefined(value, [message])\r\n       *\r\n       * Asserts that `value` is `undefined`.\r\n       *\r\n       *     var tea;\r\n       *     assert.isUndefined(tea, 'no tea defined');\r\n       *\r\n       * @name isUndefined\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isUndefined = function (val, msg) {\r\n        new Assertion(val, msg).to.equal(undefined);\r\n      };\r\n\r\n      /**\r\n       * ### .isDefined(value, [message])\r\n       *\r\n       * Asserts that `value` is not `undefined`.\r\n       *\r\n       *     var tea = 'cup of chai';\r\n       *     assert.isDefined(tea, 'tea has been defined');\r\n       *\r\n       * @name isUndefined\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isDefined = function (val, msg) {\r\n        new Assertion(val, msg).to.not.equal(undefined);\r\n      };\r\n\r\n      /**\r\n       * ### .isFunction(value, [message])\r\n       *\r\n       * Asserts that `value` is a function.\r\n       *\r\n       *     function serveTea() { return 'cup of tea'; };\r\n       *     assert.isFunction(serveTea, 'great, we can have tea now');\r\n       *\r\n       * @name isFunction\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isFunction = function (val, msg) {\r\n        new Assertion(val, msg).to.be.a('function');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotFunction(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ a function.\r\n       *\r\n       *     var serveTea = [ 'heat', 'pour', 'sip' ];\r\n       *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\r\n       *\r\n       * @name isNotFunction\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotFunction = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.a('function');\r\n      };\r\n\r\n      /**\r\n       * ### .isObject(value, [message])\r\n       *\r\n       * Asserts that `value` is an object (as revealed by\r\n       * `Object.prototype.toString`).\r\n       *\r\n       *     var selection = { name: 'Chai', serve: 'with spices' };\r\n       *     assert.isObject(selection, 'tea selection is an object');\r\n       *\r\n       * @name isObject\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isObject = function (val, msg) {\r\n        new Assertion(val, msg).to.be.a('object');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotObject(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ an object.\r\n       *\r\n       *     var selection = 'chai'\r\n       *     assert.isObject(selection, 'tea selection is not an object');\r\n       *     assert.isObject(null, 'null is not an object');\r\n       *\r\n       * @name isNotObject\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotObject = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.a('object');\r\n      };\r\n\r\n      /**\r\n       * ### .isArray(value, [message])\r\n       *\r\n       * Asserts that `value` is an array.\r\n       *\r\n       *     var menu = [ 'green', 'chai', 'oolong' ];\r\n       *     assert.isArray(menu, 'what kind of tea do we want?');\r\n       *\r\n       * @name isArray\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isArray = function (val, msg) {\r\n        new Assertion(val, msg).to.be.an('array');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotArray(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ an array.\r\n       *\r\n       *     var menu = 'green|chai|oolong';\r\n       *     assert.isNotArray(menu, 'what kind of tea do we want?');\r\n       *\r\n       * @name isNotArray\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotArray = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.an('array');\r\n      };\r\n\r\n      /**\r\n       * ### .isString(value, [message])\r\n       *\r\n       * Asserts that `value` is a string.\r\n       *\r\n       *     var teaOrder = 'chai';\r\n       *     assert.isString(teaOrder, 'order placed');\r\n       *\r\n       * @name isString\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isString = function (val, msg) {\r\n        new Assertion(val, msg).to.be.a('string');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotString(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ a string.\r\n       *\r\n       *     var teaOrder = 4;\r\n       *     assert.isNotString(teaOrder, 'order placed');\r\n       *\r\n       * @name isNotString\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotString = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.a('string');\r\n      };\r\n\r\n      /**\r\n       * ### .isNumber(value, [message])\r\n       *\r\n       * Asserts that `value` is a number.\r\n       *\r\n       *     var cups = 2;\r\n       *     assert.isNumber(cups, 'how many cups');\r\n       *\r\n       * @name isNumber\r\n       * @param {Number} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNumber = function (val, msg) {\r\n        new Assertion(val, msg).to.be.a('number');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotNumber(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ a number.\r\n       *\r\n       *     var cups = '2 cups please';\r\n       *     assert.isNotNumber(cups, 'how many cups');\r\n       *\r\n       * @name isNotNumber\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotNumber = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.a('number');\r\n      };\r\n\r\n      /**\r\n       * ### .isBoolean(value, [message])\r\n       *\r\n       * Asserts that `value` is a boolean.\r\n       *\r\n       *     var teaReady = true\r\n       *       , teaServed = false;\r\n       *\r\n       *     assert.isBoolean(teaReady, 'is the tea ready');\r\n       *     assert.isBoolean(teaServed, 'has tea been served');\r\n       *\r\n       * @name isBoolean\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isBoolean = function (val, msg) {\r\n        new Assertion(val, msg).to.be.a('boolean');\r\n      };\r\n\r\n      /**\r\n       * ### .isNotBoolean(value, [message])\r\n       *\r\n       * Asserts that `value` is _not_ a boolean.\r\n       *\r\n       *     var teaReady = 'yep'\r\n       *       , teaServed = 'nope';\r\n       *\r\n       *     assert.isNotBoolean(teaReady, 'is the tea ready');\r\n       *     assert.isNotBoolean(teaServed, 'has tea been served');\r\n       *\r\n       * @name isNotBoolean\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.isNotBoolean = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.a('boolean');\r\n      };\r\n\r\n      /**\r\n       * ### .typeOf(value, name, [message])\r\n       *\r\n       * Asserts that `value`'s type is `name`, as determined by\r\n       * `Object.prototype.toString`.\r\n       *\r\n       *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\r\n       *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\r\n       *     assert.typeOf('tea', 'string', 'we have a string');\r\n       *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\r\n       *     assert.typeOf(null, 'null', 'we have a null');\r\n       *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\r\n       *\r\n       * @name typeOf\r\n       * @param {Mixed} value\r\n       * @param {String} name\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.typeOf = function (val, type, msg) {\r\n        new Assertion(val, msg).to.be.a(type);\r\n      };\r\n\r\n      /**\r\n       * ### .notTypeOf(value, name, [message])\r\n       *\r\n       * Asserts that `value`'s type is _not_ `name`, as determined by\r\n       * `Object.prototype.toString`.\r\n       *\r\n       *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\r\n       *\r\n       * @name notTypeOf\r\n       * @param {Mixed} value\r\n       * @param {String} typeof name\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notTypeOf = function (val, type, msg) {\r\n        new Assertion(val, msg).to.not.be.a(type);\r\n      };\r\n\r\n      /**\r\n       * ### .instanceOf(object, constructor, [message])\r\n       *\r\n       * Asserts that `value` is an instance of `constructor`.\r\n       *\r\n       *     var Tea = function (name) { this.name = name; }\r\n       *       , chai = new Tea('chai');\r\n       *\r\n       *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\r\n       *\r\n       * @name instanceOf\r\n       * @param {Object} object\r\n       * @param {Constructor} constructor\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.instanceOf = function (val, type, msg) {\r\n        new Assertion(val, msg).to.be.instanceOf(type);\r\n      };\r\n\r\n      /**\r\n       * ### .notInstanceOf(object, constructor, [message])\r\n       *\r\n       * Asserts `value` is not an instance of `constructor`.\r\n       *\r\n       *     var Tea = function (name) { this.name = name; }\r\n       *       , chai = new String('chai');\r\n       *\r\n       *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\r\n       *\r\n       * @name notInstanceOf\r\n       * @param {Object} object\r\n       * @param {Constructor} constructor\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notInstanceOf = function (val, type, msg) {\r\n        new Assertion(val, msg).to.not.be.instanceOf(type);\r\n      };\r\n\r\n      /**\r\n       * ### .include(haystack, needle, [message])\r\n       *\r\n       * Asserts that `haystack` includes `needle`. Works\r\n       * for strings and arrays.\r\n       *\r\n       *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\r\n       *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\r\n       *\r\n       * @name include\r\n       * @param {Array|String} haystack\r\n       * @param {Mixed} needle\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.include = function (exp, inc, msg) {\r\n        var obj = new Assertion(exp, msg);\r\n\r\n        if (Array.isArray(exp)) {\r\n          obj.to.include(inc);\r\n        } else if ('string' === typeof exp) {\r\n          obj.to.contain.string(inc);\r\n        }\r\n      };\r\n\r\n      /**\r\n       * ### .match(value, regexp, [message])\r\n       *\r\n       * Asserts that `value` matches the regular expression `regexp`.\r\n       *\r\n       *     assert.match('foobar', /^foo/, 'regexp matches');\r\n       *\r\n       * @name match\r\n       * @param {Mixed} value\r\n       * @param {RegExp} regexp\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.match = function (exp, re, msg) {\r\n        new Assertion(exp, msg).to.match(re);\r\n      };\r\n\r\n      /**\r\n       * ### .notMatch(value, regexp, [message])\r\n       *\r\n       * Asserts that `value` does not match the regular expression `regexp`.\r\n       *\r\n       *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\r\n       *\r\n       * @name notMatch\r\n       * @param {Mixed} value\r\n       * @param {RegExp} regexp\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notMatch = function (exp, re, msg) {\r\n        new Assertion(exp, msg).to.not.match(re);\r\n      };\r\n\r\n      /**\r\n       * ### .property(object, property, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property`.\r\n       *\r\n       *     assert.property({ tea: { green: 'matcha' }}, 'tea');\r\n       *\r\n       * @name property\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.property = function (obj, prop, msg) {\r\n        new Assertion(obj, msg).to.have.property(prop);\r\n      };\r\n\r\n      /**\r\n       * ### .notProperty(object, property, [message])\r\n       *\r\n       * Asserts that `object` does _not_ have a property named by `property`.\r\n       *\r\n       *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\r\n       *\r\n       * @name notProperty\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notProperty = function (obj, prop, msg) {\r\n        new Assertion(obj, msg).to.not.have.property(prop);\r\n      };\r\n\r\n      /**\r\n       * ### .deepProperty(object, property, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property`, which can be a\r\n       * string using dot- and bracket-notation for deep reference.\r\n       *\r\n       *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\r\n       *\r\n       * @name deepProperty\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.deepProperty = function (obj, prop, msg) {\r\n        new Assertion(obj, msg).to.have.deep.property(prop);\r\n      };\r\n\r\n      /**\r\n       * ### .notDeepProperty(object, property, [message])\r\n       *\r\n       * Asserts that `object` does _not_ have a property named by `property`, which\r\n       * can be a string using dot- and bracket-notation for deep reference.\r\n       *\r\n       *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\r\n       *\r\n       * @name notDeepProperty\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.notDeepProperty = function (obj, prop, msg) {\r\n        new Assertion(obj, msg).to.not.have.deep.property(prop);\r\n      };\r\n\r\n      /**\r\n       * ### .propertyVal(object, property, value, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property` with value given\r\n       * by `value`.\r\n       *\r\n       *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\r\n       *\r\n       * @name propertyVal\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.propertyVal = function (obj, prop, val, msg) {\r\n        new Assertion(obj, msg).to.have.property(prop, val);\r\n      };\r\n\r\n      /**\r\n       * ### .propertyNotVal(object, property, value, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property`, but with a value\r\n       * different from that given by `value`.\r\n       *\r\n       *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\r\n       *\r\n       * @name propertyNotVal\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.propertyNotVal = function (obj, prop, val, msg) {\r\n        new Assertion(obj, msg).to.not.have.property(prop, val);\r\n      };\r\n\r\n      /**\r\n       * ### .deepPropertyVal(object, property, value, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property` with value given\r\n       * by `value`. `property` can use dot- and bracket-notation for deep\r\n       * reference.\r\n       *\r\n       *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\r\n       *\r\n       * @name deepPropertyVal\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.deepPropertyVal = function (obj, prop, val, msg) {\r\n        new Assertion(obj, msg).to.have.deep.property(prop, val);\r\n      };\r\n\r\n      /**\r\n       * ### .deepPropertyNotVal(object, property, value, [message])\r\n       *\r\n       * Asserts that `object` has a property named by `property`, but with a value\r\n       * different from that given by `value`. `property` can use dot- and\r\n       * bracket-notation for deep reference.\r\n       *\r\n       *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\r\n       *\r\n       * @name deepPropertyNotVal\r\n       * @param {Object} object\r\n       * @param {String} property\r\n       * @param {Mixed} value\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.deepPropertyNotVal = function (obj, prop, val, msg) {\r\n        new Assertion(obj, msg).to.not.have.deep.property(prop, val);\r\n      };\r\n\r\n      /**\r\n       * ### .lengthOf(object, length, [message])\r\n       *\r\n       * Asserts that `object` has a `length` property with the expected value.\r\n       *\r\n       *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\r\n       *     assert.lengthOf('foobar', 5, 'string has length of 6');\r\n       *\r\n       * @name lengthOf\r\n       * @param {Mixed} object\r\n       * @param {Number} length\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.lengthOf = function (exp, len, msg) {\r\n        new Assertion(exp, msg).to.have.length(len);\r\n      };\r\n\r\n      /**\r\n       * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\r\n       *\r\n       * Asserts that `function` will throw an error that is an instance of\r\n       * `constructor`, or alternately that it will throw an error with message\r\n       * matching `regexp`.\r\n       *\r\n       *     assert.throw(fn, 'function throws a reference error');\r\n       *     assert.throw(fn, /function throws a reference error/);\r\n       *     assert.throw(fn, ReferenceError);\r\n       *     assert.throw(fn, ReferenceError, 'function throws a reference error');\r\n       *     assert.throw(fn, ReferenceError, /function throws a reference error/);\r\n       *\r\n       * @name throws\r\n       * @alias throw\r\n       * @alias Throw\r\n       * @param {Function} function\r\n       * @param {ErrorConstructor} constructor\r\n       * @param {RegExp} regexp\r\n       * @param {String} message\r\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n       * @api public\r\n       */\r\n\r\n      assert.Throw = function (fn, errt, errs, msg) {\r\n        if ('string' === typeof errt || errt instanceof RegExp) {\r\n          errs = errt;\r\n          errt = null;\r\n        }\r\n\r\n        new Assertion(fn, msg).to.Throw(errt, errs);\r\n      };\r\n\r\n      /**\r\n       * ### .doesNotThrow(function, [constructor/regexp], [message])\r\n       *\r\n       * Asserts that `function` will _not_ throw an error that is an instance of\r\n       * `constructor`, or alternately that it will not throw an error with message\r\n       * matching `regexp`.\r\n       *\r\n       *     assert.doesNotThrow(fn, Error, 'function does not throw');\r\n       *\r\n       * @name doesNotThrow\r\n       * @param {Function} function\r\n       * @param {ErrorConstructor} constructor\r\n       * @param {RegExp} regexp\r\n       * @param {String} message\r\n       * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\r\n       * @api public\r\n       */\r\n\r\n      assert.doesNotThrow = function (fn, type, msg) {\r\n        if ('string' === typeof type) {\r\n          msg = type;\r\n          type = null;\r\n        }\r\n\r\n        new Assertion(fn, msg).to.not.Throw(type);\r\n      };\r\n\r\n      /**\r\n       * ### .operator(val1, operator, val2, [message])\r\n       *\r\n       * Compares two values using `operator`.\r\n       *\r\n       *     assert.operator(1, '<', 2, 'everything is ok');\r\n       *     assert.operator(1, '>', 2, 'this will fail');\r\n       *\r\n       * @name operator\r\n       * @param {Mixed} val1\r\n       * @param {String} operator\r\n       * @param {Mixed} val2\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.operator = function (val, operator, val2, msg) {\r\n        if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\r\n          throw new Error('Invalid operator \"' + operator + '\"');\r\n        }\r\n        var test = new Assertion(eval(val + operator + val2), msg);\r\n        test.assert(\r\n            true === flag(test, 'object')\r\n          , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\r\n          , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\r\n      };\r\n\r\n      /**\r\n       * ### .closeTo(actual, expected, delta, [message])\r\n       *\r\n       * Asserts that the target is equal `expected`, to within a +/- `delta` range.\r\n       *\r\n       *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\r\n       *\r\n       * @name closeTo\r\n       * @param {Number} actual\r\n       * @param {Number} expected\r\n       * @param {Number} delta\r\n       * @param {String} message\r\n       * @api public\r\n       */\r\n\r\n      assert.closeTo = function (act, exp, delta, msg) {\r\n        new Assertion(act, msg).to.be.closeTo(exp, delta);\r\n      };\r\n\r\n      /*!\r\n       * Undocumented / untested\r\n       */\r\n\r\n      assert.ifError = function (val, msg) {\r\n        new Assertion(val, msg).to.not.be.ok;\r\n      };\r\n\r\n      /*!\r\n       * Aliases.\r\n       */\r\n\r\n      (function alias(name, as){\r\n        assert[as] = assert[name];\r\n        return alias;\r\n      })\r\n      ('Throw', 'throw')\r\n      ('Throw', 'throws');\r\n    };\r\n\r\n  }); // module: chai/interface/assert.js\r\n\r\n  require.register(\"chai/interface/expect.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    module.exports = function (chai, util) {\r\n      chai.expect = function (val, message) {\r\n        return new chai.Assertion(val, message);\r\n      };\r\n    };\r\n\r\n\r\n  }); // module: chai/interface/expect.js\r\n\r\n  require.register(\"chai/interface/should.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    module.exports = function (chai, util) {\r\n      var Assertion = chai.Assertion;\r\n\r\n      function loadShould () {\r\n        // modify Object.prototype to have `should`\r\n        Object.defineProperty(Object.prototype, 'should',\r\n          {\r\n            set: function (value) {\r\n              // See https://github.com/chaijs/chai/issues/86: this makes\r\n              // `whatever.should = someValue` actually set `someValue`, which is\r\n              // especially useful for `global.should = require('chai').should()`.\r\n              //\r\n              // Note that we have to use [[DefineProperty]] instead of [[Put]]\r\n              // since otherwise we would trigger this very setter!\r\n              Object.defineProperty(this, 'should', {\r\n                value: value,\r\n                enumerable: true,\r\n                configurable: true,\r\n                writable: true\r\n              });\r\n            }\r\n          , get: function(){\r\n              if (this instanceof String || this instanceof Number) {\r\n                return new Assertion(this.constructor(this));\r\n              } else if (this instanceof Boolean) {\r\n                return new Assertion(this == true);\r\n              }\r\n              return new Assertion(this);\r\n            }\r\n          , configurable: true\r\n        });\r\n\r\n        var should = {};\r\n\r\n        should.equal = function (val1, val2, msg) {\r\n          new Assertion(val1, msg).to.equal(val2);\r\n        };\r\n\r\n        should.Throw = function (fn, errt, errs, msg) {\r\n          new Assertion(fn, msg).to.Throw(errt, errs);\r\n        };\r\n\r\n        should.exist = function (val, msg) {\r\n          new Assertion(val, msg).to.exist;\r\n        }\r\n\r\n        // negation\r\n        should.not = {}\r\n\r\n        should.not.equal = function (val1, val2, msg) {\r\n          new Assertion(val1, msg).to.not.equal(val2);\r\n        };\r\n\r\n        should.not.Throw = function (fn, errt, errs, msg) {\r\n          new Assertion(fn, msg).to.not.Throw(errt, errs);\r\n        };\r\n\r\n        should.not.exist = function (val, msg) {\r\n          new Assertion(val, msg).to.not.exist;\r\n        }\r\n\r\n        should['throw'] = should['Throw'];\r\n        should.not['throw'] = should.not['Throw'];\r\n\r\n        return should;\r\n      };\r\n\r\n      chai.should = loadShould;\r\n      chai.Should = loadShould;\r\n    };\r\n\r\n  }); // module: chai/interface/should.js\r\n\r\n  require.register(\"chai/utils/addChainableMethod.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - addChainingMethod utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Module dependencies\r\n     */\r\n\r\n    var transferFlags = require('./transferFlags');\r\n\r\n    /*!\r\n     * Module variables\r\n     */\r\n\r\n    // Check whether `__proto__` is supported\r\n    var hasProtoSupport = '__proto__' in Object;\r\n\r\n    // Without `__proto__` support, this module will need to add properties to a function.\r\n    // However, some Function.prototype methods cannot be overwritten,\r\n    // and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\r\n    var excludeNames = /^(?:length|name|arguments|caller)$/;\r\n\r\n    /**\r\n     * ### addChainableMethod (ctx, name, method, chainingBehavior)\r\n     *\r\n     * Adds a method to an object, such that the method can also be chained.\r\n     *\r\n     *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\r\n     *       var obj = utils.flag(this, 'object');\r\n     *       new chai.Assertion(obj).to.be.equal(str);\r\n     *     });\r\n     *\r\n     * Can also be accessed directly from `chai.Assertion`.\r\n     *\r\n     *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\r\n     *\r\n     * The result can then be used as both a method assertion, executing both `method` and\r\n     * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\r\n     *\r\n     *     expect(fooStr).to.be.foo('bar');\r\n     *     expect(fooStr).to.be.foo.equal('foo');\r\n     *\r\n     * @param {Object} ctx object to which the method is added\r\n     * @param {String} name of method to add\r\n     * @param {Function} method function to be used for `name`, when called\r\n     * @param {Function} chainingBehavior function to be called every time the property is accessed\r\n     * @name addChainableMethod\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (ctx, name, method, chainingBehavior) {\r\n      if (typeof chainingBehavior !== 'function')\r\n        chainingBehavior = function () { };\r\n\r\n      Object.defineProperty(ctx, name,\r\n        { get: function () {\r\n            chainingBehavior.call(this);\r\n\r\n            var assert = function () {\r\n              var result = method.apply(this, arguments);\r\n              return result === undefined ? this : result;\r\n            };\r\n\r\n            // Use `__proto__` if available\r\n            if (hasProtoSupport) {\r\n              assert.__proto__ = this;\r\n            }\r\n            // Otherwise, redefine all properties (slow!)\r\n            else {\r\n              var asserterNames = Object.getOwnPropertyNames(ctx);\r\n              asserterNames.forEach(function (asserterName) {\r\n                if (!excludeNames.test(asserterName)) {\r\n                  var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\r\n                  Object.defineProperty(assert, asserterName, pd);\r\n                }\r\n              });\r\n            }\r\n\r\n            transferFlags(this, assert);\r\n            return assert;\r\n          }\r\n        , configurable: true\r\n      });\r\n    };\r\n\r\n  }); // module: chai/utils/addChainableMethod.js\r\n\r\n  require.register(\"chai/utils/addMethod.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - addMethod utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### .addMethod (ctx, name, method)\r\n     *\r\n     * Adds a method to the prototype of an object.\r\n     *\r\n     *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\r\n     *       var obj = utils.flag(this, 'object');\r\n     *       new chai.Assertion(obj).to.be.equal(str);\r\n     *     });\r\n     *\r\n     * Can also be accessed directly from `chai.Assertion`.\r\n     *\r\n     *     chai.Assertion.addMethod('foo', fn);\r\n     *\r\n     * Then can be used as any other assertion.\r\n     *\r\n     *     expect(fooStr).to.be.foo('bar');\r\n     *\r\n     * @param {Object} ctx object to which the method is added\r\n     * @param {String} name of method to add\r\n     * @param {Function} method function to be used for name\r\n     * @name addMethod\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (ctx, name, method) {\r\n      ctx[name] = function () {\r\n        var result = method.apply(this, arguments);\r\n        return result === undefined ? this : result;\r\n      };\r\n    };\r\n\r\n  }); // module: chai/utils/addMethod.js\r\n\r\n  require.register(\"chai/utils/addProperty.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - addProperty utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### addProperty (ctx, name, getter)\r\n     *\r\n     * Adds a property to the prototype of an object.\r\n     *\r\n     *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\r\n     *       var obj = utils.flag(this, 'object');\r\n     *       new chai.Assertion(obj).to.be.instanceof(Foo);\r\n     *     });\r\n     *\r\n     * Can also be accessed directly from `chai.Assertion`.\r\n     *\r\n     *     chai.Assertion.addProperty('foo', fn);\r\n     *\r\n     * Then can be used as any other assertion.\r\n     *\r\n     *     expect(myFoo).to.be.foo;\r\n     *\r\n     * @param {Object} ctx object to which the property is added\r\n     * @param {String} name of property to add\r\n     * @param {Function} getter function to be used for name\r\n     * @name addProperty\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (ctx, name, getter) {\r\n      Object.defineProperty(ctx, name,\r\n        { get: function () {\r\n            var result = getter.call(this);\r\n            return result === undefined ? this : result;\r\n          }\r\n        , configurable: true\r\n      });\r\n    };\r\n\r\n  }); // module: chai/utils/addProperty.js\r\n\r\n  require.register(\"chai/utils/eql.js\", function(module, exports, require){\r\n    // This is (almost) directly from Node.js assert\r\n    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/assert.js\r\n\r\n    module.exports = _deepEqual;\r\n\r\n    var getEnumerableProperties = require('./getEnumerableProperties');\r\n\r\n    // for the browser\r\n    var Buffer;\r\n    try {\r\n      Buffer = require('buffer').Buffer;\r\n    } catch (ex) {\r\n      Buffer = {\r\n        isBuffer: function () { return false; }\r\n      };\r\n    }\r\n\r\n    function _deepEqual(actual, expected, memos) {\r\n\r\n      // 7.1. All identical values are equivalent, as determined by ===.\r\n      if (actual === expected) {\r\n        return true;\r\n\r\n      } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\r\n        if (actual.length != expected.length) return false;\r\n\r\n        for (var i = 0; i < actual.length; i++) {\r\n          if (actual[i] !== expected[i]) return false;\r\n        }\r\n\r\n        return true;\r\n\r\n      // 7.2. If the expected value is a Date object, the actual value is\r\n      // equivalent if it is also a Date object that refers to the same time.\r\n      } else if (actual instanceof Date && expected instanceof Date) {\r\n        return actual.getTime() === expected.getTime();\r\n\r\n      // 7.3. Other pairs that do not both pass typeof value == 'object',\r\n      // equivalence is determined by ==.\r\n      } else if (typeof actual != 'object' && typeof expected != 'object') {\r\n        return actual === expected;\r\n\r\n      // 7.4. For all other Object pairs, including Array objects, equivalence is\r\n      // determined by having the same number of owned properties (as verified\r\n      // with Object.prototype.hasOwnProperty.call), the same set of keys\r\n      // (although not necessarily the same order), equivalent values for every\r\n      // corresponding key, and an identical 'prototype' property. Note: this\r\n      // accounts for both named and indexed properties on Arrays.\r\n      } else {\r\n        return objEquiv(actual, expected, memos);\r\n      }\r\n    }\r\n\r\n    function isUndefinedOrNull(value) {\r\n      return value === null || value === undefined;\r\n    }\r\n\r\n    function isArguments(object) {\r\n      return Object.prototype.toString.call(object) == '[object Arguments]';\r\n    }\r\n\r\n    function objEquiv(a, b, memos) {\r\n      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\r\n        return false;\r\n\r\n      // an identical 'prototype' property.\r\n      if (a.prototype !== b.prototype) return false;\r\n\r\n      // check if we have already compared a and b\r\n      var i;\r\n      if (memos) {\r\n        for(i = 0; i < memos.length; i++) {\r\n          if ((memos[i][0] === a && memos[i][1] === b) ||\r\n              (memos[i][0] === b && memos[i][1] === a))\r\n            return true;\r\n        }\r\n      } else {\r\n        memos = [];\r\n      }\r\n\r\n      //~~~I've managed to break Object.keys through screwy arguments passing.\r\n      //   Converting to array solves the problem.\r\n      if (isArguments(a)) {\r\n        if (!isArguments(b)) {\r\n          return false;\r\n        }\r\n        a = pSlice.call(a);\r\n        b = pSlice.call(b);\r\n        return _deepEqual(a, b, memos);\r\n      }\r\n      try {\r\n        var ka = getEnumerableProperties(a),\r\n            kb = getEnumerableProperties(b),\r\n            key;\r\n      } catch (e) {//happens when one is a string literal and the other isn't\r\n        return false;\r\n      }\r\n\r\n      // having the same number of owned properties (keys incorporates\r\n      // hasOwnProperty)\r\n      if (ka.length != kb.length)\r\n        return false;\r\n\r\n      //the same set of keys (although not necessarily the same order),\r\n      ka.sort();\r\n      kb.sort();\r\n      //~~~cheap key test\r\n      for (i = ka.length - 1; i >= 0; i--) {\r\n        if (ka[i] != kb[i])\r\n          return false;\r\n      }\r\n\r\n      // remember objects we have compared to guard against circular references\r\n      memos.push([ a, b ]);\r\n\r\n      //equivalent values for every corresponding key, and\r\n      //~~~possibly expensive deep test\r\n      for (i = ka.length - 1; i >= 0; i--) {\r\n        key = ka[i];\r\n        if (!_deepEqual(a[key], b[key], memos)) return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n  }); // module: chai/utils/eql.js\r\n\r\n  require.register(\"chai/utils/flag.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - flag utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### flag(object ,key, [value])\r\n     *\r\n     * Get or set a flag value on an object. If a\r\n     * value is provided it will be set, else it will\r\n     * return the currently set value or `undefined` if\r\n     * the value is not set.\r\n     *\r\n     *     utils.flag(this, 'foo', 'bar'); // setter\r\n     *     utils.flag(this, 'foo'); // getter, returns `bar`\r\n     *\r\n     * @param {Object} object (constructed Assertion\r\n     * @param {String} key\r\n     * @param {Mixed} value (optional)\r\n     * @name flag\r\n     * @api private\r\n     */\r\n\r\n    module.exports = function (obj, key, value) {\r\n      var flags = obj.__flags || (obj.__flags = Object.create(null));\r\n      if (arguments.length === 3) {\r\n        flags[key] = value;\r\n      } else {\r\n        return flags[key];\r\n      }\r\n    };\r\n\r\n  }); // module: chai/utils/flag.js\r\n\r\n  require.register(\"chai/utils/getActual.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - getActual utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * # getActual(object, [actual])\r\n     *\r\n     * Returns the `actual` value for an Assertion\r\n     *\r\n     * @param {Object} object (constructed Assertion)\r\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n     */\r\n\r\n    module.exports = function (obj, args) {\r\n      var actual = args[4];\r\n      return 'undefined' !== typeof actual ? actual : obj._obj;\r\n    };\r\n\r\n  }); // module: chai/utils/getActual.js\r\n\r\n  require.register(\"chai/utils/getEnumerableProperties.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - getEnumerableProperties utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### .getEnumerableProperties(object)\r\n     *\r\n     * This allows the retrieval of enumerable property names of an object,\r\n     * inherited or not.\r\n     *\r\n     * @param {Object} object\r\n     * @returns {Array}\r\n     * @name getEnumerableProperties\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function getEnumerableProperties(object) {\r\n      var result = [];\r\n      for (var name in object) {\r\n        result.push(name);\r\n      }\r\n      return result;\r\n    };\r\n\r\n  }); // module: chai/utils/getEnumerableProperties.js\r\n\r\n  require.register(\"chai/utils/getMessage.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - message composition utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Module dependancies\r\n     */\r\n\r\n    var flag = require('./flag')\r\n      , getActual = require('./getActual')\r\n      , inspect = require('./inspect')\r\n      , objDisplay = require('./objDisplay');\r\n\r\n    /**\r\n     * ### .getMessage(object, message, negateMessage)\r\n     *\r\n     * Construct the error message based on flags\r\n     * and template tags. Template tags will return\r\n     * a stringified inspection of the object referenced.\r\n     *\r\n     * Messsage template tags:\r\n     * - `#{this}` current asserted object\r\n     * - `#{act}` actual value\r\n     * - `#{exp}` expected value\r\n     *\r\n     * @param {Object} object (constructed Assertion)\r\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n     * @name getMessage\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (obj, args) {\r\n      var negate = flag(obj, 'negate')\r\n        , val = flag(obj, 'object')\r\n        , expected = args[3]\r\n        , actual = getActual(obj, args)\r\n        , msg = negate ? args[2] : args[1]\r\n        , flagMsg = flag(obj, 'message');\r\n\r\n      msg = msg || '';\r\n      msg = msg\r\n        .replace(/#{this}/g, objDisplay(val))\r\n        .replace(/#{act}/g, objDisplay(actual))\r\n        .replace(/#{exp}/g, objDisplay(expected));\r\n\r\n      return flagMsg ? flagMsg + ': ' + msg : msg;\r\n    };\r\n\r\n  }); // module: chai/utils/getMessage.js\r\n\r\n  require.register(\"chai/utils/getName.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - getName utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * # getName(func)\r\n     *\r\n     * Gets the name of a function, in a cross-browser way.\r\n     *\r\n     * @param {Function} a function (usually a constructor)\r\n     */\r\n\r\n    module.exports = function (func) {\r\n      if (func.name) return func.name;\r\n\r\n      var match = /^\\s?function ([^(]*)\\(/.exec(func);\r\n      return match && match[1] ? match[1] : \"\";\r\n    };\r\n\r\n  }); // module: chai/utils/getName.js\r\n\r\n  require.register(\"chai/utils/getPathValue.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - getPathValue utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * @see https://github.com/logicalparadox/filtr\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### .getPathValue(path, object)\r\n     *\r\n     * This allows the retrieval of values in an\r\n     * object given a string path.\r\n     *\r\n     *     var obj = {\r\n     *         prop1: {\r\n     *             arr: ['a', 'b', 'c']\r\n     *           , str: 'Hello'\r\n     *         }\r\n     *       , prop2: {\r\n     *             arr: [ { nested: 'Universe' } ]\r\n     *           , str: 'Hello again!'\r\n     *         }\r\n     *     }\r\n     *\r\n     * The following would be the results.\r\n     *\r\n     *     getPathValue('prop1.str', obj); // Hello\r\n     *     getPathValue('prop1.att[2]', obj); // b\r\n     *     getPathValue('prop2.arr[0].nested', obj); // Universe\r\n     *\r\n     * @param {String} path\r\n     * @param {Object} object\r\n     * @returns {Object} value or `undefined`\r\n     * @name getPathValue\r\n     * @api public\r\n     */\r\n\r\n    var getPathValue = module.exports = function (path, obj) {\r\n      var parsed = parsePath(path);\r\n      return _getPathValue(parsed, obj);\r\n    };\r\n\r\n    /*!\r\n     * ## parsePath(path)\r\n     *\r\n     * Helper function used to parse string object\r\n     * paths. Use in conjunction with `_getPathValue`.\r\n     *\r\n     *      var parsed = parsePath('myobject.property.subprop');\r\n     *\r\n     * ### Paths:\r\n     *\r\n     * * Can be as near infinitely deep and nested\r\n     * * Arrays are also valid using the formal `myobject.document[3].property`.\r\n     *\r\n     * @param {String} path\r\n     * @returns {Object} parsed\r\n     * @api private\r\n     */\r\n\r\n    function parsePath (path) {\r\n      var str = path.replace(/\\[/g, '.[')\r\n        , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\r\n      return parts.map(function (value) {\r\n        var re = /\\[(\\d+)\\]$/\r\n          , mArr = re.exec(value)\r\n        if (mArr) return { i: parseFloat(mArr[1]) };\r\n        else return { p: value };\r\n      });\r\n    };\r\n\r\n    /*!\r\n     * ## _getPathValue(parsed, obj)\r\n     *\r\n     * Helper companion function for `.parsePath` that returns\r\n     * the value located at the parsed address.\r\n     *\r\n     *      var value = getPathValue(parsed, obj);\r\n     *\r\n     * @param {Object} parsed definition from `parsePath`.\r\n     * @param {Object} object to search against\r\n     * @returns {Object|Undefined} value\r\n     * @api private\r\n     */\r\n\r\n    function _getPathValue (parsed, obj) {\r\n      var tmp = obj\r\n        , res;\r\n      for (var i = 0, l = parsed.length; i < l; i++) {\r\n        var part = parsed[i];\r\n        if (tmp) {\r\n          if ('undefined' !== typeof part.p)\r\n            tmp = tmp[part.p];\r\n          else if ('undefined' !== typeof part.i)\r\n            tmp = tmp[part.i];\r\n          if (i == (l - 1)) res = tmp;\r\n        } else {\r\n          res = undefined;\r\n        }\r\n      }\r\n      return res;\r\n    };\r\n\r\n  }); // module: chai/utils/getPathValue.js\r\n\r\n  require.register(\"chai/utils/getProperties.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - getProperties utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### .getProperties(object)\r\n     *\r\n     * This allows the retrieval of property names of an object, enumerable or not,\r\n     * inherited or not.\r\n     *\r\n     * @param {Object} object\r\n     * @returns {Array}\r\n     * @name getProperties\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function getProperties(object) {\r\n      var result = Object.getOwnPropertyNames(subject);\r\n\r\n      function addProperty(property) {\r\n        if (result.indexOf(property) === -1) {\r\n          result.push(property);\r\n        }\r\n      }\r\n\r\n      var proto = Object.getPrototypeOf(subject);\r\n      while (proto !== null) {\r\n        Object.getOwnPropertyNames(proto).forEach(addProperty);\r\n        proto = Object.getPrototypeOf(proto);\r\n      }\r\n\r\n      return result;\r\n    };\r\n\r\n  }); // module: chai/utils/getProperties.js\r\n\r\n  require.register(\"chai/utils/index.js\", function(module, exports, require){\r\n    /*!\r\n     * chai\r\n     * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Main exports\r\n     */\r\n\r\n    var exports = module.exports = {};\r\n\r\n    /*!\r\n     * test utility\r\n     */\r\n\r\n    exports.test = require('./test');\r\n\r\n    /*!\r\n     * type utility\r\n     */\r\n\r\n    exports.type = require('./type');\r\n\r\n    /*!\r\n     * message utility\r\n     */\r\n\r\n    exports.getMessage = require('./getMessage');\r\n\r\n    /*!\r\n     * actual utility\r\n     */\r\n\r\n    exports.getActual = require('./getActual');\r\n\r\n    /*!\r\n     * Inspect util\r\n     */\r\n\r\n    exports.inspect = require('./inspect');\r\n\r\n    /*!\r\n     * Object Display util\r\n     */\r\n\r\n    exports.objDisplay = require('./objDisplay');\r\n\r\n    /*!\r\n     * Flag utility\r\n     */\r\n\r\n    exports.flag = require('./flag');\r\n\r\n    /*!\r\n     * Flag transferring utility\r\n     */\r\n\r\n    exports.transferFlags = require('./transferFlags');\r\n\r\n    /*!\r\n     * Deep equal utility\r\n     */\r\n\r\n    exports.eql = require('./eql');\r\n\r\n    /*!\r\n     * Deep path value\r\n     */\r\n\r\n    exports.getPathValue = require('./getPathValue');\r\n\r\n    /*!\r\n     * Function name\r\n     */\r\n\r\n    exports.getName = require('./getName');\r\n\r\n    /*!\r\n     * add Property\r\n     */\r\n\r\n    exports.addProperty = require('./addProperty');\r\n\r\n    /*!\r\n     * add Method\r\n     */\r\n\r\n    exports.addMethod = require('./addMethod');\r\n\r\n    /*!\r\n     * overwrite Property\r\n     */\r\n\r\n    exports.overwriteProperty = require('./overwriteProperty');\r\n\r\n    /*!\r\n     * overwrite Method\r\n     */\r\n\r\n    exports.overwriteMethod = require('./overwriteMethod');\r\n\r\n    /*!\r\n     * Add a chainable method\r\n     */\r\n\r\n    exports.addChainableMethod = require('./addChainableMethod');\r\n\r\n\r\n  }); // module: chai/utils/index.js\r\n\r\n  require.register(\"chai/utils/inspect.js\", function(module, exports, require){\r\n    // This is (almost) directly from Node.js utils\r\n    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\r\n\r\n    var getName = require('./getName');\r\n    var getProperties = require('./getProperties');\r\n    var getEnumerableProperties = require('./getEnumerableProperties');\r\n\r\n    module.exports = inspect;\r\n\r\n    /**\r\n     * Echos the value of a value. Trys to print the value out\r\n     * in the best way possible given the different types.\r\n     *\r\n     * @param {Object} obj The object to print out.\r\n     * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\r\n     *    properties of objects.\r\n     * @param {Number} depth Depth in which to descend in object. Default is 2.\r\n     * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\r\n     *    output. Default is false (no coloring).\r\n     */\r\n    function inspect(obj, showHidden, depth, colors) {\r\n      var ctx = {\r\n        showHidden: showHidden,\r\n        seen: [],\r\n        stylize: function (str) { return str; }\r\n      };\r\n      return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\r\n    }\r\n\r\n    // https://gist.github.com/1044128/\r\n    var getOuterHTML = function(element) {\r\n      if ('outerHTML' in element) return element.outerHTML;\r\n      var ns = \"http://www.w3.org/1999/xhtml\";\r\n      var container = document.createElementNS(ns, '_');\r\n      var elemProto = (window.HTMLElement || window.Element).prototype;\r\n      var xmlSerializer = new XMLSerializer();\r\n      var html;\r\n      if (document.xmlVersion) {\r\n        return xmlSerializer.serializeToString(element);\r\n      } else {\r\n        container.appendChild(element.cloneNode(false));\r\n        html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');\r\n        container.innerHTML = '';\r\n        return html;\r\n      }\r\n    };\r\n\r\n    // Returns true if object is a DOM element.\r\n    var isDOMElement = function (object) {\r\n      if (typeof HTMLElement === 'object') {\r\n        return object instanceof HTMLElement;\r\n      } else {\r\n        return object &&\r\n          typeof object === 'object' &&\r\n          object.nodeType === 1 &&\r\n          typeof object.nodeName === 'string';\r\n      }\r\n    };\r\n\r\n    function formatValue(ctx, value, recurseTimes) {\r\n      // Provide a hook for user-specified inspect functions.\r\n      // Check that value is an object with an inspect function on it\r\n      if (value && typeof value.inspect === 'function' &&\r\n          // Filter out the util module, it's inspect function is special\r\n          value.inspect !== exports.inspect &&\r\n          // Also filter out any prototype objects using the circular check.\r\n          !(value.constructor && value.constructor.prototype === value)) {\r\n        return value.inspect(recurseTimes);\r\n      }\r\n\r\n      // Primitive types cannot have properties\r\n      var primitive = formatPrimitive(ctx, value);\r\n      if (primitive) {\r\n        return primitive;\r\n      }\r\n\r\n      // If it's DOM elem, get outer HTML.\r\n      if (isDOMElement(value)) {\r\n        return getOuterHTML(value);\r\n      }\r\n\r\n      // Look up the keys of the object.\r\n      var visibleKeys = getEnumerableProperties(value);\r\n      var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\r\n\r\n      // Some type of object without properties can be shortcutted.\r\n      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\r\n      // a `stack` plus `description` property; ignore those for consistency.\r\n      if (keys.length === 0 || (isError(value) && (\r\n          (keys.length === 1 && keys[0] === 'stack') ||\r\n          (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\r\n         ))) {\r\n        if (typeof value === 'function') {\r\n          var name = getName(value);\r\n          var nameSuffix = name ? ': ' + name : '';\r\n          return ctx.stylize('[Function' + nameSuffix + ']', 'special');\r\n        }\r\n        if (isRegExp(value)) {\r\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n        }\r\n        if (isDate(value)) {\r\n          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\r\n        }\r\n        if (isError(value)) {\r\n          return formatError(value);\r\n        }\r\n      }\r\n\r\n      var base = '', array = false, braces = ['{', '}'];\r\n\r\n      // Make Array say that they are Array\r\n      if (isArray(value)) {\r\n        array = true;\r\n        braces = ['[', ']'];\r\n      }\r\n\r\n      // Make functions say that they are functions\r\n      if (typeof value === 'function') {\r\n        var name = getName(value);\r\n        var nameSuffix = name ? ': ' + name : '';\r\n        base = ' [Function' + nameSuffix + ']';\r\n      }\r\n\r\n      // Make RegExps say that they are RegExps\r\n      if (isRegExp(value)) {\r\n        base = ' ' + RegExp.prototype.toString.call(value);\r\n      }\r\n\r\n      // Make dates with properties first say the date\r\n      if (isDate(value)) {\r\n        base = ' ' + Date.prototype.toUTCString.call(value);\r\n      }\r\n\r\n      // Make error with message first say the error\r\n      if (isError(value)) {\r\n        return formatError(value);\r\n      }\r\n\r\n      if (keys.length === 0 && (!array || value.length == 0)) {\r\n        return braces[0] + base + braces[1];\r\n      }\r\n\r\n      if (recurseTimes < 0) {\r\n        if (isRegExp(value)) {\r\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\r\n        } else {\r\n          return ctx.stylize('[Object]', 'special');\r\n        }\r\n      }\r\n\r\n      ctx.seen.push(value);\r\n\r\n      var output;\r\n      if (array) {\r\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\r\n      } else {\r\n        output = keys.map(function(key) {\r\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\r\n        });\r\n      }\r\n\r\n      ctx.seen.pop();\r\n\r\n      return reduceToSingleString(output, base, braces);\r\n    }\r\n\r\n\r\n    function formatPrimitive(ctx, value) {\r\n      switch (typeof value) {\r\n        case 'undefined':\r\n          return ctx.stylize('undefined', 'undefined');\r\n\r\n        case 'string':\r\n          var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\r\n                                                   .replace(/'/g, \"\\\\'\")\r\n                                                   .replace(/\\\\\"/g, '\"') + '\\'';\r\n          return ctx.stylize(simple, 'string');\r\n\r\n        case 'number':\r\n          return ctx.stylize('' + value, 'number');\r\n\r\n        case 'boolean':\r\n          return ctx.stylize('' + value, 'boolean');\r\n      }\r\n      // For some reason typeof null is \"object\", so special case here.\r\n      if (value === null) {\r\n        return ctx.stylize('null', 'null');\r\n      }\r\n    }\r\n\r\n\r\n    function formatError(value) {\r\n      return '[' + Error.prototype.toString.call(value) + ']';\r\n    }\r\n\r\n\r\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\r\n      var output = [];\r\n      for (var i = 0, l = value.length; i < l; ++i) {\r\n        if (Object.prototype.hasOwnProperty.call(value, String(i))) {\r\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n              String(i), true));\r\n        } else {\r\n          output.push('');\r\n        }\r\n      }\r\n      keys.forEach(function(key) {\r\n        if (!key.match(/^\\d+$/)) {\r\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\r\n              key, true));\r\n        }\r\n      });\r\n      return output;\r\n    }\r\n\r\n\r\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\r\n      var name, str;\r\n      if (value.__lookupGetter__) {\r\n        if (value.__lookupGetter__(key)) {\r\n          if (value.__lookupSetter__(key)) {\r\n            str = ctx.stylize('[Getter/Setter]', 'special');\r\n          } else {\r\n            str = ctx.stylize('[Getter]', 'special');\r\n          }\r\n        } else {\r\n          if (value.__lookupSetter__(key)) {\r\n            str = ctx.stylize('[Setter]', 'special');\r\n          }\r\n        }\r\n      }\r\n      if (visibleKeys.indexOf(key) < 0) {\r\n        name = '[' + key + ']';\r\n      }\r\n      if (!str) {\r\n        if (ctx.seen.indexOf(value[key]) < 0) {\r\n          if (recurseTimes === null) {\r\n            str = formatValue(ctx, value[key], null);\r\n          } else {\r\n            str = formatValue(ctx, value[key], recurseTimes - 1);\r\n          }\r\n          if (str.indexOf('\\n') > -1) {\r\n            if (array) {\r\n              str = str.split('\\n').map(function(line) {\r\n                return '  ' + line;\r\n              }).join('\\n').substr(2);\r\n            } else {\r\n              str = '\\n' + str.split('\\n').map(function(line) {\r\n                return '   ' + line;\r\n              }).join('\\n');\r\n            }\r\n          }\r\n        } else {\r\n          str = ctx.stylize('[Circular]', 'special');\r\n        }\r\n      }\r\n      if (typeof name === 'undefined') {\r\n        if (array && key.match(/^\\d+$/)) {\r\n          return str;\r\n        }\r\n        name = JSON.stringify('' + key);\r\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\r\n          name = name.substr(1, name.length - 2);\r\n          name = ctx.stylize(name, 'name');\r\n        } else {\r\n          name = name.replace(/'/g, \"\\\\'\")\r\n                     .replace(/\\\\\"/g, '\"')\r\n                     .replace(/(^\"|\"$)/g, \"'\");\r\n          name = ctx.stylize(name, 'string');\r\n        }\r\n      }\r\n\r\n      return name + ': ' + str;\r\n    }\r\n\r\n\r\n    function reduceToSingleString(output, base, braces) {\r\n      var numLinesEst = 0;\r\n      var length = output.reduce(function(prev, cur) {\r\n        numLinesEst++;\r\n        if (cur.indexOf('\\n') >= 0) numLinesEst++;\r\n        return prev + cur.length + 1;\r\n      }, 0);\r\n\r\n      if (length > 60) {\r\n        return braces[0] +\r\n               (base === '' ? '' : base + '\\n ') +\r\n               ' ' +\r\n               output.join(',\\n  ') +\r\n               ' ' +\r\n               braces[1];\r\n      }\r\n\r\n      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\r\n    }\r\n\r\n    function isArray(ar) {\r\n      return Array.isArray(ar) ||\r\n             (typeof ar === 'object' && objectToString(ar) === '[object Array]');\r\n    }\r\n\r\n    function isRegExp(re) {\r\n      return typeof re === 'object' && objectToString(re) === '[object RegExp]';\r\n    }\r\n\r\n    function isDate(d) {\r\n      return typeof d === 'object' && objectToString(d) === '[object Date]';\r\n    }\r\n\r\n    function isError(e) {\r\n      return typeof e === 'object' && objectToString(e) === '[object Error]';\r\n    }\r\n\r\n    function objectToString(o) {\r\n      return Object.prototype.toString.call(o);\r\n    }\r\n\r\n  }); // module: chai/utils/inspect.js\r\n\r\n  require.register(\"chai/utils/objDisplay.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - flag utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Module dependancies\r\n     */\r\n\r\n    var inspect = require('./inspect');\r\n\r\n    /**\r\n     * ### .objDisplay (object)\r\n     *\r\n     * Determines if an object or an array matches\r\n     * criteria to be inspected in-line for error\r\n     * messages or should be truncated.\r\n     *\r\n     * @param {Mixed} javascript object to inspect\r\n     * @name objDisplay\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (obj) {\r\n      var str = inspect(obj)\r\n        , type = Object.prototype.toString.call(obj);\r\n\r\n      if (str.length >= 40) {\r\n        if (type === '[object Function]') {\r\n          return !obj.name || obj.name === ''\r\n            ? '[Function]'\r\n            : '[Function: ' + obj.name + ']';\r\n        } else if (type === '[object Array]') {\r\n          return '[ Array(' + obj.length + ') ]';\r\n        } else if (type === '[object Object]') {\r\n          var keys = Object.keys(obj)\r\n            , kstr = keys.length > 2\r\n              ? keys.splice(0, 2).join(', ') + ', ...'\r\n              : keys.join(', ');\r\n          return '{ Object (' + kstr + ') }';\r\n        } else {\r\n          return str;\r\n        }\r\n      } else {\r\n        return str;\r\n      }\r\n    };\r\n\r\n  }); // module: chai/utils/objDisplay.js\r\n\r\n  require.register(\"chai/utils/overwriteMethod.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - overwriteMethod utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### overwriteMethod (ctx, name, fn)\r\n     *\r\n     * Overwites an already existing method and provides\r\n     * access to previous function. Must return function\r\n     * to be used for name.\r\n     *\r\n     *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\r\n     *       return function (str) {\r\n     *         var obj = utils.flag(this, 'object');\r\n     *         if (obj instanceof Foo) {\r\n     *           new chai.Assertion(obj.value).to.equal(str);\r\n     *         } else {\r\n     *           _super.apply(this, arguments);\r\n     *         }\r\n     *       }\r\n     *     });\r\n     *\r\n     * Can also be accessed directly from `chai.Assertion`.\r\n     *\r\n     *     chai.Assertion.overwriteMethod('foo', fn);\r\n     *\r\n     * Then can be used as any other assertion.\r\n     *\r\n     *     expect(myFoo).to.equal('bar');\r\n     *\r\n     * @param {Object} ctx object whose method is to be overwritten\r\n     * @param {String} name of method to overwrite\r\n     * @param {Function} method function that returns a function to be used for name\r\n     * @name overwriteMethod\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (ctx, name, method) {\r\n      var _method = ctx[name]\r\n        , _super = function () { return this; };\r\n\r\n      if (_method && 'function' === typeof _method)\r\n        _super = _method;\r\n\r\n      ctx[name] = function () {\r\n        var result = method(_super).apply(this, arguments);\r\n        return result === undefined ? this : result;\r\n      }\r\n    };\r\n\r\n  }); // module: chai/utils/overwriteMethod.js\r\n\r\n  require.register(\"chai/utils/overwriteProperty.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - overwriteProperty utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### overwriteProperty (ctx, name, fn)\r\n     *\r\n     * Overwites an already existing property getter and provides\r\n     * access to previous value. Must return function to use as getter.\r\n     *\r\n     *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\r\n     *       return function () {\r\n     *         var obj = utils.flag(this, 'object');\r\n     *         if (obj instanceof Foo) {\r\n     *           new chai.Assertion(obj.name).to.equal('bar');\r\n     *         } else {\r\n     *           _super.call(this);\r\n     *         }\r\n     *       }\r\n     *     });\r\n     *\r\n     *\r\n     * Can also be accessed directly from `chai.Assertion`.\r\n     *\r\n     *     chai.Assertion.overwriteProperty('foo', fn);\r\n     *\r\n     * Then can be used as any other assertion.\r\n     *\r\n     *     expect(myFoo).to.be.ok;\r\n     *\r\n     * @param {Object} ctx object whose property is to be overwritten\r\n     * @param {String} name of property to overwrite\r\n     * @param {Function} getter function that returns a getter function to be used for name\r\n     * @name overwriteProperty\r\n     * @api public\r\n     */\r\n\r\n    module.exports = function (ctx, name, getter) {\r\n      var _get = Object.getOwnPropertyDescriptor(ctx, name)\r\n        , _super = function () {};\r\n\r\n      if (_get && 'function' === typeof _get.get)\r\n        _super = _get.get\r\n\r\n      Object.defineProperty(ctx, name,\r\n        { get: function () {\r\n            var result = getter(_super).call(this);\r\n            return result === undefined ? this : result;\r\n          }\r\n        , configurable: true\r\n      });\r\n    };\r\n\r\n  }); // module: chai/utils/overwriteProperty.js\r\n\r\n  require.register(\"chai/utils/test.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - test utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Module dependancies\r\n     */\r\n\r\n    var flag = require('./flag');\r\n\r\n    /**\r\n     * # test(object, expression)\r\n     *\r\n     * Test and object for expression.\r\n     *\r\n     * @param {Object} object (constructed Assertion)\r\n     * @param {Arguments} chai.Assertion.prototype.assert arguments\r\n     */\r\n\r\n    module.exports = function (obj, args) {\r\n      var negate = flag(obj, 'negate')\r\n        , expr = args[0];\r\n      return negate ? !expr : expr;\r\n    };\r\n\r\n  }); // module: chai/utils/test.js\r\n\r\n  require.register(\"chai/utils/transferFlags.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - transferFlags utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /**\r\n     * ### transferFlags(assertion, object, includeAll = true)\r\n     *\r\n     * Transfer all the flags for `assertion` to `object`. If\r\n     * `includeAll` is set to `false`, then the base Chai\r\n     * assertion flags (namely `object`, `ssfi`, and `message`)\r\n     * will not be transferred.\r\n     *\r\n     *\r\n     *     var newAssertion = new Assertion();\r\n     *     utils.transferFlags(assertion, newAssertion);\r\n     *\r\n     *     var anotherAsseriton = new Assertion(myObj);\r\n     *     utils.transferFlags(assertion, anotherAssertion, false);\r\n     *\r\n     * @param {Assertion} assertion the assertion to transfer the flags from\r\n     * @param {Object} object the object to transfer the flags too; usually a new assertion\r\n     * @param {Boolean} includeAll\r\n     * @name getAllFlags\r\n     * @api private\r\n     */\r\n\r\n    module.exports = function (assertion, object, includeAll) {\r\n      var flags = assertion.__flags || (assertion.__flags = Object.create(null));\r\n\r\n      if (!object.__flags) {\r\n        object.__flags = Object.create(null);\r\n      }\r\n\r\n      includeAll = arguments.length === 3 ? includeAll : true;\r\n\r\n      for (var flag in flags) {\r\n        if (includeAll ||\r\n            (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\r\n          object.__flags[flag] = flags[flag];\r\n        }\r\n      }\r\n    };\r\n\r\n  }); // module: chai/utils/transferFlags.js\r\n\r\n  require.register(\"chai/utils/type.js\", function(module, exports, require){\r\n    /*!\r\n     * Chai - type utility\r\n     * Copyright(c) 2012-2013 Jake Luer <jake@alogicalparadox.com>\r\n     * MIT Licensed\r\n     */\r\n\r\n    /*!\r\n     * Detectable javascript natives\r\n     */\r\n\r\n    var natives = {\r\n        '[object Arguments]': 'arguments'\r\n      , '[object Array]': 'array'\r\n      , '[object Date]': 'date'\r\n      , '[object Function]': 'function'\r\n      , '[object Number]': 'number'\r\n      , '[object RegExp]': 'regexp'\r\n      , '[object String]': 'string'\r\n    };\r\n\r\n    /**\r\n     * ### type(object)\r\n     *\r\n     * Better implementation of `typeof` detection that can\r\n     * be used cross-browser. Handles the inconsistencies of\r\n     * Array, `null`, and `undefined` detection.\r\n     *\r\n     *     utils.type({}) // 'object'\r\n     *     utils.type(null) // `null'\r\n     *     utils.type(undefined) // `undefined`\r\n     *     utils.type([]) // `array`\r\n     *\r\n     * @param {Mixed} object to detect type of\r\n     * @name type\r\n     * @api private\r\n     */\r\n\r\n    module.exports = function (obj) {\r\n      var str = Object.prototype.toString.call(obj);\r\n      if (natives[str]) return natives[str];\r\n      if (obj === null) return 'null';\r\n      if (obj === undefined) return 'undefined';\r\n      if (obj === Object(obj)) return 'object';\r\n      return typeof obj;\r\n    };\r\n\r\n  }); // module: chai/utils/type.js\r\n\r\n  require.alias(\"./chai.js\", \"chai\");\r\n\r\n  return require('chai');\r\n});\r\n",";(function(){\r\n\r\n\r\n// CommonJS require()\r\n\r\nfunction require(p){\r\n    var path = require.resolve(p)\r\n      , mod = require.modules[path];\r\n    if (!mod) throw new Error('failed to require \"' + p + '\"');\r\n    if (!mod.exports) {\r\n      mod.exports = {};\r\n      mod.call(mod.exports, mod, mod.exports, require.relative(path));\r\n    }\r\n    return mod.exports;\r\n  }\r\n\r\nrequire.modules = {};\r\n\r\nrequire.resolve = function (path){\r\n    var orig = path\r\n      , reg = path + '.js'\r\n      , index = path + '/index.js';\r\n    return require.modules[reg] && reg\r\n      || require.modules[index] && index\r\n      || orig;\r\n  };\r\n\r\nrequire.register = function (path, fn){\r\n    require.modules[path] = fn;\r\n  };\r\n\r\nrequire.relative = function (parent) {\r\n    return function(p){\r\n      if ('.' != p.charAt(0)) return require(p);\r\n\r\n      var path = parent.split('/')\r\n        , segs = p.split('/');\r\n      path.pop();\r\n\r\n      for (var i = 0; i < segs.length; i++) {\r\n        var seg = segs[i];\r\n        if ('..' == seg) path.pop();\r\n        else if ('.' != seg) path.push(seg);\r\n      }\r\n\r\n      return require(path.join('/'));\r\n    };\r\n  };\r\n\r\n\r\nrequire.register(\"browser/debug.js\", function(module, exports, require){\r\n\r\nmodule.exports = function(type){\r\n  return function(){\r\n\r\n  }\r\n};\r\n}); // module: browser/debug.js\r\n\r\nrequire.register(\"browser/diff.js\", function(module, exports, require){\r\n/* See license.txt for terms of usage */\r\n\r\n/*\r\n * Text diff implementation.\r\n *\r\n * This library supports the following APIS:\r\n * JsDiff.diffChars: Character by character diff\r\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\r\n * JsDiff.diffLines: Line based diff\r\n *\r\n * JsDiff.diffCss: Diff targeted at CSS content\r\n *\r\n * These methods are based on the implementation proposed in\r\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\r\n */\r\nvar JsDiff = (function() {\r\n  function clonePath(path) {\r\n    return { newPos: path.newPos, components: path.components.slice(0) };\r\n  }\r\n  function removeEmpty(array) {\r\n    var ret = [];\r\n    for (var i = 0; i < array.length; i++) {\r\n      if (array[i]) {\r\n        ret.push(array[i]);\r\n      }\r\n    }\r\n    return ret;\r\n  }\r\n  function escapeHTML(s) {\r\n    var n = s;\r\n    n = n.replace(/&/g, \"&amp;\");\r\n    n = n.replace(/</g, \"&lt;\");\r\n    n = n.replace(/>/g, \"&gt;\");\r\n    n = n.replace(/\"/g, \"&quot;\");\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  var fbDiff = function(ignoreWhitespace) {\r\n    this.ignoreWhitespace = ignoreWhitespace;\r\n  };\r\n  fbDiff.prototype = {\r\n      diff: function(oldString, newString) {\r\n        // Handle the identity case (this is due to unrolling editLength == 0\r\n        if (newString == oldString) {\r\n          return [{ value: newString }];\r\n        }\r\n        if (!newString) {\r\n          return [{ value: oldString, removed: true }];\r\n        }\r\n        if (!oldString) {\r\n          return [{ value: newString, added: true }];\r\n        }\r\n\r\n        newString = this.tokenize(newString);\r\n        oldString = this.tokenize(oldString);\r\n\r\n        var newLen = newString.length, oldLen = oldString.length;\r\n        var maxEditLength = newLen + oldLen;\r\n        var bestPath = [{ newPos: -1, components: [] }];\r\n\r\n        // Seed editLength = 0\r\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\r\n        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\r\n          return bestPath[0].components;\r\n        }\r\n\r\n        for (var editLength = 1; editLength <= maxEditLength; editLength++) {\r\n          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\r\n            var basePath;\r\n            var addPath = bestPath[diagonalPath-1],\r\n                removePath = bestPath[diagonalPath+1];\r\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\r\n            if (addPath) {\r\n              // No one else is going to attempt to use this value, clear it\r\n              bestPath[diagonalPath-1] = undefined;\r\n            }\r\n\r\n            var canAdd = addPath && addPath.newPos+1 < newLen;\r\n            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\r\n            if (!canAdd && !canRemove) {\r\n              bestPath[diagonalPath] = undefined;\r\n              continue;\r\n            }\r\n\r\n            // Select the diagonal that we want to branch from. We select the prior\r\n            // path whose position in the new string is the farthest from the origin\r\n            // and does not pass the bounds of the diff graph\r\n            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\r\n              basePath = clonePath(removePath);\r\n              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\r\n            } else {\r\n              basePath = clonePath(addPath);\r\n              basePath.newPos++;\r\n              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\r\n            }\r\n\r\n            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\r\n\r\n            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\r\n              return basePath.components;\r\n            } else {\r\n              bestPath[diagonalPath] = basePath;\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      pushComponent: function(components, value, added, removed) {\r\n        var last = components[components.length-1];\r\n        if (last && last.added === added && last.removed === removed) {\r\n          // We need to clone here as the component clone operation is just\r\n          // as shallow array clone\r\n          components[components.length-1] =\r\n            {value: this.join(last.value, value), added: added, removed: removed };\r\n        } else {\r\n          components.push({value: value, added: added, removed: removed });\r\n        }\r\n      },\r\n      extractCommon: function(basePath, newString, oldString, diagonalPath) {\r\n        var newLen = newString.length,\r\n            oldLen = oldString.length,\r\n            newPos = basePath.newPos,\r\n            oldPos = newPos - diagonalPath;\r\n        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {\r\n          newPos++;\r\n          oldPos++;\r\n\r\n          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\r\n        }\r\n        basePath.newPos = newPos;\r\n        return oldPos;\r\n      },\r\n\r\n      equals: function(left, right) {\r\n        var reWhitespace = /\\S/;\r\n        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {\r\n          return true;\r\n        } else {\r\n          return left == right;\r\n        }\r\n      },\r\n      join: function(left, right) {\r\n        return left + right;\r\n      },\r\n      tokenize: function(value) {\r\n        return value;\r\n      }\r\n  };\r\n\r\n  var CharDiff = new fbDiff();\r\n\r\n  var WordDiff = new fbDiff(true);\r\n  WordDiff.tokenize = function(value) {\r\n    return removeEmpty(value.split(/(\\s+|\\b)/));\r\n  };\r\n\r\n  var CssDiff = new fbDiff(true);\r\n  CssDiff.tokenize = function(value) {\r\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\r\n  };\r\n\r\n  var LineDiff = new fbDiff();\r\n  LineDiff.tokenize = function(value) {\r\n    return value.split(/^/m);\r\n  };\r\n\r\n  return {\r\n    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },\r\n    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },\r\n    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },\r\n\r\n    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },\r\n\r\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\r\n      var ret = [];\r\n\r\n      ret.push(\"Index: \" + fileName);\r\n      ret.push(\"===================================================================\");\r\n      ret.push(\"--- \" + fileName + (typeof oldHeader === \"undefined\" ? \"\" : \"\\t\" + oldHeader));\r\n      ret.push(\"+++ \" + fileName + (typeof newHeader === \"undefined\" ? \"\" : \"\\t\" + newHeader));\r\n\r\n      var diff = LineDiff.diff(oldStr, newStr);\r\n      if (!diff[diff.length-1].value) {\r\n        diff.pop();   // Remove trailing newline add\r\n      }\r\n      diff.push({value: \"\", lines: []});   // Append an empty value to make cleanup easier\r\n\r\n      function contextLines(lines) {\r\n        return lines.map(function(entry) { return ' ' + entry; });\r\n      }\r\n      function eofNL(curRange, i, current) {\r\n        var last = diff[diff.length-2],\r\n            isLast = i === diff.length-2,\r\n            isLastOfType = i === diff.length-3 && (current.added === !last.added || current.removed === !last.removed);\r\n\r\n        // Figure out if this is the last line for the given file and missing NL\r\n        if (!/\\n$/.test(current.value) && (isLast || isLastOfType)) {\r\n          curRange.push('\\\\ No newline at end of file');\r\n        }\r\n      }\r\n\r\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\r\n          oldLine = 1, newLine = 1;\r\n      for (var i = 0; i < diff.length; i++) {\r\n        var current = diff[i],\r\n            lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\r\n        current.lines = lines;\r\n\r\n        if (current.added || current.removed) {\r\n          if (!oldRangeStart) {\r\n            var prev = diff[i-1];\r\n            oldRangeStart = oldLine;\r\n            newRangeStart = newLine;\r\n\r\n            if (prev) {\r\n              curRange = contextLines(prev.lines.slice(-4));\r\n              oldRangeStart -= curRange.length;\r\n              newRangeStart -= curRange.length;\r\n            }\r\n          }\r\n          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?\"+\":\"-\") + entry; }));\r\n          eofNL(curRange, i, current);\r\n\r\n          if (current.added) {\r\n            newLine += lines.length;\r\n          } else {\r\n            oldLine += lines.length;\r\n          }\r\n        } else {\r\n          if (oldRangeStart) {\r\n            // Close out any changes that have been output (or join overlapping)\r\n            if (lines.length <= 8 && i < diff.length-2) {\r\n              // Overlapping\r\n              curRange.push.apply(curRange, contextLines(lines));\r\n            } else {\r\n              // end the range and output\r\n              var contextSize = Math.min(lines.length, 4);\r\n              ret.push(\r\n                  \"@@ -\" + oldRangeStart + \",\" + (oldLine-oldRangeStart+contextSize)\r\n                  + \" +\" + newRangeStart + \",\" + (newLine-newRangeStart+contextSize)\r\n                  + \" @@\");\r\n              ret.push.apply(ret, curRange);\r\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\r\n              if (lines.length <= 4) {\r\n                eofNL(ret, i, current);\r\n              }\r\n\r\n              oldRangeStart = 0;  newRangeStart = 0; curRange = [];\r\n            }\r\n          }\r\n          oldLine += lines.length;\r\n          newLine += lines.length;\r\n        }\r\n      }\r\n\r\n      return ret.join('\\n') + '\\n';\r\n    },\r\n\r\n    convertChangesToXML: function(changes){\r\n      var ret = [];\r\n      for ( var i = 0; i < changes.length; i++) {\r\n        var change = changes[i];\r\n        if (change.added) {\r\n          ret.push(\"<ins>\");\r\n        } else if (change.removed) {\r\n          ret.push(\"<del>\");\r\n        }\r\n\r\n        ret.push(escapeHTML(change.value));\r\n\r\n        if (change.added) {\r\n          ret.push(\"</ins>\");\r\n        } else if (change.removed) {\r\n          ret.push(\"</del>\");\r\n        }\r\n      }\r\n      return ret.join(\"\");\r\n    }\r\n  };\r\n})();\r\n\r\nif (typeof module !== \"undefined\") {\r\n    module.exports = JsDiff;\r\n}\r\n\r\n}); // module: browser/diff.js\r\n\r\nrequire.register(\"browser/events.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nexports.EventEmitter = EventEmitter;\r\n\r\n/**\r\n * Check if `obj` is an array.\r\n */\r\n\r\nfunction isArray(obj) {\r\n  return '[object Array]' == {}.toString.call(obj);\r\n}\r\n\r\n/**\r\n * Event emitter constructor.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction EventEmitter(){};\r\n\r\n/**\r\n * Adds a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.on = function (name, fn) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = fn;\r\n  } else if (isArray(this.$events[name])) {\r\n    this.$events[name].push(fn);\r\n  } else {\r\n    this.$events[name] = [this.$events[name], fn];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n/**\r\n * Adds a volatile listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.once = function (name, fn) {\r\n  var self = this;\r\n\r\n  function on () {\r\n    self.removeListener(name, on);\r\n    fn.apply(this, arguments);\r\n  };\r\n\r\n  on.listener = fn;\r\n  this.on(name, on);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes a listener.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeListener = function (name, fn) {\r\n  if (this.$events && this.$events[name]) {\r\n    var list = this.$events[name];\r\n\r\n    if (isArray(list)) {\r\n      var pos = -1;\r\n\r\n      for (var i = 0, l = list.length; i < l; i++) {\r\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n          pos = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (pos < 0) {\r\n        return this;\r\n      }\r\n\r\n      list.splice(pos, 1);\r\n\r\n      if (!list.length) {\r\n        delete this.$events[name];\r\n      }\r\n    } else if (list === fn || (list.listener && list.listener === fn)) {\r\n      delete this.$events[name];\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Removes all listeners for an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.removeAllListeners = function (name) {\r\n  if (name === undefined) {\r\n    this.$events = {};\r\n    return this;\r\n  }\r\n\r\n  if (this.$events && this.$events[name]) {\r\n    this.$events[name] = null;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Gets all listeners for a certain event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.listeners = function (name) {\r\n  if (!this.$events) {\r\n    this.$events = {};\r\n  }\r\n\r\n  if (!this.$events[name]) {\r\n    this.$events[name] = [];\r\n  }\r\n\r\n  if (!isArray(this.$events[name])) {\r\n    this.$events[name] = [this.$events[name]];\r\n  }\r\n\r\n  return this.$events[name];\r\n};\r\n\r\n/**\r\n * Emits an event.\r\n *\r\n * @api public\r\n */\r\n\r\nEventEmitter.prototype.emit = function (name) {\r\n  if (!this.$events) {\r\n    return false;\r\n  }\r\n\r\n  var handler = this.$events[name];\r\n\r\n  if (!handler) {\r\n    return false;\r\n  }\r\n\r\n  var args = [].slice.call(arguments, 1);\r\n\r\n  if ('function' == typeof handler) {\r\n    handler.apply(this, args);\r\n  } else if (isArray(handler)) {\r\n    var listeners = handler.slice();\r\n\r\n    for (var i = 0, l = listeners.length; i < l; i++) {\r\n      listeners[i].apply(this, args);\r\n    }\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n}); // module: browser/events.js\r\n\r\nrequire.register(\"browser/fs.js\", function(module, exports, require){\r\n\r\n}); // module: browser/fs.js\r\n\r\nrequire.register(\"browser/path.js\", function(module, exports, require){\r\n\r\n}); // module: browser/path.js\r\n\r\nrequire.register(\"browser/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nmodule.exports = Progress;\r\n\r\n/**\r\n * Initialize a new `Progress` indicator.\r\n */\r\n\r\nfunction Progress() {\r\n  this.percent = 0;\r\n  this.size(0);\r\n  this.fontSize(11);\r\n  this.font('helvetica, arial, sans-serif');\r\n}\r\n\r\n/**\r\n * Set progress size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.size = function(n){\r\n  this._size = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set text to `str`.\r\n *\r\n * @param {String} str\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.text = function(str){\r\n  this._text = str;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font size to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n * @api public\r\n */\r\n\r\nProgress.prototype.fontSize = function(n){\r\n  this._fontSize = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set font `family`.\r\n *\r\n * @param {String} family\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.font = function(family){\r\n  this._font = family;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Update percentage to `n`.\r\n *\r\n * @param {Number} n\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.update = function(n){\r\n  this.percent = n;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Draw on `ctx`.\r\n *\r\n * @param {CanvasRenderingContext2d} ctx\r\n * @return {Progress} for chaining\r\n */\r\n\r\nProgress.prototype.draw = function(ctx){\r\n  var percent = Math.min(this.percent, 100)\r\n    , size = this._size\r\n    , half = size / 2\r\n    , x = half\r\n    , y = half\r\n    , rad = half - 1\r\n    , fontSize = this._fontSize;\r\n\r\n  ctx.font = fontSize + 'px ' + this._font;\r\n\r\n  var angle = Math.PI * 2 * (percent / 100);\r\n  ctx.clearRect(0, 0, size, size);\r\n\r\n  // outer circle\r\n  ctx.strokeStyle = '#9f9f9f';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad, 0, angle, false);\r\n  ctx.stroke();\r\n\r\n  // inner circle\r\n  ctx.strokeStyle = '#eee';\r\n  ctx.beginPath();\r\n  ctx.arc(x, y, rad - 1, 0, angle, true);\r\n  ctx.stroke();\r\n\r\n  // text\r\n  var text = this._text || (percent | 0) + '%'\r\n    , w = ctx.measureText(text).width;\r\n\r\n  ctx.fillText(\r\n      text\r\n    , x - w / 2 + 1\r\n    , y + fontSize / 2 - 1);\r\n\r\n  return this;\r\n};\r\n\r\n}); // module: browser/progress.js\r\n\r\nrequire.register(\"browser/tty.js\", function(module, exports, require){\r\n\r\nexports.isatty = function(){\r\n  return true;\r\n};\r\n\r\nexports.getWindowSize = function(){\r\n  return [window.innerHeight, window.innerWidth];\r\n};\r\n}); // module: browser/tty.js\r\n\r\nrequire.register(\"context.js\", function(module, exports, require){\r\n\r\n/**\r\n * Expose `Context`.\r\n */\r\n\r\nmodule.exports = Context;\r\n\r\n/**\r\n * Initialize a new `Context`.\r\n *\r\n * @api private\r\n */\r\n\r\nfunction Context(){}\r\n\r\n/**\r\n * Set or get the context `Runnable` to `runnable`.\r\n *\r\n * @param {Runnable} runnable\r\n * @return {Context}\r\n * @api private\r\n */\r\n\r\nContext.prototype.runnable = function(runnable){\r\n  if (0 == arguments.length) return this._runnable;\r\n  this.test = this._runnable = runnable;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test timeout `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.timeout = function(ms){\r\n  this.runnable().timeout(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test slowness threshold `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {Context} self\r\n * @api private\r\n */\r\n\r\nContext.prototype.slow = function(ms){\r\n  this.runnable().slow(ms);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Inspect the context void of `._runnable`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nContext.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_runnable' == key) return;\r\n    if ('test' == key) return;\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n}); // module: context.js\r\n\r\nrequire.register(\"hook.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Hook`.\r\n */\r\n\r\nmodule.exports = Hook;\r\n\r\n/**\r\n * Initialize a new `Hook` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Hook(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.type = 'hook';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Runnable.prototype;\r\nHook.prototype = new F;\r\nHook.prototype.constructor = Hook;\r\n\r\n\r\n/**\r\n * Get or set the test `err`.\r\n *\r\n * @param {Error} err\r\n * @return {Error}\r\n * @api public\r\n */\r\n\r\nHook.prototype.error = function(err){\r\n  if (0 == arguments.length) {\r\n    var err = this._error;\r\n    this._error = null;\r\n    return err;\r\n  }\r\n\r\n  this._error = err;\r\n};\r\n\r\n\r\n}); // module: hook.js\r\n\r\nrequire.register(\"interfaces/bdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * BDD-style interface:\r\n *\r\n *      describe('Array', function(){\r\n *        describe('#indexOf()', function(){\r\n *          it('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          it('should return the index when present', function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.describe = context.context = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Pending describe.\r\n     */\r\n\r\n    context.xdescribe =\r\n    context.xcontext =\r\n    context.describe.skip = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suite.pending = true;\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n    };\r\n\r\n    /**\r\n     * Exclusive suite.\r\n     */\r\n\r\n    context.describe.only = function(title, fn){\r\n      var suite = context.describe(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.it = context.specify = function(title, fn){\r\n      var suite = suites[0];\r\n      if (suite.pending) var fn = null;\r\n      var test = new Test(title, fn);\r\n      suite.addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.it.only = function(title, fn){\r\n      var test = context.it(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.xit =\r\n    context.xspecify =\r\n    context.it.skip = function(title){\r\n      context.it(title);\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/bdd.js\r\n\r\nrequire.register(\"interfaces/exports.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *     exports.Array = {\r\n *       '#indexOf()': {\r\n *         'should return -1 when the value is not present': function(){\r\n *\r\n *         },\r\n *\r\n *         'should return the correct index when the value is present': function(){\r\n *\r\n *         }\r\n *       }\r\n *     };\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('require', visit);\r\n\r\n  function visit(obj) {\r\n    var suite;\r\n    for (var key in obj) {\r\n      if ('function' == typeof obj[key]) {\r\n        var fn = obj[key];\r\n        switch (key) {\r\n          case 'before':\r\n            suites[0].beforeAll(fn);\r\n            break;\r\n          case 'after':\r\n            suites[0].afterAll(fn);\r\n            break;\r\n          case 'beforeEach':\r\n            suites[0].beforeEach(fn);\r\n            break;\r\n          case 'afterEach':\r\n            suites[0].afterEach(fn);\r\n            break;\r\n          default:\r\n            suites[0].addTest(new Test(key, fn));\r\n        }\r\n      } else {\r\n        var suite = Suite.create(suites[0], key);\r\n        suites.unshift(suite);\r\n        visit(obj[key]);\r\n        suites.shift();\r\n      }\r\n    }\r\n  }\r\n};\r\n}); // module: interfaces/exports.js\r\n\r\nrequire.register(\"interfaces/index.js\", function(module, exports, require){\r\n\r\nexports.bdd = require('./bdd');\r\nexports.tdd = require('./tdd');\r\nexports.qunit = require('./qunit');\r\nexports.exports = require('./exports');\r\n\r\n}); // module: interfaces/index.js\r\n\r\nrequire.register(\"interfaces/qunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * QUnit-style interface:\r\n *\r\n *     suite('Array');\r\n *\r\n *     test('#length', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.length == 3);\r\n *     });\r\n *\r\n *     test('#indexOf()', function(){\r\n *       var arr = [1,2,3];\r\n *       ok(arr.indexOf(1) == 0);\r\n *       ok(arr.indexOf(2) == 1);\r\n *       ok(arr.indexOf(3) == 2);\r\n *     });\r\n *\r\n *     suite('String');\r\n *\r\n *     test('#length', function(){\r\n *       ok('foo'.length == 3);\r\n *     });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context){\r\n\r\n    /**\r\n     * Execute before running tests.\r\n     */\r\n\r\n    context.before = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after running tests.\r\n     */\r\n\r\n    context.after = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.beforeEach = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.afterEach = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`.\r\n     */\r\n\r\n    context.suite = function(title){\r\n      if (suites.length > 1) suites.shift();\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      suites[0].addTest(new Test(title, fn));\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/qunit.js\r\n\r\nrequire.register(\"interfaces/tdd.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Suite = require('../suite')\r\n  , Test = require('../test');\r\n\r\n/**\r\n * TDD-style interface:\r\n *\r\n *      suite('Array', function(){\r\n *        suite('#indexOf()', function(){\r\n *          suiteSetup(function(){\r\n *\r\n *          });\r\n *\r\n *          test('should return -1 when not present', function(){\r\n *\r\n *          });\r\n *\r\n *          test('should return the index when present', function(){\r\n *\r\n *          });\r\n *\r\n *          suiteTeardown(function(){\r\n *\r\n *          });\r\n *        });\r\n *      });\r\n *\r\n */\r\n\r\nmodule.exports = function(suite){\r\n  var suites = [suite];\r\n\r\n  suite.on('pre-require', function(context, file, mocha){\r\n\r\n    /**\r\n     * Execute before each test case.\r\n     */\r\n\r\n    context.setup = function(fn){\r\n      suites[0].beforeEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after each test case.\r\n     */\r\n\r\n    context.teardown = function(fn){\r\n      suites[0].afterEach(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute before the suite.\r\n     */\r\n\r\n    context.suiteSetup = function(fn){\r\n      suites[0].beforeAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Execute after the suite.\r\n     */\r\n\r\n    context.suiteTeardown = function(fn){\r\n      suites[0].afterAll(fn);\r\n    };\r\n\r\n    /**\r\n     * Describe a \"suite\" with the given `title`\r\n     * and callback `fn` containing nested suites\r\n     * and/or tests.\r\n     */\r\n\r\n    context.suite = function(title, fn){\r\n      var suite = Suite.create(suites[0], title);\r\n      suites.unshift(suite);\r\n      fn.call(suite);\r\n      suites.shift();\r\n      return suite;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.suite.only = function(title, fn){\r\n      var suite = context.suite(title, fn);\r\n      mocha.grep(suite.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Describe a specification or test-case\r\n     * with the given `title` and callback `fn`\r\n     * acting as a thunk.\r\n     */\r\n\r\n    context.test = function(title, fn){\r\n      var test = new Test(title, fn);\r\n      suites[0].addTest(test);\r\n      return test;\r\n    };\r\n\r\n    /**\r\n     * Exclusive test-case.\r\n     */\r\n\r\n    context.test.only = function(title, fn){\r\n      var test = context.test(title, fn);\r\n      mocha.grep(test.fullTitle());\r\n    };\r\n\r\n    /**\r\n     * Pending test case.\r\n     */\r\n\r\n    context.test.skip = function(title){\r\n      context.test(title);\r\n    };\r\n  });\r\n};\r\n\r\n}); // module: interfaces/tdd.js\r\n\r\nrequire.register(\"mocha.js\", function(module, exports, require){\r\n/*!\r\n * mocha\r\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar path = require('browser/path')\r\n  , utils = require('./utils');\r\n\r\n/**\r\n * Expose `Mocha`.\r\n */\r\n\r\nexports = module.exports = Mocha;\r\n\r\n/**\r\n * Expose internals.\r\n */\r\n\r\nexports.utils = utils;\r\nexports.interfaces = require('./interfaces');\r\nexports.reporters = require('./reporters');\r\nexports.Runnable = require('./runnable');\r\nexports.Context = require('./context');\r\nexports.Runner = require('./runner');\r\nexports.Suite = require('./suite');\r\nexports.Hook = require('./hook');\r\nexports.Test = require('./test');\r\n\r\n/**\r\n * Return image `name` path.\r\n *\r\n * @param {String} name\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction image(name) {\r\n  return __dirname + '/../images/' + name + '.png';\r\n}\r\n\r\n/**\r\n * Setup mocha with `options`.\r\n *\r\n * Options:\r\n *\r\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\r\n *   - `reporter` reporter instance, defaults to `mocha.reporters.Dot`\r\n *   - `globals` array of accepted globals\r\n *   - `timeout` timeout in milliseconds\r\n *   - `bail` bail on the first test failure\r\n *   - `slow` milliseconds to wait before considering a test slow\r\n *   - `ignoreLeaks` ignore global leaks\r\n *   - `grep` string or regexp to filter tests with\r\n *\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Mocha(options) {\r\n  options = options || {};\r\n  this.files = [];\r\n  this.options = options;\r\n  this.grep(options.grep);\r\n  this.suite = new exports.Suite('', new exports.Context);\r\n  this.ui(options.ui);\r\n  this.bail(options.bail);\r\n  this.reporter(options.reporter);\r\n  if (options.timeout) this.timeout(options.timeout);\r\n  if (options.slow) this.slow(options.slow);\r\n}\r\n\r\n/**\r\n * Enable or disable bailing on the first failure.\r\n *\r\n * @param {Boolean} [bail]\r\n * @api public\r\n */\r\n\r\nMocha.prototype.bail = function(bail){\r\n  if (0 == arguments.length) bail = true;\r\n  this.suite.bail(bail);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add test `file`.\r\n *\r\n * @param {String} file\r\n * @api public\r\n */\r\n\r\nMocha.prototype.addFile = function(file){\r\n  this.files.push(file);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set reporter to `reporter`, defaults to \"dot\".\r\n *\r\n * @param {String|Function} reporter name or constructor\r\n * @api public\r\n */\r\n\r\nMocha.prototype.reporter = function(reporter){\r\n  if ('function' == typeof reporter) {\r\n    this._reporter = reporter;\r\n  } else {\r\n    reporter = reporter || 'dot';\r\n    try {\r\n      this._reporter = require('./reporters/' + reporter);\r\n    } catch (err) {\r\n      this._reporter = require(reporter);\r\n    }\r\n    if (!this._reporter) throw new Error('invalid reporter \"' + reporter + '\"');\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set test UI `name`, defaults to \"bdd\".\r\n *\r\n * @param {String} bdd\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ui = function(name){\r\n  name = name || 'bdd';\r\n  this._ui = exports.interfaces[name];\r\n  if (!this._ui) throw new Error('invalid interface \"' + name + '\"');\r\n  this._ui = this._ui(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Load registered files.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype.loadFiles = function(fn){\r\n  var self = this;\r\n  var suite = this.suite;\r\n  var pending = this.files.length;\r\n  this.files.forEach(function(file){\r\n    file = path.resolve(file);\r\n    suite.emit('pre-require', global, file, self);\r\n    suite.emit('require', require(file), file, self);\r\n    suite.emit('post-require', global, file, self);\r\n    --pending || (fn && fn());\r\n  });\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @api private\r\n */\r\n\r\nMocha.prototype._growl = function(runner, reporter) {\r\n  var notify = require('growl');\r\n\r\n  runner.on('end', function(){\r\n    var stats = reporter.stats;\r\n    if (stats.failures) {\r\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\r\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\r\n    } else {\r\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\r\n          name: 'mocha'\r\n        , title: 'Passed'\r\n        , image: image('ok')\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Add regexp to grep, if `re` is a string it is escaped.\r\n *\r\n * @param {RegExp|String} re\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.grep = function(re){\r\n  this.options.grep = 'string' == typeof re\r\n    ? new RegExp(utils.escapeRegexp(re))\r\n    : re;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Invert `.grep()` matches.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.invert = function(){\r\n  this.options.invert = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore global leaks.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.ignoreLeaks = function(){\r\n  this.options.ignoreLeaks = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable global leak checking.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.checkLeaks = function(){\r\n  this.options.ignoreLeaks = false;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Enable growl support.\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.growl = function(){\r\n  this.options.growl = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Ignore `globals` array or string.\r\n *\r\n * @param {Array|String} globals\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.globals = function(globals){\r\n  this.options.globals = (this.options.globals || []).concat(globals);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the timeout in milliseconds.\r\n *\r\n * @param {Number} timeout\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.timeout = function(timeout){\r\n  this.suite.timeout(timeout);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slowness threshold in milliseconds.\r\n *\r\n * @param {Number} slow\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.slow = function(slow){\r\n  this.suite.slow(slow);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Makes all tests async (accepting a callback)\r\n *\r\n * @return {Mocha}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.asyncOnly = function(){\r\n  this.options.asyncOnly = true;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run tests and invoke `fn()` when complete.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner}\r\n * @api public\r\n */\r\n\r\nMocha.prototype.run = function(fn){\r\n  if (this.files.length) this.loadFiles();\r\n  var suite = this.suite;\r\n  var options = this.options;\r\n  var runner = new exports.Runner(suite);\r\n  var reporter = new this._reporter(runner);\r\n  runner.ignoreLeaks = options.ignoreLeaks;\r\n  runner.asyncOnly = options.asyncOnly;\r\n  if (options.grep) runner.grep(options.grep, options.invert);\r\n  if (options.globals) runner.globals(options.globals);\r\n  if (options.growl) this._growl(runner, reporter);\r\n  return runner.run(fn);\r\n};\r\n\r\n}); // module: mocha.js\r\n\r\nrequire.register(\"ms.js\", function(module, exports, require){\r\n\r\n/**\r\n * Helpers.\r\n */\r\n\r\nvar s = 1000;\r\nvar m = s * 60;\r\nvar h = m * 60;\r\nvar d = h * 24;\r\n\r\n/**\r\n * Parse or format the given `val`.\r\n *\r\n * @param {String|Number} val\r\n * @return {String|Number}\r\n * @api public\r\n */\r\n\r\nmodule.exports = function(val){\r\n  if ('string' == typeof val) return parse(val);\r\n  return format(val);\r\n}\r\n\r\n/**\r\n * Parse the given `str` and return milliseconds.\r\n *\r\n * @param {String} str\r\n * @return {Number}\r\n * @api private\r\n */\r\n\r\nfunction parse(str) {\r\n  var m = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\r\n  if (!m) return;\r\n  var n = parseFloat(m[1]);\r\n  var type = (m[2] || 'ms').toLowerCase();\r\n  switch (type) {\r\n    case 'years':\r\n    case 'year':\r\n    case 'y':\r\n      return n * 31557600000;\r\n    case 'days':\r\n    case 'day':\r\n    case 'd':\r\n      return n * 86400000;\r\n    case 'hours':\r\n    case 'hour':\r\n    case 'h':\r\n      return n * 3600000;\r\n    case 'minutes':\r\n    case 'minute':\r\n    case 'm':\r\n      return n * 60000;\r\n    case 'seconds':\r\n    case 'second':\r\n    case 's':\r\n      return n * 1000;\r\n    case 'ms':\r\n      return n;\r\n  }\r\n}\r\n\r\n/**\r\n * Format the given `ms`.\r\n *\r\n * @param {Number} ms\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nfunction format(ms) {\r\n  if (ms == d) return Math.round(ms / d) + ' day';\r\n  if (ms > d) return Math.round(ms / d) + ' days';\r\n  if (ms == h) return Math.round(ms / h) + ' hour';\r\n  if (ms > h) return Math.round(ms / h) + ' hours';\r\n  if (ms == m) return Math.round(ms / m) + ' minute';\r\n  if (ms > m) return Math.round(ms / m) + ' minutes';\r\n  if (ms == s) return Math.round(ms / s) + ' second';\r\n  if (ms > s) return Math.round(ms / s) + ' seconds';\r\n  return ms + ' ms';\r\n}\r\n}); // module: ms.js\r\n\r\nrequire.register(\"reporters/base.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar tty = require('browser/tty')\r\n  , diff = require('browser/diff')\r\n  , ms = require('../ms');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Check if both stdio streams are associated with a tty.\r\n */\r\n\r\nvar isatty = tty.isatty(1) && tty.isatty(2);\r\n\r\n/**\r\n * Expose `Base`.\r\n */\r\n\r\nexports = module.exports = Base;\r\n\r\n/**\r\n * Enable coloring by default.\r\n */\r\n\r\nexports.useColors = isatty;\r\n\r\n/**\r\n * Default color map.\r\n */\r\n\r\nexports.colors = {\r\n    'pass': 90\r\n  , 'fail': 31\r\n  , 'bright pass': 92\r\n  , 'bright fail': 91\r\n  , 'bright yellow': 93\r\n  , 'pending': 36\r\n  , 'suite': 0\r\n  , 'error title': 0\r\n  , 'error message': 31\r\n  , 'error stack': 90\r\n  , 'checkmark': 32\r\n  , 'fast': 90\r\n  , 'medium': 33\r\n  , 'slow': 31\r\n  , 'green': 32\r\n  , 'light': 90\r\n  , 'diff gutter': 90\r\n  , 'diff added': 42\r\n  , 'diff removed': 41\r\n};\r\n\r\n/**\r\n * Default symbol map.\r\n */\r\n\r\nexports.symbols = {\r\n  ok: '✓',\r\n  err: '✖',\r\n  dot: '․'\r\n};\r\n\r\n// With node.js on Windows: use symbols available in terminal default fonts\r\nif ('win32' == process.platform) {\r\n  exports.symbols.ok = '\\u221A';\r\n  exports.symbols.err = '\\u00D7';\r\n  exports.symbols.dot = '.';\r\n}\r\n\r\n/**\r\n * Color `str` with the given `type`,\r\n * allowing colors to be disabled,\r\n * as well as user-defined color\r\n * schemes.\r\n *\r\n * @param {String} type\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nvar color = exports.color = function(type, str) {\r\n  if (!exports.useColors) return str;\r\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Expose term window size, with some\r\n * defaults for when stderr is not a tty.\r\n */\r\n\r\nexports.window = {\r\n  width: isatty\r\n    ? process.stdout.getWindowSize\r\n      ? process.stdout.getWindowSize(1)[0]\r\n      : tty.getWindowSize()[1]\r\n    : 75\r\n};\r\n\r\n/**\r\n * Expose some basic cursor interactions\r\n * that are common among reporters.\r\n */\r\n\r\nexports.cursor = {\r\n  hide: function(){\r\n    process.stdout.write('\\u001b[?25l');\r\n  },\r\n\r\n  show: function(){\r\n    process.stdout.write('\\u001b[?25h');\r\n  },\r\n\r\n  deleteLine: function(){\r\n    process.stdout.write('\\u001b[2K');\r\n  },\r\n\r\n  beginningOfLine: function(){\r\n    process.stdout.write('\\u001b[0G');\r\n  },\r\n\r\n  CR: function(){\r\n    exports.cursor.deleteLine();\r\n    exports.cursor.beginningOfLine();\r\n  }\r\n};\r\n\r\n/**\r\n * Outut the given `failures` as a list.\r\n *\r\n * @param {Array} failures\r\n * @api public\r\n */\r\n\r\nexports.list = function(failures){\r\n  console.error();\r\n  failures.forEach(function(test, i){\r\n    // format\r\n    var fmt = color('error title', '  %s) %s:\\n')\r\n      + color('error message', '     %s')\r\n      + color('error stack', '\\n%s\\n');\r\n\r\n    // msg\r\n    var err = test.err\r\n      , message = err.message || ''\r\n      , stack = err.stack || message\r\n      , index = stack.indexOf(message) + message.length\r\n      , msg = stack.slice(0, index)\r\n      , actual = err.actual\r\n      , expected = err.expected\r\n      , escape = true;\r\n\r\n    // explicitly show diff\r\n    if (err.showDiff) {\r\n      escape = false;\r\n      err.actual = actual = JSON.stringify(actual, null, 2);\r\n      err.expected = expected = JSON.stringify(expected, null, 2);\r\n    }\r\n\r\n    // actual / expected diff\r\n    if ('string' == typeof actual && 'string' == typeof expected) {\r\n      var len = Math.max(actual.length, expected.length);\r\n\r\n      if (len < 20) msg = errorDiff(err, 'Chars', escape);\r\n      else msg = errorDiff(err, 'Words', escape);\r\n\r\n      // linenos\r\n      var lines = msg.split('\\n');\r\n      if (lines.length > 4) {\r\n        var width = String(lines.length).length;\r\n        msg = lines.map(function(str, i){\r\n          return pad(++i, width) + ' |' + ' ' + str;\r\n        }).join('\\n');\r\n      }\r\n\r\n      // legend\r\n      msg = '\\n'\r\n        + color('diff removed', 'actual')\r\n        + ' '\r\n        + color('diff added', 'expected')\r\n        + '\\n\\n'\r\n        + msg\r\n        + '\\n';\r\n\r\n      // indent\r\n      msg = msg.replace(/^/gm, '      ');\r\n\r\n      fmt = color('error title', '  %s) %s:\\n%s')\r\n        + color('error stack', '\\n%s\\n');\r\n    }\r\n\r\n    // indent stack trace without msg\r\n    stack = stack.slice(index ? index + 1 : index)\r\n      .replace(/^/gm, '  ');\r\n\r\n    console.error(fmt, (i + 1), test.fullTitle(), msg, stack);\r\n  });\r\n};\r\n\r\n/**\r\n * Initialize a new `Base` reporter.\r\n *\r\n * All other reporters generally\r\n * inherit from this reporter, providing\r\n * stats such as test duration, number\r\n * of tests passed / failed etc.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Base(runner) {\r\n  var self = this\r\n    , stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 }\r\n    , failures = this.failures = [];\r\n\r\n  if (!runner) return;\r\n  this.runner = runner;\r\n\r\n  runner.stats = stats;\r\n\r\n  runner.on('start', function(){\r\n    stats.start = new Date;\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    stats.suites = stats.suites || 0;\r\n    suite.root || stats.suites++;\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    stats.tests = stats.tests || 0;\r\n    stats.tests++;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    stats.passes = stats.passes || 0;\r\n\r\n    var medium = test.slow() / 2;\r\n    test.speed = test.duration > test.slow()\r\n      ? 'slow'\r\n      : test.duration > medium\r\n        ? 'medium'\r\n        : 'fast';\r\n\r\n    stats.passes++;\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    stats.failures = stats.failures || 0;\r\n    stats.failures++;\r\n    test.err = err;\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    stats.end = new Date;\r\n    stats.duration = new Date - stats.start;\r\n  });\r\n\r\n  runner.on('pending', function(){\r\n    stats.pending++;\r\n  });\r\n}\r\n\r\n/**\r\n * Output common epilogue used by many of\r\n * the bundled reporters.\r\n *\r\n * @api public\r\n */\r\n\r\nBase.prototype.epilogue = function(){\r\n  var stats = this.stats\r\n    , fmt\r\n    , tests;\r\n\r\n  console.log();\r\n\r\n  function pluralize(n) {\r\n    return 1 == n ? 'test' : 'tests';\r\n  }\r\n\r\n  // failure\r\n  if (stats.failures) {\r\n    fmt = color('bright fail', '  ' + exports.symbols.err)\r\n      + color('fail', ' %d of %d %s failed')\r\n      + color('light', ':')\r\n\r\n    console.error(fmt,\r\n      stats.failures,\r\n      this.runner.total,\r\n      pluralize(this.runner.total));\r\n\r\n    Base.list(this.failures);\r\n    console.error();\r\n    return;\r\n  }\r\n\r\n  // pass\r\n  fmt = color('bright pass', ' ')\r\n    + color('green', ' %d %s complete')\r\n    + color('light', ' (%s)');\r\n\r\n  console.log(fmt,\r\n    stats.tests || 0,\r\n    pluralize(stats.tests),\r\n    ms(stats.duration));\r\n\r\n  // pending\r\n  if (stats.pending) {\r\n    fmt = color('pending', ' ')\r\n      + color('pending', ' %d %s pending');\r\n\r\n    console.log(fmt, stats.pending, pluralize(stats.pending));\r\n  }\r\n\r\n  console.log();\r\n};\r\n\r\n/**\r\n * Pad the given `str` to `len`.\r\n *\r\n * @param {String} str\r\n * @param {String} len\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction pad(str, len) {\r\n  str = String(str);\r\n  return Array(len - str.length + 1).join(' ') + str;\r\n}\r\n\r\n/**\r\n * Return a character diff for `err`.\r\n *\r\n * @param {Error} err\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction errorDiff(err, type, escape) {\r\n  return diff['diff' + type](err.actual, err.expected).map(function(str){\r\n    if (escape) {\r\n      str.value = str.value\r\n        .replace(/\\t/g, '<tab>')\r\n        .replace(/\\r/g, '<CR>')\r\n        .replace(/\\n/g, '<LF>\\n');\r\n    }\r\n    if (str.added) return colorLines('diff added', str.value);\r\n    if (str.removed) return colorLines('diff removed', str.value);\r\n    return str.value;\r\n  }).join('');\r\n}\r\n\r\n/**\r\n * Color lines for `str`, using the color `name`.\r\n *\r\n * @param {String} name\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction colorLines(name, str) {\r\n  return str.split('\\n').map(function(str){\r\n    return color(name, str);\r\n  }).join('\\n');\r\n}\r\n\r\n}); // module: reporters/base.js\r\n\r\nrequire.register(\"reporters/doc.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = Doc;\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Doc(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , indents = 2;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ');\r\n  }\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n    ++indents;\r\n    console.log('%s<section class=\"suite\">', indent());\r\n    ++indents;\r\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\r\n    console.log('%s<dl>', indent());\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    console.log('%s</dl>', indent());\r\n    --indents;\r\n    console.log('%s</section>', indent());\r\n    --indents;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\r\n    var code = utils.escape(utils.clean(test.fn.toString()));\r\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\r\n  });\r\n}\r\n\r\n}); // module: reporters/doc.js\r\n\r\nrequire.register(\"reporters/dot.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = Dot;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Dot(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    process.stdout.write('\\n  ');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    process.stdout.write(color('pending', Base.symbols.dot));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    if ('slow' == test.speed) {\r\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\r\n    } else {\r\n      process.stdout.write(color(test.speed, Base.symbols.dot));\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if (++n % width == 0) process.stdout.write('\\n  ');\r\n    process.stdout.write(color('fail', Base.symbols.dot));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nDot.prototype = new F;\r\nDot.prototype.constructor = Dot;\r\n\r\n}); // module: reporters/dot.js\r\n\r\nrequire.register(\"reporters/html-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar JSONCov = require('./json-cov')\r\n  , fs = require('browser/fs');\r\n\r\n/**\r\n * Expose `HTMLCov`.\r\n */\r\n\r\nexports = module.exports = HTMLCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTMLCov(runner) {\r\n  var jade = require('jade')\r\n    , file = __dirname + '/templates/coverage.jade'\r\n    , str = fs.readFileSync(file, 'utf8')\r\n    , fn = jade.compile(str, { filename: file })\r\n    , self = this;\r\n\r\n  JSONCov.call(this, runner, false);\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(fn({\r\n        cov: self.cov\r\n      , coverageClass: coverageClass\r\n    }));\r\n  });\r\n}\r\n\r\n/**\r\n * Return coverage class for `n`.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction coverageClass(n) {\r\n  if (n >= 75) return 'high';\r\n  if (n >= 50) return 'medium';\r\n  if (n >= 25) return 'low';\r\n  return 'terrible';\r\n}\r\n}); // module: reporters/html-cov.js\r\n\r\nrequire.register(\"reporters/html.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , Progress = require('../browser/progress')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `Doc`.\r\n */\r\n\r\nexports = module.exports = HTML;\r\n\r\n/**\r\n * Stats template.\r\n */\r\n\r\nvar statsTemplate = '<ul id=\"mocha-stats\">'\r\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\r\n  + '<li class=\"passes\"><a href=\"#\">passes:</a> <em>0</em></li>'\r\n  + '<li class=\"failures\"><a href=\"#\">failures:</a> <em>0</em></li>'\r\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\r\n  + '</ul>';\r\n\r\n/**\r\n * Initialize a new `Doc` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction HTML(runner, root) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total\r\n    , stat = fragment(statsTemplate)\r\n    , items = stat.getElementsByTagName('li')\r\n    , passes = items[1].getElementsByTagName('em')[0]\r\n    , passesLink = items[1].getElementsByTagName('a')[0]\r\n    , failures = items[2].getElementsByTagName('em')[0]\r\n    , failuresLink = items[2].getElementsByTagName('a')[0]\r\n    , duration = items[3].getElementsByTagName('em')[0]\r\n    , canvas = stat.getElementsByTagName('canvas')[0]\r\n    , report = fragment('<ul id=\"mocha-report\"></ul>')\r\n    , stack = [report]\r\n    , progress\r\n    , ctx\r\n\r\n  root = root || document.getElementById('mocha');\r\n\r\n  if (canvas.getContext) {\r\n    var ratio = window.devicePixelRatio || 1;\r\n    canvas.style.width = canvas.width;\r\n    canvas.style.height = canvas.height;\r\n    canvas.width *= ratio;\r\n    canvas.height *= ratio;\r\n    ctx = canvas.getContext('2d');\r\n    ctx.scale(ratio, ratio);\r\n    progress = new Progress;\r\n  }\r\n\r\n  if (!root) return error('#mocha div missing, add it to your document');\r\n\r\n  // pass toggle\r\n  on(passesLink, 'click', function(){\r\n    unhide();\r\n    var name = /pass/.test(report.className) ? '' : ' pass';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) hideSuitesWithout('test pass');\r\n  });\r\n\r\n  // failure toggle\r\n  on(failuresLink, 'click', function(){\r\n    unhide();\r\n    var name = /fail/.test(report.className) ? '' : ' fail';\r\n    report.className = report.className.replace(/fail|pass/g, '') + name;\r\n    if (report.className.trim()) hideSuitesWithout('test fail');\r\n  });\r\n\r\n  root.appendChild(stat);\r\n  root.appendChild(report);\r\n\r\n  if (progress) progress.size(40);\r\n\r\n  runner.on('suite', function(suite){\r\n    if (suite.root) return;\r\n\r\n    // suite\r\n    var url = '?grep=' + encodeURIComponent(suite.fullTitle());\r\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\r\n\r\n    // container\r\n    stack[0].appendChild(el);\r\n    stack.unshift(document.createElement('ul'));\r\n    el.appendChild(stack[0]);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    if (suite.root) return;\r\n    stack.shift();\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    if ('hook' == test.type) runner.emit('test end', test);\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    window.scrollTo(0, document.body.scrollHeight);\r\n\r\n    // TODO: add to stats\r\n    var percent = stats.tests / this.total * 100 | 0;\r\n    if (progress) progress.update(percent).draw(ctx);\r\n\r\n    // update stats\r\n    var ms = new Date - stats.start;\r\n    text(passes, stats.passes);\r\n    text(failures, stats.failures);\r\n    text(duration, (ms / 1000).toFixed(2));\r\n\r\n    // test\r\n    if ('passed' == test.state) {\r\n      var el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"?grep=%e\" class=\"replay\">‣</a></h2></li>', test.speed, test.title, test.duration, encodeURIComponent(test.fullTitle()));\r\n    } else if (test.pending) {\r\n      var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\r\n    } else {\r\n      var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"?grep=%e\" class=\"replay\">‣</a></h2></li>', test.title, encodeURIComponent(test.fullTitle()));\r\n      var str = test.err.stack || test.err.toString();\r\n\r\n      // FF / Opera do not add the message\r\n      if (!~str.indexOf(test.err.message)) {\r\n        str = test.err.message + '\\n' + str;\r\n      }\r\n\r\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\r\n      // check for the result of the stringifying.\r\n      if ('[object Error]' == str) str = test.err.message;\r\n\r\n      // Safari doesn't give you a stack. Let's at least provide a source line.\r\n      if (!test.err.stack && test.err.sourceURL && test.err.line !== undefined) {\r\n        str += \"\\n(\" + test.err.sourceURL + \":\" + test.err.line + \")\";\r\n      }\r\n\r\n      el.appendChild(fragment('<pre class=\"error\">%e</pre>', str));\r\n    }\r\n\r\n    // toggle code\r\n    // TODO: defer\r\n    if (!test.pending) {\r\n      var h2 = el.getElementsByTagName('h2')[0];\r\n\r\n      on(h2, 'click', function(){\r\n        pre.style.display = 'none' == pre.style.display\r\n          ? 'block'\r\n          : 'none';\r\n      });\r\n\r\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.fn.toString()));\r\n      el.appendChild(pre);\r\n      pre.style.display = 'none';\r\n    }\r\n\r\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\r\n    if (stack[0]) stack[0].appendChild(el);\r\n  });\r\n}\r\n\r\n/**\r\n * Display error `msg`.\r\n */\r\n\r\nfunction error(msg) {\r\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\r\n}\r\n\r\n/**\r\n * Return a DOM fragment from `html`.\r\n */\r\n\r\nfunction fragment(html) {\r\n  var args = arguments\r\n    , div = document.createElement('div')\r\n    , i = 1;\r\n\r\n  div.innerHTML = html.replace(/%([se])/g, function(_, type){\r\n    switch (type) {\r\n      case 's': return String(args[i++]);\r\n      case 'e': return escape(args[i++]);\r\n    }\r\n  });\r\n\r\n  return div.firstChild;\r\n}\r\n\r\n/**\r\n * Check for suites that do not have elements\r\n * with `classname`, and hide them.\r\n */\r\n\r\nfunction hideSuitesWithout(classname) {\r\n  var suites = document.getElementsByClassName('suite');\r\n  for (var i = 0; i < suites.length; i++) {\r\n    var els = suites[i].getElementsByClassName(classname);\r\n    if (0 == els.length) suites[i].className += ' hidden';\r\n  }\r\n}\r\n\r\n/**\r\n * Unhide .hidden suites.\r\n */\r\n\r\nfunction unhide() {\r\n  var els = document.getElementsByClassName('suite hidden');\r\n  for (var i = 0; i < els.length; ++i) {\r\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\r\n  }\r\n}\r\n\r\n/**\r\n * Set `el` text to `str`.\r\n */\r\n\r\nfunction text(el, str) {\r\n  if (el.textContent) {\r\n    el.textContent = str;\r\n  } else {\r\n    el.innerText = str;\r\n  }\r\n}\r\n\r\n/**\r\n * Listen on `event` with callback `fn`.\r\n */\r\n\r\nfunction on(el, event, fn) {\r\n  if (el.addEventListener) {\r\n    el.addEventListener(event, fn, false);\r\n  } else {\r\n    el.attachEvent('on' + event, fn);\r\n  }\r\n}\r\n\r\n}); // module: reporters/html.js\r\n\r\nrequire.register(\"reporters/index.js\", function(module, exports, require){\r\n\r\nexports.Base = require('./base');\r\nexports.Dot = require('./dot');\r\nexports.Doc = require('./doc');\r\nexports.TAP = require('./tap');\r\nexports.JSON = require('./json');\r\nexports.HTML = require('./html');\r\nexports.List = require('./list');\r\nexports.Min = require('./min');\r\nexports.Spec = require('./spec');\r\nexports.Nyan = require('./nyan');\r\nexports.XUnit = require('./xunit');\r\nexports.Markdown = require('./markdown');\r\nexports.Progress = require('./progress');\r\nexports.Landing = require('./landing');\r\nexports.JSONCov = require('./json-cov');\r\nexports.HTMLCov = require('./html-cov');\r\nexports.JSONStream = require('./json-stream');\r\nexports.Teamcity = require('./teamcity');\r\n\r\n}); // module: reporters/index.js\r\n\r\nrequire.register(\"reporters/json-cov.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `JSONCov`.\r\n */\r\n\r\nexports = module.exports = JSONCov;\r\n\r\n/**\r\n * Initialize a new `JsCoverage` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Boolean} output\r\n * @api public\r\n */\r\n\r\nfunction JSONCov(runner, output) {\r\n  var self = this\r\n    , output = 1 == arguments.length ? true : output;\r\n\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var cov = global._$jscoverage || {};\r\n    var result = self.cov = map(cov);\r\n    result.stats = self.stats;\r\n    result.tests = tests.map(clean);\r\n    result.failures = failures.map(clean);\r\n    result.passes = passes.map(clean);\r\n    if (!output) return;\r\n    process.stdout.write(JSON.stringify(result, null, 2 ));\r\n  });\r\n}\r\n\r\n/**\r\n * Map jscoverage data to a JSON structure\r\n * suitable for reporting.\r\n *\r\n * @param {Object} cov\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction map(cov) {\r\n  var ret = {\r\n      instrumentation: 'node-jscoverage'\r\n    , sloc: 0\r\n    , hits: 0\r\n    , misses: 0\r\n    , coverage: 0\r\n    , files: []\r\n  };\r\n\r\n  for (var filename in cov) {\r\n    var data = coverage(filename, cov[filename]);\r\n    ret.files.push(data);\r\n    ret.hits += data.hits;\r\n    ret.misses += data.misses;\r\n    ret.sloc += data.sloc;\r\n  }\r\n\r\n  ret.files.sort(function(a, b) {\r\n    return a.filename.localeCompare(b.filename);\r\n  });\r\n\r\n  if (ret.sloc > 0) {\r\n    ret.coverage = (ret.hits / ret.sloc) * 100;\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Map jscoverage data for a single source file\r\n * to a JSON structure suitable for reporting.\r\n *\r\n * @param {String} filename name of the source file\r\n * @param {Object} data jscoverage coverage data\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction coverage(filename, data) {\r\n  var ret = {\r\n    filename: filename,\r\n    coverage: 0,\r\n    hits: 0,\r\n    misses: 0,\r\n    sloc: 0,\r\n    source: {}\r\n  };\r\n\r\n  data.source.forEach(function(line, num){\r\n    num++;\r\n\r\n    if (data[num] === 0) {\r\n      ret.misses++;\r\n      ret.sloc++;\r\n    } else if (data[num] !== undefined) {\r\n      ret.hits++;\r\n      ret.sloc++;\r\n    }\r\n\r\n    ret.source[num] = {\r\n        source: line\r\n      , coverage: data[num] === undefined\r\n        ? ''\r\n        : data[num]\r\n    };\r\n  });\r\n\r\n  ret.coverage = ret.hits / ret.sloc * 100;\r\n\r\n  return ret;\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n\r\n}); // module: reporters/json-cov.js\r\n\r\nrequire.register(\"reporters/json-stream.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , total = runner.total;\r\n\r\n  runner.on('start', function(){\r\n    console.log(JSON.stringify(['start', { total: total }]));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    console.log(JSON.stringify(['pass', clean(test)]));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    console.log(JSON.stringify(['fail', clean(test)]));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write(JSON.stringify(['end', self.stats]));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json-stream.js\r\n\r\nrequire.register(\"reporters/json.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `JSON`.\r\n */\r\n\r\nexports = module.exports = JSONReporter;\r\n\r\n/**\r\n * Initialize a new `JSON` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction JSONReporter(runner) {\r\n  var self = this;\r\n  Base.call(this, runner);\r\n\r\n  var tests = []\r\n    , failures = []\r\n    , passes = [];\r\n\r\n  runner.on('test end', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    failures.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    var obj = {\r\n        stats: self.stats\r\n      , tests: tests.map(clean)\r\n      , failures: failures.map(clean)\r\n      , passes: passes.map(clean)\r\n    };\r\n\r\n    process.stdout.write(JSON.stringify(obj, null, 2));\r\n  });\r\n}\r\n\r\n/**\r\n * Return a plain-object representation of `test`\r\n * free of cyclic properties etc.\r\n *\r\n * @param {Object} test\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction clean(test) {\r\n  return {\r\n      title: test.title\r\n    , fullTitle: test.fullTitle()\r\n    , duration: test.duration\r\n  }\r\n}\r\n}); // module: reporters/json.js\r\n\r\nrequire.register(\"reporters/landing.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Landing`.\r\n */\r\n\r\nexports = module.exports = Landing;\r\n\r\n/**\r\n * Airplane color.\r\n */\r\n\r\nBase.colors.plane = 0;\r\n\r\n/**\r\n * Airplane crash color.\r\n */\r\n\r\nBase.colors['plane crash'] = 31;\r\n\r\n/**\r\n * Runway color.\r\n */\r\n\r\nBase.colors.runway = 90;\r\n\r\n/**\r\n * Initialize a new `Landing` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Landing(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , total = runner.total\r\n    , stream = process.stdout\r\n    , plane = color('plane', '✈')\r\n    , crashed = -1\r\n    , n = 0;\r\n\r\n  function runway() {\r\n    var buf = Array(width).join('-');\r\n    return '  ' + color('runway', buf);\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    stream.write('\\n  ');\r\n    cursor.hide();\r\n  });\r\n\r\n  runner.on('test end', function(test){\r\n    // check if the plane crashed\r\n    var col = -1 == crashed\r\n      ? width * ++n / total | 0\r\n      : crashed;\r\n\r\n    // show the crash\r\n    if ('failed' == test.state) {\r\n      plane = color('plane crash', '✈');\r\n      crashed = col;\r\n    }\r\n\r\n    // render landing strip\r\n    stream.write('\\u001b[4F\\n\\n');\r\n    stream.write(runway());\r\n    stream.write('\\n  ');\r\n    stream.write(color('runway', Array(col).join('⋅')));\r\n    stream.write(plane)\r\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\r\n    stream.write(runway());\r\n    stream.write('\\u001b[0m');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nLanding.prototype = new F;\r\nLanding.prototype.constructor = Landing;\r\n\r\n}); // module: reporters/landing.js\r\n\r\nrequire.register(\"reporters/list.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `List`.\r\n */\r\n\r\nexports = module.exports = List;\r\n\r\n/**\r\n * Initialize a new `List` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction List(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = color('checkmark', '  -')\r\n      + color('pending', ' %s');\r\n    console.log(fmt, test.fullTitle());\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var fmt = color('checkmark', '  '+Base.symbols.dot)\r\n      + color('pass', ' %s: ')\r\n      + color(test.speed, '%dms');\r\n    cursor.CR();\r\n    console.log(fmt, test.fullTitle(), test.duration);\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nList.prototype = new F;\r\nList.prototype.constructor = List;\r\n\r\n\r\n}); // module: reporters/list.js\r\n\r\nrequire.register(\"reporters/markdown.js\", function(module, exports, require){\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils');\r\n\r\n/**\r\n * Expose `Markdown`.\r\n */\r\n\r\nexports = module.exports = Markdown;\r\n\r\n/**\r\n * Initialize a new `Markdown` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Markdown(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , level = 0\r\n    , buf = '';\r\n\r\n  function title(str) {\r\n    return Array(level).join('#') + ' ' + str;\r\n  }\r\n\r\n  function indent() {\r\n    return Array(level).join('  ');\r\n  }\r\n\r\n  function mapTOC(suite, obj) {\r\n    var ret = obj;\r\n    obj = obj[suite.title] = obj[suite.title] || { suite: suite };\r\n    suite.suites.forEach(function(suite){\r\n      mapTOC(suite, obj);\r\n    });\r\n    return ret;\r\n  }\r\n\r\n  function stringifyTOC(obj, level) {\r\n    ++level;\r\n    var buf = '';\r\n    var link;\r\n    for (var key in obj) {\r\n      if ('suite' == key) continue;\r\n      if (key) link = ' - [' + key + '](#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\r\n      if (key) buf += Array(level).join('  ') + link;\r\n      buf += stringifyTOC(obj[key], level);\r\n    }\r\n    --level;\r\n    return buf;\r\n  }\r\n\r\n  function generateTOC(suite) {\r\n    var obj = mapTOC(suite, {});\r\n    return stringifyTOC(obj, 0);\r\n  }\r\n\r\n  generateTOC(runner.suite);\r\n\r\n  runner.on('suite', function(suite){\r\n    ++level;\r\n    var slug = utils.slug(suite.fullTitle());\r\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\r\n    buf += title(suite.title) + '\\n';\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --level;\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    var code = utils.clean(test.fn.toString());\r\n    buf += test.title + '.\\n';\r\n    buf += '\\n```js\\n';\r\n    buf += code + '\\n';\r\n    buf += '```\\n\\n';\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    process.stdout.write('# TOC\\n');\r\n    process.stdout.write(generateTOC(runner.suite));\r\n    process.stdout.write(buf);\r\n  });\r\n}\r\n}); // module: reporters/markdown.js\r\n\r\nrequire.register(\"reporters/min.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Min`.\r\n */\r\n\r\nexports = module.exports = Min;\r\n\r\n/**\r\n * Initialize a new `Min` minimal test reporter (best used with --watch).\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Min(runner) {\r\n  Base.call(this, runner);\r\n\r\n  runner.on('start', function(){\r\n    // clear screen\r\n    process.stdout.write('\\u001b[2J');\r\n    // set cursor position\r\n    process.stdout.write('\\u001b[1;3H');\r\n  });\r\n\r\n  runner.on('end', this.epilogue.bind(this));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nMin.prototype = new F;\r\nMin.prototype.constructor = Min;\r\n\r\n}); // module: reporters/min.js\r\n\r\nrequire.register(\"reporters/nyan.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Dot`.\r\n */\r\n\r\nexports = module.exports = NyanCat;\r\n\r\n/**\r\n * Initialize a new `Dot` matrix test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction NyanCat(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , width = Base.window.width * .75 | 0\r\n    , rainbowColors = this.rainbowColors = self.generateColors()\r\n    , colorIndex = this.colorIndex = 0\r\n    , numerOfLines = this.numberOfLines = 4\r\n    , trajectories = this.trajectories = [[], [], [], []]\r\n    , nyanCatWidth = this.nyanCatWidth = 11\r\n    , trajectoryWidthMax = this.trajectoryWidthMax = (width - nyanCatWidth)\r\n    , scoreboardWidth = this.scoreboardWidth = 5\r\n    , tick = this.tick = 0\r\n    , n = 0;\r\n\r\n  runner.on('start', function(){\r\n    Base.cursor.hide();\r\n    self.draw('start');\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    self.draw('pending');\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    self.draw('pass');\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    self.draw('fail');\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    Base.cursor.show();\r\n    for (var i = 0; i < self.numberOfLines; i++) write('\\n');\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Draw the nyan cat with runner `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.draw = function(status){\r\n  this.appendRainbow();\r\n  this.drawScoreboard();\r\n  this.drawRainbow();\r\n  this.drawNyanCat(status);\r\n  this.tick = !this.tick;\r\n};\r\n\r\n/**\r\n * Draw the \"scoreboard\" showing the number\r\n * of passes, failures and pending tests.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawScoreboard = function(){\r\n  var stats = this.stats;\r\n  var colors = Base.colors;\r\n\r\n  function draw(color, n) {\r\n    write(' ');\r\n    write('\\u001b[' + color + 'm' + n + '\\u001b[0m');\r\n    write('\\n');\r\n  }\r\n\r\n  draw(colors.green, stats.passes);\r\n  draw(colors.fail, stats.failures);\r\n  draw(colors.pending, stats.pending);\r\n  write('\\n');\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Append the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.appendRainbow = function(){\r\n  var segment = this.tick ? '_' : '-';\r\n  var rainbowified = this.rainbowify(segment);\r\n\r\n  for (var index = 0; index < this.numberOfLines; index++) {\r\n    var trajectory = this.trajectories[index];\r\n    if (trajectory.length >= this.trajectoryWidthMax) trajectory.shift();\r\n    trajectory.push(rainbowified);\r\n  }\r\n};\r\n\r\n/**\r\n * Draw the rainbow.\r\n *\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawRainbow = function(){\r\n  var self = this;\r\n\r\n  this.trajectories.forEach(function(line, index) {\r\n    write('\\u001b[' + self.scoreboardWidth + 'C');\r\n    write(line.join(''));\r\n    write('\\n');\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Draw the nyan cat with `status`.\r\n *\r\n * @param {String} status\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.drawNyanCat = function(status) {\r\n  var self = this;\r\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\r\n\r\n  [0, 1, 2, 3].forEach(function(index) {\r\n    write('\\u001b[' + startWidth + 'C');\r\n\r\n    switch (index) {\r\n      case 0:\r\n        write('_,------,');\r\n        write('\\n');\r\n        break;\r\n      case 1:\r\n        var padding = self.tick ? '  ' : '   ';\r\n        write('_|' + padding + '/\\\\_/\\\\ ');\r\n        write('\\n');\r\n        break;\r\n      case 2:\r\n        var padding = self.tick ? '_' : '__';\r\n        var tail = self.tick ? '~' : '^';\r\n        var face;\r\n        switch (status) {\r\n          case 'pass':\r\n            face = '( ^ .^)';\r\n            break;\r\n          case 'fail':\r\n            face = '( o .o)';\r\n            break;\r\n          default:\r\n            face = '( - .-)';\r\n        }\r\n        write(tail + '|' + padding + face + ' ');\r\n        write('\\n');\r\n        break;\r\n      case 3:\r\n        var padding = self.tick ? ' ' : '  ';\r\n        write(padding + '\"\"  \"\" ');\r\n        write('\\n');\r\n        break;\r\n    }\r\n  });\r\n\r\n  this.cursorUp(this.numberOfLines);\r\n};\r\n\r\n/**\r\n * Move cursor up `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorUp = function(n) {\r\n  write('\\u001b[' + n + 'A');\r\n};\r\n\r\n/**\r\n * Move cursor down `n`.\r\n *\r\n * @param {Number} n\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.cursorDown = function(n) {\r\n  write('\\u001b[' + n + 'B');\r\n};\r\n\r\n/**\r\n * Generate rainbow colors.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.generateColors = function(){\r\n  var colors = [];\r\n\r\n  for (var i = 0; i < (6 * 7); i++) {\r\n    var pi3 = Math.floor(Math.PI / 3);\r\n    var n = (i * (1.0 / 6));\r\n    var r = Math.floor(3 * Math.sin(n) + 3);\r\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\r\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\r\n    colors.push(36 * r + 6 * g + b + 16);\r\n  }\r\n\r\n  return colors;\r\n};\r\n\r\n/**\r\n * Apply rainbow to the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nNyanCat.prototype.rainbowify = function(str){\r\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\r\n  this.colorIndex += 1;\r\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\r\n};\r\n\r\n/**\r\n * Stdout helper.\r\n */\r\n\r\nfunction write(string) {\r\n  process.stdout.write(string);\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nNyanCat.prototype = new F;\r\nNyanCat.prototype.constructor = NyanCat;\r\n\r\n\r\n}); // module: reporters/nyan.js\r\n\r\nrequire.register(\"reporters/progress.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Progress`.\r\n */\r\n\r\nexports = module.exports = Progress;\r\n\r\n/**\r\n * General progress bar color.\r\n */\r\n\r\nBase.colors.progress = 90;\r\n\r\n/**\r\n * Initialize a new `Progress` bar test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @param {Object} options\r\n * @api public\r\n */\r\n\r\nfunction Progress(runner, options) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , options = options || {}\r\n    , stats = this.stats\r\n    , width = Base.window.width * .50 | 0\r\n    , total = runner.total\r\n    , complete = 0\r\n    , max = Math.max;\r\n\r\n  // default chars\r\n  options.open = options.open || '[';\r\n  options.complete = options.complete || '▬';\r\n  options.incomplete = options.incomplete || Base.symbols.dot;\r\n  options.close = options.close || ']';\r\n  options.verbose = false;\r\n\r\n  // tests started\r\n  runner.on('start', function(){\r\n    console.log();\r\n    cursor.hide();\r\n  });\r\n\r\n  // tests complete\r\n  runner.on('test end', function(){\r\n    complete++;\r\n    var incomplete = total - complete\r\n      , percent = complete / total\r\n      , n = width * percent | 0\r\n      , i = width - n;\r\n\r\n    cursor.CR();\r\n    process.stdout.write('\\u001b[J');\r\n    process.stdout.write(color('progress', '  ' + options.open));\r\n    process.stdout.write(Array(n).join(options.complete));\r\n    process.stdout.write(Array(i).join(options.incomplete));\r\n    process.stdout.write(color('progress', options.close));\r\n    if (options.verbose) {\r\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\r\n    }\r\n  });\r\n\r\n  // tests are complete, output some stats\r\n  // and the failures if any\r\n  runner.on('end', function(){\r\n    cursor.show();\r\n    console.log();\r\n    self.epilogue();\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nProgress.prototype = new F;\r\nProgress.prototype.constructor = Progress;\r\n\r\n\r\n}); // module: reporters/progress.js\r\n\r\nrequire.register(\"reporters/spec.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `Spec`.\r\n */\r\n\r\nexports = module.exports = Spec;\r\n\r\n/**\r\n * Initialize a new `Spec` test reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Spec(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , indents = 0\r\n    , n = 0;\r\n\r\n  function indent() {\r\n    return Array(indents).join('  ')\r\n  }\r\n\r\n  runner.on('start', function(){\r\n    console.log();\r\n  });\r\n\r\n  runner.on('suite', function(suite){\r\n    ++indents;\r\n    console.log(color('suite', '%s%s'), indent(), suite.title);\r\n  });\r\n\r\n  runner.on('suite end', function(suite){\r\n    --indents;\r\n    if (1 == indents) console.log();\r\n  });\r\n\r\n  runner.on('test', function(test){\r\n    process.stdout.write(indent() + color('pass', '  ◦ ' + test.title + ': '));\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    var fmt = indent() + color('pending', '  - %s');\r\n    console.log(fmt, test.title);\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    if ('fast' == test.speed) {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ' + Base.symbols.ok)\r\n        + color('pass', ' %s ');\r\n      cursor.CR();\r\n      console.log(fmt, test.title);\r\n    } else {\r\n      var fmt = indent()\r\n        + color('checkmark', '  ' + Base.symbols.ok)\r\n        + color('pass', ' %s ')\r\n        + color(test.speed, '(%dms)');\r\n      cursor.CR();\r\n      console.log(fmt, test.title, test.duration);\r\n    }\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    cursor.CR();\r\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\r\n  });\r\n\r\n  runner.on('end', self.epilogue.bind(self));\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nSpec.prototype = new F;\r\nSpec.prototype.constructor = Spec;\r\n\r\n\r\n}); // module: reporters/spec.js\r\n\r\nrequire.register(\"reporters/tap.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , cursor = Base.cursor\r\n  , color = Base.color;\r\n\r\n/**\r\n * Expose `TAP`.\r\n */\r\n\r\nexports = module.exports = TAP;\r\n\r\n/**\r\n * Initialize a new `TAP` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction TAP(runner) {\r\n  Base.call(this, runner);\r\n\r\n  var self = this\r\n    , stats = this.stats\r\n    , n = 1\r\n    , passes = 0\r\n    , failures = 0;\r\n\r\n  runner.on('start', function(){\r\n    var total = runner.grepTotal(runner.suite);\r\n    console.log('%d..%d', 1, total);\r\n  });\r\n\r\n  runner.on('test end', function(){\r\n    ++n;\r\n  });\r\n\r\n  runner.on('pending', function(test){\r\n    console.log('ok %d %s # SKIP -', n, title(test));\r\n  });\r\n\r\n  runner.on('pass', function(test){\r\n    passes++;\r\n    console.log('ok %d %s', n, title(test));\r\n  });\r\n\r\n  runner.on('fail', function(test, err){\r\n    failures++;\r\n    console.log('not ok %d %s', n, title(test));\r\n    if (err.stack) console.log(err.stack.replace(/^/gm, '  '));\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log('# tests ' + (passes + failures));\r\n    console.log('# pass ' + passes);\r\n    console.log('# fail ' + failures);\r\n  });\r\n}\r\n\r\n/**\r\n * Return a TAP-safe title of `test`\r\n *\r\n * @param {Object} test\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction title(test) {\r\n  return test.fullTitle().replace(/#/g, '');\r\n}\r\n\r\n}); // module: reporters/tap.js\r\n\r\nrequire.register(\"reporters/teamcity.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base');\r\n\r\n/**\r\n * Expose `Teamcity`.\r\n */\r\n\r\nexports = module.exports = Teamcity;\r\n\r\n/**\r\n * Initialize a new `Teamcity` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction Teamcity(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats;\r\n\r\n  runner.on('start', function() {\r\n    console.log(\"##teamcity[testSuiteStarted name='mocha.suite']\");\r\n  });\r\n\r\n  runner.on('test', function(test) {\r\n    console.log(\"##teamcity[testStarted name='\" + escape(test.fullTitle()) + \"']\");\r\n  });\r\n\r\n  runner.on('fail', function(test, err) {\r\n    console.log(\"##teamcity[testFailed name='\" + escape(test.fullTitle()) + \"' message='\" + escape(err.message) + \"']\");\r\n  });\r\n\r\n  runner.on('pending', function(test) {\r\n    console.log(\"##teamcity[testIgnored name='\" + escape(test.fullTitle()) + \"' message='pending']\");\r\n  });\r\n\r\n  runner.on('test end', function(test) {\r\n    console.log(\"##teamcity[testFinished name='\" + escape(test.fullTitle()) + \"' duration='\" + test.duration + \"']\");\r\n  });\r\n\r\n  runner.on('end', function() {\r\n    console.log(\"##teamcity[testSuiteFinished name='mocha.suite' duration='\" + stats.duration + \"']\");\r\n  });\r\n}\r\n\r\n/**\r\n * Escape the given `str`.\r\n */\r\n\r\nfunction escape(str) {\r\n  return str\r\n    .replace(/\\|/g, \"||\")\r\n    .replace(/\\n/g, \"|n\")\r\n    .replace(/\\r/g, \"|r\")\r\n    .replace(/\\[/g, \"|[\")\r\n    .replace(/\\]/g, \"|]\")\r\n    .replace(/\\u0085/g, \"|x\")\r\n    .replace(/\\u2028/g, \"|l\")\r\n    .replace(/\\u2029/g, \"|p\")\r\n    .replace(/'/g, \"|'\");\r\n}\r\n\r\n}); // module: reporters/teamcity.js\r\n\r\nrequire.register(\"reporters/xunit.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Base = require('./base')\r\n  , utils = require('../utils')\r\n  , escape = utils.escape;\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Expose `XUnit`.\r\n */\r\n\r\nexports = module.exports = XUnit;\r\n\r\n/**\r\n * Initialize a new `XUnit` reporter.\r\n *\r\n * @param {Runner} runner\r\n * @api public\r\n */\r\n\r\nfunction XUnit(runner) {\r\n  Base.call(this, runner);\r\n  var stats = this.stats\r\n    , tests = []\r\n    , self = this;\r\n\r\n  runner.on('pass', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('fail', function(test){\r\n    tests.push(test);\r\n  });\r\n\r\n  runner.on('end', function(){\r\n    console.log(tag('testsuite', {\r\n        name: 'Mocha Tests'\r\n      , tests: stats.tests\r\n      , failures: stats.failures\r\n      , errors: stats.failures\r\n      , skip: stats.tests - stats.failures - stats.passes\r\n      , timestamp: (new Date).toUTCString()\r\n      , time: stats.duration / 1000\r\n    }, false));\r\n\r\n    tests.forEach(test);\r\n    console.log('</testsuite>');\r\n  });\r\n}\r\n\r\n/**\r\n * Inherit from `Base.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Base.prototype;\r\nXUnit.prototype = new F;\r\nXUnit.prototype.constructor = XUnit;\r\n\r\n\r\n/**\r\n * Output tag for the given `test.`\r\n */\r\n\r\nfunction test(test) {\r\n  var attrs = {\r\n      classname: test.parent.fullTitle()\r\n    , name: test.title\r\n    , time: test.duration / 1000\r\n  };\r\n\r\n  if ('failed' == test.state) {\r\n    var err = test.err;\r\n    attrs.message = escape(err.message);\r\n    console.log(tag('testcase', attrs, false, tag('failure', attrs, false, cdata(err.stack))));\r\n  } else if (test.pending) {\r\n    console.log(tag('testcase', attrs, false, tag('skipped', {}, true)));\r\n  } else {\r\n    console.log(tag('testcase', attrs, true) );\r\n  }\r\n}\r\n\r\n/**\r\n * HTML tag helper.\r\n */\r\n\r\nfunction tag(name, attrs, close, content) {\r\n  var end = close ? '/>' : '>'\r\n    , pairs = []\r\n    , tag;\r\n\r\n  for (var key in attrs) {\r\n    pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\r\n  }\r\n\r\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\r\n  if (content) tag += content + '</' + name + end;\r\n  return tag;\r\n}\r\n\r\n/**\r\n * Return cdata escaped CDATA `str`.\r\n */\r\n\r\nfunction cdata(str) {\r\n  return '<![CDATA[' + escape(str) + ']]>';\r\n}\r\n\r\n}); // module: reporters/xunit.js\r\n\r\nrequire.register(\"runnable.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runnable')\r\n  , milliseconds = require('./ms');\r\n\r\n/**\r\n * Save timer references to avoid Sinon interfering (see GH-237).\r\n */\r\n\r\nvar Date = global.Date\r\n  , setTimeout = global.setTimeout\r\n  , setInterval = global.setInterval\r\n  , clearTimeout = global.clearTimeout\r\n  , clearInterval = global.clearInterval;\r\n\r\n/**\r\n * Object#toString().\r\n */\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\n/**\r\n * Expose `Runnable`.\r\n */\r\n\r\nmodule.exports = Runnable;\r\n\r\n/**\r\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Runnable(title, fn) {\r\n  this.title = title;\r\n  this.fn = fn;\r\n  this.async = fn && fn.length;\r\n  this.sync = ! this.async;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this.timedOut = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nRunnable.prototype = new F;\r\nRunnable.prototype.constructor = Runnable;\r\n\r\n\r\n/**\r\n * Set & get timeout `ms`.\r\n *\r\n * @param {Number|String} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._timeout = ms;\r\n  if (this.timer) this.resetTimeout();\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set & get slow `ms`.\r\n *\r\n * @param {Number|String} ms\r\n * @return {Runnable|Number} ms or self\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nRunnable.prototype.fullTitle = function(){\r\n  return this.parent.fullTitle() + ' ' + this.title;\r\n};\r\n\r\n/**\r\n * Clear the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.clearTimeout = function(){\r\n  clearTimeout(this.timer);\r\n};\r\n\r\n/**\r\n * Inspect the runnable void of private properties.\r\n *\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.inspect = function(){\r\n  return JSON.stringify(this, function(key, val){\r\n    if ('_' == key[0]) return;\r\n    if ('parent' == key) return '#<Suite>';\r\n    if ('ctx' == key) return '#<Context>';\r\n    return val;\r\n  }, 2);\r\n};\r\n\r\n/**\r\n * Reset the timeout.\r\n *\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.resetTimeout = function(){\r\n  var self = this\r\n    , ms = this.timeout();\r\n\r\n  this.clearTimeout();\r\n  if (ms) {\r\n    this.timer = setTimeout(function(){\r\n      self.callback(new Error('timeout of ' + ms + 'ms exceeded'));\r\n      self.timedOut = true;\r\n    }, ms);\r\n  }\r\n};\r\n\r\n/**\r\n * Run the test and invoke `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunnable.prototype.run = function(fn){\r\n  var self = this\r\n    , ms = this.timeout()\r\n    , start = new Date\r\n    , ctx = this.ctx\r\n    , finished\r\n    , emitted;\r\n\r\n  if (ctx) ctx.runnable(this);\r\n\r\n  // timeout\r\n  if (this.async) {\r\n    if (ms) {\r\n      this.timer = setTimeout(function(){\r\n        done(new Error('timeout of ' + ms + 'ms exceeded'));\r\n        self.timedOut = true;\r\n      }, ms);\r\n    }\r\n  }\r\n\r\n  // called multiple times\r\n  function multiple(err) {\r\n    if (emitted) return;\r\n    emitted = true;\r\n    self.emit('error', err || new Error('done() called multiple times'));\r\n  }\r\n\r\n  // finished\r\n  function done(err) {\r\n    if (self.timedOut) return;\r\n    if (finished) return multiple(err);\r\n    self.clearTimeout();\r\n    self.duration = new Date - start;\r\n    finished = true;\r\n    fn(err);\r\n  }\r\n\r\n  // for .resetTimeout()\r\n  this.callback = done;\r\n\r\n  // async\r\n  if (this.async) {\r\n    try {\r\n      this.fn.call(ctx, function(err){\r\n        if (err instanceof Error || toString.call(err) === \"[object Error]\") return done(err);\r\n        if (null != err) return done(new Error('done() invoked with non-Error: ' + err));\r\n        done();\r\n      });\r\n    } catch (err) {\r\n      done(err);\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (this.asyncOnly) {\r\n    return done(new Error('--async-only option in use without declaring `done()`'));\r\n  }\r\n\r\n  // sync\r\n  try {\r\n    if (!this.pending) this.fn.call(ctx);\r\n    this.duration = new Date - start;\r\n    fn();\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n}); // module: runnable.js\r\n\r\nrequire.register(\"runner.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:runner')\r\n  , Test = require('./test')\r\n  , utils = require('./utils')\r\n  , filter = utils.filter\r\n  , keys = utils.keys\r\n  , noop = function(){}\r\n  , immediately = global.setImmediate || process.nextTick;\r\n\r\n/**\r\n * Non-enumerable globals.\r\n */\r\n\r\nvar globals = [\r\n  'setTimeout',\r\n  'clearTimeout',\r\n  'setInterval',\r\n  'clearInterval',\r\n  'XMLHttpRequest',\r\n  'Date'\r\n];\r\n\r\n/**\r\n * Expose `Runner`.\r\n */\r\n\r\nmodule.exports = Runner;\r\n\r\n/**\r\n * Initialize a `Runner` for the given `suite`.\r\n *\r\n * Events:\r\n *\r\n *   - `start`  execution started\r\n *   - `end`  execution complete\r\n *   - `suite`  (suite) test suite execution started\r\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\r\n *   - `test`  (test) test execution started\r\n *   - `test end`  (test) test completed\r\n *   - `hook`  (hook) hook execution started\r\n *   - `hook end`  (hook) hook complete\r\n *   - `pass`  (test) test passed\r\n *   - `fail`  (test, err) test failed\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Runner(suite) {\r\n  var self = this;\r\n  this._globals = [];\r\n  this.suite = suite;\r\n  this.total = suite.total();\r\n  this.failures = 0;\r\n  this.on('test end', function(test){ self.checkGlobals(test); });\r\n  this.on('hook end', function(hook){ self.checkGlobals(hook); });\r\n  this.grep(/.*/);\r\n  this.globals(this.globalProps().concat(['errno']));\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nRunner.prototype = new F;\r\nRunner.prototype.constructor = Runner;\r\n\r\n\r\n/**\r\n * Run tests with full titles matching `re`. Updates runner.total\r\n * with number of tests matched.\r\n *\r\n * @param {RegExp} re\r\n * @param {Boolean} invert\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grep = function(re, invert){\r\n  debug('grep %s', re);\r\n  this._grep = re;\r\n  this._invert = invert;\r\n  this.total = this.grepTotal(this.suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the number of tests matching the grep search for the\r\n * given suite.\r\n *\r\n * @param {Suite} suite\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nRunner.prototype.grepTotal = function(suite) {\r\n  var self = this;\r\n  var total = 0;\r\n\r\n  suite.eachTest(function(test){\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (match) total++;\r\n  });\r\n\r\n  return total;\r\n};\r\n\r\n/**\r\n * Return a list of global properties.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nRunner.prototype.globalProps = function() {\r\n  var props = utils.keys(global);\r\n\r\n  // non-enumerables\r\n  for (var i = 0; i < globals.length; ++i) {\r\n    if (~utils.indexOf(props, globals[i])) continue;\r\n    props.push(globals[i]);\r\n  }\r\n\r\n  return props;\r\n};\r\n\r\n/**\r\n * Allow the given `arr` of globals.\r\n *\r\n * @param {Array} arr\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.globals = function(arr){\r\n  if (0 == arguments.length) return this._globals;\r\n  debug('globals %j', arr);\r\n  utils.forEach(arr, function(arr){\r\n    this._globals.push(arr);\r\n  }, this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Check for global variable leaks.\r\n *\r\n * @api private\r\n */\r\n\r\nRunner.prototype.checkGlobals = function(test){\r\n  if (this.ignoreLeaks) return;\r\n  var ok = this._globals;\r\n  var globals = this.globalProps();\r\n  var isNode = process.kill;\r\n  var leaks;\r\n\r\n  // check length - 2 ('errno' and 'location' globals)\r\n  if (isNode && 1 == ok.length - globals.length) return\r\n  else if (2 == ok.length - globals.length) return;\r\n\r\n  leaks = filterLeaks(ok, globals);\r\n  this._globals = this._globals.concat(leaks);\r\n\r\n  if (leaks.length > 1) {\r\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\r\n  } else if (leaks.length) {\r\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\r\n  }\r\n};\r\n\r\n/**\r\n * Fail the given `test`.\r\n *\r\n * @param {Test} test\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.fail = function(test, err){\r\n  ++this.failures;\r\n  test.state = 'failed';\r\n\r\n  if ('string' == typeof err) {\r\n    err = new Error('the string \"' + err + '\" was thrown, throw an Error :)');\r\n  }\r\n\r\n  this.emit('fail', test, err);\r\n};\r\n\r\n/**\r\n * Fail the given `hook` with `err`.\r\n *\r\n * Hook failures (currently) hard-end due\r\n * to that fact that a failing hook will\r\n * surely cause subsequent tests to fail,\r\n * causing jumbled reporting.\r\n *\r\n * @param {Hook} hook\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.failHook = function(hook, err){\r\n  this.fail(hook, err);\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run hook `name` callbacks and then invoke `fn()`.\r\n *\r\n * @param {String} name\r\n * @param {Function} function\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hook = function(name, fn){\r\n  var suite = this.suite\r\n    , hooks = suite['_' + name]\r\n    , self = this\r\n    , timer;\r\n\r\n  function next(i) {\r\n    var hook = hooks[i];\r\n    if (!hook) return fn();\r\n    self.currentRunnable = hook;\r\n\r\n    self.emit('hook', hook);\r\n\r\n    hook.on('error', function(err){\r\n      self.failHook(hook, err);\r\n    });\r\n\r\n    hook.run(function(err){\r\n      hook.removeAllListeners('error');\r\n      var testError = hook.error();\r\n      if (testError) self.fail(self.test, testError);\r\n      if (err) return self.failHook(hook, err);\r\n      self.emit('hook end', hook);\r\n      next(++i);\r\n    });\r\n  }\r\n\r\n  immediately(function(){\r\n    next(0);\r\n  });\r\n};\r\n\r\n/**\r\n * Run hook `name` for the given array of `suites`\r\n * in order, and callback `fn(err)`.\r\n *\r\n * @param {String} name\r\n * @param {Array} suites\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hooks = function(name, suites, fn){\r\n  var self = this\r\n    , orig = this.suite;\r\n\r\n  function next(suite) {\r\n    self.suite = suite;\r\n\r\n    if (!suite) {\r\n      self.suite = orig;\r\n      return fn();\r\n    }\r\n\r\n    self.hook(name, function(err){\r\n      if (err) {\r\n        self.suite = orig;\r\n        return fn(err);\r\n      }\r\n\r\n      next(suites.pop());\r\n    });\r\n  }\r\n\r\n  next(suites.pop());\r\n};\r\n\r\n/**\r\n * Run hooks from the top level down.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookUp = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents()).reverse();\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Run hooks from the bottom up.\r\n *\r\n * @param {String} name\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.hookDown = function(name, fn){\r\n  var suites = [this.suite].concat(this.parents());\r\n  this.hooks(name, suites, fn);\r\n};\r\n\r\n/**\r\n * Return an array of parent Suites from\r\n * closest to furthest.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nRunner.prototype.parents = function(){\r\n  var suite = this.suite\r\n    , suites = [];\r\n  while (suite = suite.parent) suites.push(suite);\r\n  return suites;\r\n};\r\n\r\n/**\r\n * Run the current test and callback `fn(err)`.\r\n *\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTest = function(fn){\r\n  var test = this.test\r\n    , self = this;\r\n\r\n  if (this.asyncOnly) test.asyncOnly = true;\r\n\r\n  try {\r\n    test.on('error', function(err){\r\n      self.fail(test, err);\r\n    });\r\n    test.run(fn);\r\n  } catch (err) {\r\n    fn(err);\r\n  }\r\n};\r\n\r\n/**\r\n * Run tests in the given `suite` and invoke\r\n * the callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runTests = function(suite, fn){\r\n  var self = this\r\n    , tests = suite.tests.slice()\r\n    , test;\r\n\r\n  function next(err) {\r\n    // if we bail after first err\r\n    if (self.failures && suite._bail) return fn();\r\n\r\n    // next test\r\n    test = tests.shift();\r\n\r\n    // all done\r\n    if (!test) return fn();\r\n\r\n    // grep\r\n    var match = self._grep.test(test.fullTitle());\r\n    if (self._invert) match = !match;\r\n    if (!match) return next();\r\n\r\n    // pending\r\n    if (test.pending) {\r\n      self.emit('pending', test);\r\n      self.emit('test end', test);\r\n      return next();\r\n    }\r\n\r\n    // execute test and hook(s)\r\n    self.emit('test', self.test = test);\r\n    self.hookDown('beforeEach', function(){\r\n      self.currentRunnable = self.test;\r\n      self.runTest(function(err){\r\n        test = self.test;\r\n\r\n        if (err) {\r\n          self.fail(test, err);\r\n          self.emit('test end', test);\r\n          return self.hookUp('afterEach', next);\r\n        }\r\n\r\n        test.state = 'passed';\r\n        self.emit('pass', test);\r\n        self.emit('test end', test);\r\n        self.hookUp('afterEach', next);\r\n      });\r\n    });\r\n  }\r\n\r\n  this.next = next;\r\n  next();\r\n};\r\n\r\n/**\r\n * Run the given `suite` and invoke the\r\n * callback `fn()` when complete.\r\n *\r\n * @param {Suite} suite\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nRunner.prototype.runSuite = function(suite, fn){\r\n  var total = this.grepTotal(suite)\r\n    , self = this\r\n    , i = 0;\r\n\r\n  debug('run suite %s', suite.fullTitle());\r\n\r\n  if (!total) return fn();\r\n\r\n  this.emit('suite', this.suite = suite);\r\n\r\n  function next() {\r\n    var curr = suite.suites[i++];\r\n    if (!curr) return done();\r\n    self.runSuite(curr, next);\r\n  }\r\n\r\n  function done() {\r\n    self.suite = suite;\r\n    self.hook('afterAll', function(){\r\n      self.emit('suite end', suite);\r\n      fn();\r\n    });\r\n  }\r\n\r\n  this.hook('beforeAll', function(){\r\n    self.runTests(suite, next);\r\n  });\r\n};\r\n\r\n/**\r\n * Handle uncaught exceptions.\r\n *\r\n * @param {Error} err\r\n * @api private\r\n */\r\n\r\nRunner.prototype.uncaught = function(err){\r\n  debug('uncaught exception %s', err.message);\r\n  var runnable = this.currentRunnable;\r\n  if (!runnable || 'failed' == runnable.state) return;\r\n  runnable.clearTimeout();\r\n  err.uncaught = true;\r\n  this.fail(runnable, err);\r\n\r\n  // recover from test\r\n  if ('test' == runnable.type) {\r\n    this.emit('test end', runnable);\r\n    this.hookUp('afterEach', this.next);\r\n    return;\r\n  }\r\n\r\n  // bail on hooks\r\n  this.emit('end');\r\n};\r\n\r\n/**\r\n * Run the root suite and invoke `fn(failures)`\r\n * on completion.\r\n *\r\n * @param {Function} fn\r\n * @return {Runner} for chaining\r\n * @api public\r\n */\r\n\r\nRunner.prototype.run = function(fn){\r\n  var self = this\r\n    , fn = fn || function(){};\r\n\r\n  function uncaught(err){\r\n    self.uncaught(err);\r\n  }\r\n\r\n  debug('start');\r\n\r\n  // callback\r\n  this.on('end', function(){\r\n    debug('end');\r\n    process.removeListener('uncaughtException', uncaught);\r\n    fn(self.failures);\r\n  });\r\n\r\n  // run suites\r\n  this.emit('start');\r\n  this.runSuite(this.suite, function(){\r\n    debug('finished running');\r\n    self.emit('end');\r\n  });\r\n\r\n  // uncaught exception\r\n  process.on('uncaughtException', uncaught);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Filter leaks with the given globals flagged as `ok`.\r\n *\r\n * @param {Array} ok\r\n * @param {Array} globals\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nfunction filterLeaks(ok, globals) {\r\n  return filter(globals, function(key){\r\n    var matched = filter(ok, function(ok){\r\n      if (~ok.indexOf('*')) return 0 == key.indexOf(ok.split('*')[0]);\r\n      // Opera and IE expose global variables for HTML element IDs (issue #243)\r\n      if (/^mocha-/.test(key)) return true;\r\n      return key == ok;\r\n    });\r\n    return matched.length == 0 && (!global.navigator || 'onerror' !== key);\r\n  });\r\n}\r\n\r\n}); // module: runner.js\r\n\r\nrequire.register(\"suite.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar EventEmitter = require('browser/events').EventEmitter\r\n  , debug = require('browser/debug')('mocha:suite')\r\n  , milliseconds = require('./ms')\r\n  , utils = require('./utils')\r\n  , Hook = require('./hook');\r\n\r\n/**\r\n * Expose `Suite`.\r\n */\r\n\r\nexports = module.exports = Suite;\r\n\r\n/**\r\n * Create a new `Suite` with the given `title`\r\n * and parent `Suite`. When a suite with the\r\n * same title is already present, that suite\r\n * is returned to provide nicer reporter\r\n * and more flexible meta-testing.\r\n *\r\n * @param {Suite} parent\r\n * @param {String} title\r\n * @return {Suite}\r\n * @api public\r\n */\r\n\r\nexports.create = function(parent, title){\r\n  var suite = new Suite(title, parent.ctx);\r\n  suite.parent = parent;\r\n  if (parent.pending) suite.pending = true;\r\n  title = suite.fullTitle();\r\n  parent.addSuite(suite);\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Initialize a new `Suite` with the given\r\n * `title` and `ctx`.\r\n *\r\n * @param {String} title\r\n * @param {Context} ctx\r\n * @api private\r\n */\r\n\r\nfunction Suite(title, ctx) {\r\n  this.title = title;\r\n  this.ctx = ctx;\r\n  this.suites = [];\r\n  this.tests = [];\r\n  this.pending = false;\r\n  this._beforeEach = [];\r\n  this._beforeAll = [];\r\n  this._afterEach = [];\r\n  this._afterAll = [];\r\n  this.root = !title;\r\n  this._timeout = 2000;\r\n  this._slow = 75;\r\n  this._bail = false;\r\n}\r\n\r\n/**\r\n * Inherit from `EventEmitter.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = EventEmitter.prototype;\r\nSuite.prototype = new F;\r\nSuite.prototype.constructor = Suite;\r\n\r\n\r\n/**\r\n * Return a clone of this `Suite`.\r\n *\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.clone = function(){\r\n  var suite = new Suite(this.title);\r\n  debug('clone');\r\n  suite.ctx = this.ctx;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  return suite;\r\n};\r\n\r\n/**\r\n * Set timeout `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.timeout = function(ms){\r\n  if (0 == arguments.length) return this._timeout;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('timeout %d', ms);\r\n  this._timeout = parseInt(ms, 10);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set slow `ms` or short-hand such as \"2s\".\r\n *\r\n * @param {Number|String} ms\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.slow = function(ms){\r\n  if (0 === arguments.length) return this._slow;\r\n  if ('string' == typeof ms) ms = milliseconds(ms);\r\n  debug('slow %d', ms);\r\n  this._slow = ms;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets whether to bail after first error.\r\n *\r\n * @parma {Boolean} bail\r\n * @return {Suite|Number} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.bail = function(bail){\r\n  if (0 == arguments.length) return this._bail;\r\n  debug('bail %s', bail);\r\n  this._bail = bail;\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeAll.push(hook);\r\n  this.emit('beforeAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after running tests.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterAll = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after all\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterAll.push(hook);\r\n  this.emit('afterAll', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` before each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.beforeEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"before each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._beforeEach.push(hook);\r\n  this.emit('beforeEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Run `fn(test[, done])` after each test case.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.afterEach = function(fn){\r\n  if (this.pending) return this;\r\n  var hook = new Hook('\"after each\" hook', fn);\r\n  hook.parent = this;\r\n  hook.timeout(this.timeout());\r\n  hook.slow(this.slow());\r\n  hook.ctx = this.ctx;\r\n  this._afterEach.push(hook);\r\n  this.emit('afterEach', hook);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a test `suite`.\r\n *\r\n * @param {Suite} suite\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addSuite = function(suite){\r\n  suite.parent = this;\r\n  suite.timeout(this.timeout());\r\n  suite.slow(this.slow());\r\n  suite.bail(this.bail());\r\n  this.suites.push(suite);\r\n  this.emit('suite', suite);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a `test` to this suite.\r\n *\r\n * @param {Test} test\r\n * @return {Suite} for chaining\r\n * @api private\r\n */\r\n\r\nSuite.prototype.addTest = function(test){\r\n  test.parent = this;\r\n  test.timeout(this.timeout());\r\n  test.slow(this.slow());\r\n  test.ctx = this.ctx;\r\n  this.tests.push(test);\r\n  this.emit('test', test);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return the full title generated by recursively\r\n * concatenating the parent's full title.\r\n *\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.fullTitle = function(){\r\n  if (this.parent) {\r\n    var full = this.parent.fullTitle();\r\n    if (full) return full + ' ' + this.title;\r\n  }\r\n  return this.title;\r\n};\r\n\r\n/**\r\n * Return the total number of tests.\r\n *\r\n * @return {Number}\r\n * @api public\r\n */\r\n\r\nSuite.prototype.total = function(){\r\n  return utils.reduce(this.suites, function(sum, suite){\r\n    return sum + suite.total();\r\n  }, 0) + this.tests.length;\r\n};\r\n\r\n/**\r\n * Iterates through each suite recursively to find\r\n * all tests. Applies a function in the format\r\n * `fn(test)`.\r\n *\r\n * @param {Function} fn\r\n * @return {Suite}\r\n * @api private\r\n */\r\n\r\nSuite.prototype.eachTest = function(fn){\r\n  utils.forEach(this.tests, fn);\r\n  utils.forEach(this.suites, function(suite){\r\n    suite.eachTest(fn);\r\n  });\r\n  return this;\r\n};\r\n\r\n}); // module: suite.js\r\n\r\nrequire.register(\"test.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar Runnable = require('./runnable');\r\n\r\n/**\r\n * Expose `Test`.\r\n */\r\n\r\nmodule.exports = Test;\r\n\r\n/**\r\n * Initialize a new `Test` with the given `title` and callback `fn`.\r\n *\r\n * @param {String} title\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nfunction Test(title, fn) {\r\n  Runnable.call(this, title, fn);\r\n  this.pending = !fn;\r\n  this.type = 'test';\r\n}\r\n\r\n/**\r\n * Inherit from `Runnable.prototype`.\r\n */\r\n\r\nfunction F(){};\r\nF.prototype = Runnable.prototype;\r\nTest.prototype = new F;\r\nTest.prototype.constructor = Test;\r\n\r\n\r\n}); // module: test.js\r\n\r\nrequire.register(\"utils.js\", function(module, exports, require){\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar fs = require('browser/fs')\r\n  , path = require('browser/path')\r\n  , join = path.join\r\n  , debug = require('browser/debug')('mocha:watch');\r\n\r\n/**\r\n * Ignored directories.\r\n */\r\n\r\nvar ignore = ['node_modules', '.git'];\r\n\r\n/**\r\n * Escape special characters in the given string of html.\r\n *\r\n * @param  {String} html\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escape = function(html){\r\n  return String(html)\r\n    .replace(/&/g, '&amp;')\r\n    .replace(/\"/g, '&quot;')\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;');\r\n};\r\n\r\n/**\r\n * Array#forEach (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} scope\r\n * @api private\r\n */\r\n\r\nexports.forEach = function(arr, fn, scope){\r\n  for (var i = 0, l = arr.length; i < l; i++)\r\n    fn.call(scope, arr[i], i);\r\n};\r\n\r\n/**\r\n * Array#indexOf (<=IE8)\r\n *\r\n * @parma {Array} arr\r\n * @param {Object} obj to find index of\r\n * @param {Number} start\r\n * @api private\r\n */\r\n\r\nexports.indexOf = function(arr, obj, start){\r\n  for (var i = start || 0, l = arr.length; i < l; i++) {\r\n    if (arr[i] === obj)\r\n      return i;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Array#reduce (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @param {Object} initial value\r\n * @api private\r\n */\r\n\r\nexports.reduce = function(arr, fn, val){\r\n  var rval = val;\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    rval = fn(rval, arr[i], i, arr);\r\n  }\r\n\r\n  return rval;\r\n};\r\n\r\n/**\r\n * Array#filter (<=IE8)\r\n *\r\n * @param {Array} array\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.filter = function(arr, fn){\r\n  var ret = [];\r\n\r\n  for (var i = 0, l = arr.length; i < l; i++) {\r\n    var val = arr[i];\r\n    if (fn(val, i, arr)) ret.push(val);\r\n  }\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Object.keys (<=IE8)\r\n *\r\n * @param {Object} obj\r\n * @return {Array} keys\r\n * @api private\r\n */\r\n\r\nexports.keys = Object.keys || function(obj) {\r\n  var keys = []\r\n    , has = Object.prototype.hasOwnProperty // for `window` on <=IE8\r\n\r\n  for (var key in obj) {\r\n    if (has.call(obj, key)) {\r\n      keys.push(key);\r\n    }\r\n  }\r\n\r\n  return keys;\r\n};\r\n\r\n/**\r\n * Watch the given `files` for changes\r\n * and invoke `fn(file)` on modification.\r\n *\r\n * @param {Array} files\r\n * @param {Function} fn\r\n * @api private\r\n */\r\n\r\nexports.watch = function(files, fn){\r\n  var options = { interval: 100 };\r\n  files.forEach(function(file){\r\n    debug('file %s', file);\r\n    fs.watchFile(file, options, function(curr, prev){\r\n      if (prev.mtime < curr.mtime) fn(file);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Ignored files.\r\n */\r\n\r\nfunction ignored(path){\r\n  return !~ignore.indexOf(path);\r\n}\r\n\r\n/**\r\n * Lookup files in the given `dir`.\r\n *\r\n * @return {Array}\r\n * @api private\r\n */\r\n\r\nexports.files = function(dir, ret){\r\n  ret = ret || [];\r\n\r\n  fs.readdirSync(dir)\r\n  .filter(ignored)\r\n  .forEach(function(path){\r\n    path = join(dir, path);\r\n    if (fs.statSync(path).isDirectory()) {\r\n      exports.files(path, ret);\r\n    } else if (path.match(/\\.(js|coffee)$/)) {\r\n      ret.push(path);\r\n    }\r\n  });\r\n\r\n  return ret;\r\n};\r\n\r\n/**\r\n * Compute a slug from the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.slug = function(str){\r\n  return str\r\n    .toLowerCase()\r\n    .replace(/ +/g, '-')\r\n    .replace(/[^-\\w]/g, '');\r\n};\r\n\r\n/**\r\n * Strip the function definition from `str`,\r\n * and re-indent for pre whitespace.\r\n */\r\n\r\nexports.clean = function(str) {\r\n  str = str\r\n    .replace(/^function *\\(.*\\) *{/, '')\r\n    .replace(/\\s+\\}$/, '');\r\n\r\n  var spaces = str.match(/^\\n?( *)/)[1].length\r\n    , re = new RegExp('^ {' + spaces + '}', 'gm');\r\n\r\n  str = str.replace(re, '');\r\n\r\n  return exports.trim(str);\r\n};\r\n\r\n/**\r\n * Escape regular expression characters in `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.escapeRegexp = function(str){\r\n  return str.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\r\n};\r\n\r\n/**\r\n * Trim the given `str`.\r\n *\r\n * @param {String} str\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nexports.trim = function(str){\r\n  return str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Parse the given `qs`.\r\n *\r\n * @param {String} qs\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nexports.parseQuery = function(qs){\r\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair){\r\n    var i = pair.indexOf('=')\r\n      , key = pair.slice(0, i)\r\n      , val = pair.slice(++i);\r\n\r\n    obj[key] = decodeURIComponent(val);\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Highlight the given string of `js`.\r\n *\r\n * @param {String} js\r\n * @return {String}\r\n * @api private\r\n */\r\n\r\nfunction highlight(js) {\r\n  return js\r\n    .replace(/</g, '&lt;')\r\n    .replace(/>/g, '&gt;')\r\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\r\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\r\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\r\n    .replace(/\\bnew *(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\r\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>')\r\n}\r\n\r\n/**\r\n * Highlight the contents of tag `name`.\r\n *\r\n * @param {String} name\r\n * @api private\r\n */\r\n\r\nexports.highlightTags = function(name) {\r\n  var code = document.getElementsByTagName(name);\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    code[i].innerHTML = highlight(code[i].innerHTML);\r\n  }\r\n};\r\n\r\n}); // module: utils.js\r\n/**\r\n * Node shims.\r\n *\r\n * These are meant only to allow\r\n * mocha.js to run untouched, not\r\n * to allow running node code in\r\n * the browser.\r\n */\r\n\r\nprocess = {};\r\nprocess.exit = function(status){};\r\nprocess.stdout = {};\r\nglobal = window;\r\n\r\n/**\r\n * next tick implementation.\r\n */\r\n\r\nprocess.nextTick = (function(){\r\n  // postMessage behaves badly on IE8\r\n  if (window.ActiveXObject || !window.postMessage) {\r\n    return function(fn){ fn() };\r\n  }\r\n\r\n  // based on setZeroTimeout by David Baron\r\n  // - http://dbaron.org/log/20100309-faster-timeouts\r\n  var timeouts = []\r\n    , name = 'mocha-zero-timeout'\r\n\r\n  window.addEventListener('message', function(e){\r\n    if (e.source == window && e.data == name) {\r\n      if (e.stopPropagation) e.stopPropagation();\r\n      if (timeouts.length) timeouts.shift()();\r\n    }\r\n  }, true);\r\n\r\n  return function(fn){\r\n    timeouts.push(fn);\r\n    window.postMessage(name, '*');\r\n  }\r\n})();\r\n\r\n/**\r\n * Remove uncaughtException listener.\r\n */\r\n\r\nprocess.removeListener = function(e){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = null;\r\n  }\r\n};\r\n\r\n/**\r\n * Implements uncaughtException listener.\r\n */\r\n\r\nprocess.on = function(e, fn){\r\n  if ('uncaughtException' == e) {\r\n    window.onerror = function(err, url, line){\r\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\r\n    };\r\n  }\r\n};\r\n\r\n// boot\r\n;(function(){\r\n\r\n  /**\r\n   * Expose mocha.\r\n   */\r\n\r\n  var Mocha = window.Mocha = require('mocha'),\r\n      mocha = window.mocha = new Mocha({ reporter: 'html' });\r\n\r\n  /**\r\n   * Override ui to ensure that the ui functions are initialized.\r\n   * Normally this would happen in Mocha.prototype.loadFiles.\r\n   */\r\n\r\n  mocha.ui = function(ui){\r\n    Mocha.prototype.ui.call(this, ui);\r\n    this.suite.emit('pre-require', window, null, this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Setup mocha with the given setting options.\r\n   */\r\n\r\n  mocha.setup = function(opts){\r\n    if ('string' == typeof opts) opts = { ui: opts };\r\n    for (var opt in opts) this[opt](opts[opt]);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Run mocha, returning the Runner.\r\n   */\r\n\r\n  mocha.run = function(fn){\r\n    var options = mocha.options;\r\n    mocha.globals('location');\r\n\r\n    var query = Mocha.utils.parseQuery(window.location.search || '');\r\n    if (query.grep) mocha.grep(query.grep);\r\n    if (query.invert) mocha.invert();\r\n\r\n    return Mocha.prototype.run.call(mocha, function(){\r\n      Mocha.utils.highlightTags('code');\r\n      if (fn) fn();\r\n    });\r\n  };\r\n})();\r\n})();\r\n","/**\r\n * Sinon.JS 1.6.0, 2013/02/18\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS\r\n *\r\n * (The BSD License)\r\n *\r\n * Copyright (c) 2010-2013, Christian Johansen, christian@cjohansen.no\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright notice,\r\n *       this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright notice,\r\n *       this list of conditions and the following disclaimer in the documentation\r\n *       and/or other materials provided with the distribution.\r\n *     * Neither the name of Christian Johansen nor the names of his contributors\r\n *       may be used to endorse or promote products derived from this software\r\n *       without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar sinon = (function () {\r\n\"use strict\";\r\n\r\nvar buster = (function (setTimeout, B) {\r\n    var isNode = typeof require == \"function\" && typeof module == \"object\";\r\n    var div = typeof document != \"undefined\" && document.createElement(\"div\");\r\n    var F = function () {};\r\n\r\n    var buster = {\r\n        bind: function bind(obj, methOrProp) {\r\n            var method = typeof methOrProp == \"string\" ? obj[methOrProp] : methOrProp;\r\n            var args = Array.prototype.slice.call(arguments, 2);\r\n            return function () {\r\n                var allArgs = args.concat(Array.prototype.slice.call(arguments));\r\n                return method.apply(obj, allArgs);\r\n            };\r\n        },\r\n\r\n        partial: function partial(fn) {\r\n            var args = [].slice.call(arguments, 1);\r\n            return function () {\r\n                return fn.apply(this, args.concat([].slice.call(arguments)));\r\n            };\r\n        },\r\n\r\n        create: function create(object) {\r\n            F.prototype = object;\r\n            return new F();\r\n        },\r\n\r\n        extend: function extend(target) {\r\n            if (!target) { return; }\r\n            for (var i = 1, l = arguments.length, prop; i < l; ++i) {\r\n                for (prop in arguments[i]) {\r\n                    target[prop] = arguments[i][prop];\r\n                }\r\n            }\r\n            return target;\r\n        },\r\n\r\n        nextTick: function nextTick(callback) {\r\n            if (typeof process != \"undefined\" && process.nextTick) {\r\n                return process.nextTick(callback);\r\n            }\r\n            setTimeout(callback, 0);\r\n        },\r\n\r\n        functionName: function functionName(func) {\r\n            if (!func) return \"\";\r\n            if (func.displayName) return func.displayName;\r\n            if (func.name) return func.name;\r\n            var matches = func.toString().match(/function\\s+([^\\(]+)/m);\r\n            return matches && matches[1] || \"\";\r\n        },\r\n\r\n        isNode: function isNode(obj) {\r\n            if (!div) return false;\r\n            try {\r\n                obj.appendChild(div);\r\n                obj.removeChild(div);\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n            return true;\r\n        },\r\n\r\n        isElement: function isElement(obj) {\r\n            return obj && obj.nodeType === 1 && buster.isNode(obj);\r\n        },\r\n\r\n        isArray: function isArray(arr) {\r\n            return Object.prototype.toString.call(arr) == \"[object Array]\";\r\n        },\r\n\r\n        flatten: function flatten(arr) {\r\n            var result = [], arr = arr || [];\r\n            for (var i = 0, l = arr.length; i < l; ++i) {\r\n                result = result.concat(buster.isArray(arr[i]) ? flatten(arr[i]) : arr[i]);\r\n            }\r\n            return result;\r\n        },\r\n\r\n        each: function each(arr, callback) {\r\n            for (var i = 0, l = arr.length; i < l; ++i) {\r\n                callback(arr[i]);\r\n            }\r\n        },\r\n\r\n        map: function map(arr, callback) {\r\n            var results = [];\r\n            for (var i = 0, l = arr.length; i < l; ++i) {\r\n                results.push(callback(arr[i]));\r\n            }\r\n            return results;\r\n        },\r\n\r\n        parallel: function parallel(fns, callback) {\r\n            function cb(err, res) {\r\n                if (typeof callback == \"function\") {\r\n                    callback(err, res);\r\n                    callback = null;\r\n                }\r\n            }\r\n            if (fns.length == 0) { return cb(null, []); }\r\n            var remaining = fns.length, results = [];\r\n            function makeDone(num) {\r\n                return function done(err, result) {\r\n                    if (err) { return cb(err); }\r\n                    results[num] = result;\r\n                    if (--remaining == 0) { cb(null, results); }\r\n                };\r\n            }\r\n            for (var i = 0, l = fns.length; i < l; ++i) {\r\n                fns[i](makeDone(i));\r\n            }\r\n        },\r\n\r\n        series: function series(fns, callback) {\r\n            function cb(err, res) {\r\n                if (typeof callback == \"function\") {\r\n                    callback(err, res);\r\n                }\r\n            }\r\n            var remaining = fns.slice();\r\n            var results = [];\r\n            function callNext() {\r\n                if (remaining.length == 0) return cb(null, results);\r\n                var promise = remaining.shift()(next);\r\n                if (promise && typeof promise.then == \"function\") {\r\n                    promise.then(buster.partial(next, null), next);\r\n                }\r\n            }\r\n            function next(err, result) {\r\n                if (err) return cb(err);\r\n                results.push(result);\r\n                callNext();\r\n            }\r\n            callNext();\r\n        },\r\n\r\n        countdown: function countdown(num, done) {\r\n            return function () {\r\n                if (--num == 0) done();\r\n            };\r\n        }\r\n    };\r\n\r\n    if (typeof process === \"object\" &&\r\n        typeof require === \"function\" && typeof module === \"object\") {\r\n        var crypto = require(\"crypto\");\r\n        var path = require(\"path\");\r\n\r\n        buster.tmpFile = function (fileName) {\r\n            var hashed = crypto.createHash(\"sha1\");\r\n            hashed.update(fileName);\r\n            var tmpfileName = hashed.digest(\"hex\");\r\n\r\n            if (process.platform == \"win32\") {\r\n                return path.join(process.env[\"TEMP\"], tmpfileName);\r\n            } else {\r\n                return path.join(\"/tmp\", tmpfileName);\r\n            }\r\n        };\r\n    }\r\n\r\n    if (Array.prototype.some) {\r\n        buster.some = function (arr, fn, thisp) {\r\n            return arr.some(fn, thisp);\r\n        };\r\n    } else {\r\n        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some\r\n        buster.some = function (arr, fun, thisp) {\r\n                        if (arr == null) { throw new TypeError(); }\r\n            arr = Object(arr);\r\n            var len = arr.length >>> 0;\r\n            if (typeof fun !== \"function\") { throw new TypeError(); }\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                if (arr.hasOwnProperty(i) && fun.call(thisp, arr[i], i, arr)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        };\r\n    }\r\n\r\n    if (Array.prototype.filter) {\r\n        buster.filter = function (arr, fn, thisp) {\r\n            return arr.filter(fn, thisp);\r\n        };\r\n    } else {\r\n        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter\r\n        buster.filter = function (fn, thisp) {\r\n                        if (this == null) { throw new TypeError(); }\r\n\r\n            var t = Object(this);\r\n            var len = t.length >>> 0;\r\n            if (typeof fn != \"function\") { throw new TypeError(); }\r\n\r\n            var res = [];\r\n            for (var i = 0; i < len; i++) {\r\n                if (i in t) {\r\n                    var val = t[i]; // in case fun mutates this\r\n                    if (fn.call(thisp, val, i, t)) { res.push(val); }\r\n                }\r\n            }\r\n\r\n            return res;\r\n        };\r\n    }\r\n\r\n    if (isNode) {\r\n        module.exports = buster;\r\n        buster.eventEmitter = require(\"./buster-event-emitter\");\r\n        Object.defineProperty(buster, \"defineVersionGetter\", {\r\n            get: function () {\r\n                return require(\"./define-version-getter\");\r\n            }\r\n        });\r\n    }\r\n\r\n    return buster.extend(B || {}, buster);\r\n}(setTimeout, buster));\r\nif (typeof buster === \"undefined\") {\r\n    var buster = {};\r\n}\r\n\r\nif (typeof module === \"object\" && typeof require === \"function\") {\r\n    buster = require(\"buster-core\");\r\n}\r\n\r\nbuster.format = buster.format || {};\r\nbuster.format.excludeConstructors = [\"Object\", /^.$/];\r\nbuster.format.quoteStrings = true;\r\n\r\nbuster.format.ascii = (function () {\r\n\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n    var specialObjects = [];\r\n    if (typeof global != \"undefined\") {\r\n        specialObjects.push({ obj: global, value: \"[object global]\" });\r\n    }\r\n    if (typeof document != \"undefined\") {\r\n        specialObjects.push({ obj: document, value: \"[object HTMLDocument]\" });\r\n    }\r\n    if (typeof window != \"undefined\") {\r\n        specialObjects.push({ obj: window, value: \"[object Window]\" });\r\n    }\r\n\r\n    function keys(object) {\r\n        var k = Object.keys && Object.keys(object) || [];\r\n\r\n        if (k.length == 0) {\r\n            for (var prop in object) {\r\n                if (hasOwn.call(object, prop)) {\r\n                    k.push(prop);\r\n                }\r\n            }\r\n        }\r\n\r\n        return k.sort();\r\n    }\r\n\r\n    function isCircular(object, objects) {\r\n        if (typeof object != \"object\") {\r\n            return false;\r\n        }\r\n\r\n        for (var i = 0, l = objects.length; i < l; ++i) {\r\n            if (objects[i] === object) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function ascii(object, processed, indent) {\r\n        if (typeof object == \"string\") {\r\n            var quote = typeof this.quoteStrings != \"boolean\" || this.quoteStrings;\r\n            return processed || quote ? '\"' + object + '\"' : object;\r\n        }\r\n\r\n        if (typeof object == \"function\" && !(object instanceof RegExp)) {\r\n            return ascii.func(object);\r\n        }\r\n\r\n        processed = processed || [];\r\n\r\n        if (isCircular(object, processed)) {\r\n            return \"[Circular]\";\r\n        }\r\n\r\n        if (Object.prototype.toString.call(object) == \"[object Array]\") {\r\n            return ascii.array.call(this, object, processed);\r\n        }\r\n\r\n        if (!object) {\r\n            return \"\" + object;\r\n        }\r\n\r\n        if (buster.isElement(object)) {\r\n            return ascii.element(object);\r\n        }\r\n\r\n        if (typeof object.toString == \"function\" &&\r\n            object.toString !== Object.prototype.toString) {\r\n            return object.toString();\r\n        }\r\n\r\n        for (var i = 0, l = specialObjects.length; i < l; i++) {\r\n            if (object === specialObjects[i].obj) {\r\n                return specialObjects[i].value;\r\n            }\r\n        }\r\n\r\n        return ascii.object.call(this, object, processed, indent);\r\n    }\r\n\r\n    ascii.func = function (func) {\r\n        return \"function \" + buster.functionName(func) + \"() {}\";\r\n    };\r\n\r\n    ascii.array = function (array, processed) {\r\n        processed = processed || [];\r\n        processed.push(array);\r\n        var pieces = [];\r\n\r\n        for (var i = 0, l = array.length; i < l; ++i) {\r\n            pieces.push(ascii.call(this, array[i], processed));\r\n        }\r\n\r\n        return \"[\" + pieces.join(\", \") + \"]\";\r\n    };\r\n\r\n    ascii.object = function (object, processed, indent) {\r\n        processed = processed || [];\r\n        processed.push(object);\r\n        indent = indent || 0;\r\n        var pieces = [], properties = keys(object), prop, str, obj;\r\n        var is = \"\";\r\n        var length = 3;\r\n\r\n        for (var i = 0, l = indent; i < l; ++i) {\r\n            is += \" \";\r\n        }\r\n\r\n        for (i = 0, l = properties.length; i < l; ++i) {\r\n            prop = properties[i];\r\n            obj = object[prop];\r\n\r\n            if (isCircular(obj, processed)) {\r\n                str = \"[Circular]\";\r\n            } else {\r\n                str = ascii.call(this, obj, processed, indent + 2);\r\n            }\r\n\r\n            str = (/\\s/.test(prop) ? '\"' + prop + '\"' : prop) + \": \" + str;\r\n            length += str.length;\r\n            pieces.push(str);\r\n        }\r\n\r\n        var cons = ascii.constructorName.call(this, object);\r\n        var prefix = cons ? \"[\" + cons + \"] \" : \"\"\r\n\r\n        return (length + indent) > 80 ?\r\n            prefix + \"{\\n  \" + is + pieces.join(\",\\n  \" + is) + \"\\n\" + is + \"}\" :\r\n            prefix + \"{ \" + pieces.join(\", \") + \" }\";\r\n    };\r\n\r\n    ascii.element = function (element) {\r\n        var tagName = element.tagName.toLowerCase();\r\n        var attrs = element.attributes, attribute, pairs = [], attrName;\r\n\r\n        for (var i = 0, l = attrs.length; i < l; ++i) {\r\n            attribute = attrs.item(i);\r\n            attrName = attribute.nodeName.toLowerCase().replace(\"html:\", \"\");\r\n\r\n            if (attrName == \"contenteditable\" && attribute.nodeValue == \"inherit\") {\r\n                continue;\r\n            }\r\n\r\n            if (!!attribute.nodeValue) {\r\n                pairs.push(attrName + \"=\\\"\" + attribute.nodeValue + \"\\\"\");\r\n            }\r\n        }\r\n\r\n        var formatted = \"<\" + tagName + (pairs.length > 0 ? \" \" : \"\");\r\n        var content = element.innerHTML;\r\n\r\n        if (content.length > 20) {\r\n            content = content.substr(0, 20) + \"[...]\";\r\n        }\r\n\r\n        var res = formatted + pairs.join(\" \") + \">\" + content + \"</\" + tagName + \">\";\r\n\r\n        return res.replace(/ contentEditable=\"inherit\"/, \"\");\r\n    };\r\n\r\n    ascii.constructorName = function (object) {\r\n        var name = buster.functionName(object && object.constructor);\r\n        var excludes = this.excludeConstructors || buster.format.excludeConstructors || [];\r\n\r\n        for (var i = 0, l = excludes.length; i < l; ++i) {\r\n            if (typeof excludes[i] == \"string\" && excludes[i] == name) {\r\n                return \"\";\r\n            } else if (excludes[i].test && excludes[i].test(name)) {\r\n                return \"\";\r\n            }\r\n        }\r\n\r\n        return name;\r\n    };\r\n\r\n    return ascii;\r\n}());\r\n\r\nif (typeof module != \"undefined\") {\r\n    module.exports = buster.format;\r\n}\r\n/*jslint eqeqeq: false, onevar: false, forin: true, nomen: false, regexp: false, plusplus: false*/\r\n/*global module, require, __dirname, document*/\r\n/**\r\n * Sinon core utilities. For internal use only.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\nvar sinon = (function (buster) {\r\n    var div = typeof document != \"undefined\" && document.createElement(\"div\");\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n    function isDOMNode(obj) {\r\n        var success = false;\r\n\r\n        try {\r\n            obj.appendChild(div);\r\n            success = div.parentNode == obj;\r\n        } catch (e) {\r\n            return false;\r\n        } finally {\r\n            try {\r\n                obj.removeChild(div);\r\n            } catch (e) {\r\n                // Remove failed, not much we can do about that\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function isElement(obj) {\r\n        return div && obj && obj.nodeType === 1 && isDOMNode(obj);\r\n    }\r\n\r\n    function isFunction(obj) {\r\n        return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\r\n    }\r\n\r\n    function mirrorProperties(target, source) {\r\n        for (var prop in source) {\r\n            if (!hasOwn.call(target, prop)) {\r\n                target[prop] = source[prop];\r\n            }\r\n        }\r\n    }\r\n\r\n    var sinon = {\r\n        wrapMethod: function wrapMethod(object, property, method) {\r\n            if (!object) {\r\n                throw new TypeError(\"Should wrap property of object\");\r\n            }\r\n\r\n            if (typeof method != \"function\") {\r\n                throw new TypeError(\"Method wrapper should be function\");\r\n            }\r\n\r\n            var wrappedMethod = object[property];\r\n\r\n            if (!isFunction(wrappedMethod)) {\r\n                throw new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\r\n                                    property + \" as function\");\r\n            }\r\n\r\n            if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\r\n                throw new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\r\n            }\r\n\r\n            if (wrappedMethod.calledBefore) {\r\n                var verb = !!wrappedMethod.returns ? \"stubbed\" : \"spied on\";\r\n                throw new TypeError(\"Attempted to wrap \" + property + \" which is already \" + verb);\r\n            }\r\n\r\n            // IE 8 does not support hasOwnProperty on the window object.\r\n            var owned = hasOwn.call(object, property);\r\n            object[property] = method;\r\n            method.displayName = property;\r\n\r\n            method.restore = function () {\r\n                // For prototype properties try to reset by delete first.\r\n                // If this fails (ex: localStorage on mobile safari) then force a reset\r\n                // via direct assignment.\r\n                if (!owned) {\r\n                    delete object[property];\r\n                }\r\n                if (object[property] === method) {\r\n                    object[property] = wrappedMethod;\r\n                }\r\n            };\r\n\r\n            method.restore.sinon = true;\r\n            mirrorProperties(method, wrappedMethod);\r\n\r\n            return method;\r\n        },\r\n\r\n        extend: function extend(target) {\r\n            for (var i = 1, l = arguments.length; i < l; i += 1) {\r\n                for (var prop in arguments[i]) {\r\n                    if (arguments[i].hasOwnProperty(prop)) {\r\n                        target[prop] = arguments[i][prop];\r\n                    }\r\n\r\n                    // DONT ENUM bug, only care about toString\r\n                    if (arguments[i].hasOwnProperty(\"toString\") &&\r\n                        arguments[i].toString != target.toString) {\r\n                        target.toString = arguments[i].toString;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return target;\r\n        },\r\n\r\n        create: function create(proto) {\r\n            var F = function () {};\r\n            F.prototype = proto;\r\n            return new F();\r\n        },\r\n\r\n        deepEqual: function deepEqual(a, b) {\r\n            if (sinon.match && sinon.match.isMatcher(a)) {\r\n                return a.test(b);\r\n            }\r\n            if (typeof a != \"object\" || typeof b != \"object\") {\r\n                return a === b;\r\n            }\r\n\r\n            if (isElement(a) || isElement(b)) {\r\n                return a === b;\r\n            }\r\n\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n\r\n            if ((a === null && b !== null) || (a !== null && b === null)) {\r\n                return false;\r\n            }\r\n\r\n            var aString = Object.prototype.toString.call(a);\r\n            if (aString != Object.prototype.toString.call(b)) {\r\n                return false;\r\n            }\r\n\r\n            if (aString == \"[object Array]\") {\r\n                if (a.length !== b.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (var i = 0, l = a.length; i < l; i += 1) {\r\n                    if (!deepEqual(a[i], b[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            var prop, aLength = 0, bLength = 0;\r\n\r\n            for (prop in a) {\r\n                aLength += 1;\r\n\r\n                if (!deepEqual(a[prop], b[prop])) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            for (prop in b) {\r\n                bLength += 1;\r\n            }\r\n\r\n            if (aLength != bLength) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        functionName: function functionName(func) {\r\n            var name = func.displayName || func.name;\r\n\r\n            // Use function decomposition as a last resort to get function\r\n            // name. Does not rely on function decomposition to work - if it\r\n            // doesn't debugging will be slightly less informative\r\n            // (i.e. toString will say 'spy' rather than 'myFunc').\r\n            if (!name) {\r\n                var matches = func.toString().match(/function ([^\\s\\(]+)/);\r\n                name = matches && matches[1];\r\n            }\r\n\r\n            return name;\r\n        },\r\n\r\n        functionToString: function toString() {\r\n            if (this.getCall && this.callCount) {\r\n                var thisValue, prop, i = this.callCount;\r\n\r\n                while (i--) {\r\n                    thisValue = this.getCall(i).thisValue;\r\n\r\n                    for (prop in thisValue) {\r\n                        if (thisValue[prop] === this) {\r\n                            return prop;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.displayName || \"sinon fake\";\r\n        },\r\n\r\n        getConfig: function (custom) {\r\n            var config = {};\r\n            custom = custom || {};\r\n            var defaults = sinon.defaultConfig;\r\n\r\n            for (var prop in defaults) {\r\n                if (defaults.hasOwnProperty(prop)) {\r\n                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];\r\n                }\r\n            }\r\n\r\n            return config;\r\n        },\r\n\r\n        format: function (val) {\r\n            return \"\" + val;\r\n        },\r\n\r\n        defaultConfig: {\r\n            injectIntoThis: true,\r\n            injectInto: null,\r\n            properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\r\n            useFakeTimers: true,\r\n            useFakeServer: true\r\n        },\r\n\r\n        timesInWords: function timesInWords(count) {\r\n            return count == 1 && \"once\" ||\r\n                count == 2 && \"twice\" ||\r\n                count == 3 && \"thrice\" ||\r\n                (count || 0) + \" times\";\r\n        },\r\n\r\n        calledInOrder: function (spies) {\r\n            for (var i = 1, l = spies.length; i < l; i++) {\r\n                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        orderByFirstCall: function (spies) {\r\n            return spies.sort(function (a, b) {\r\n                // uuid, won't ever be equal\r\n                var aCall = a.getCall(0);\r\n                var bCall = b.getCall(0);\r\n                var aId = aCall && aCall.callId || -1;\r\n                var bId = bCall && bCall.callId || -1;\r\n\r\n                return aId < bId ? -1 : 1;\r\n            });\r\n        },\r\n\r\n        log: function () {},\r\n\r\n        logError: function (label, err) {\r\n            var msg = label + \" threw exception: \"\r\n            sinon.log(msg + \"[\" + err.name + \"] \" + err.message);\r\n            if (err.stack) { sinon.log(err.stack); }\r\n\r\n            setTimeout(function () {\r\n                err.message = msg + err.message;\r\n                throw err;\r\n            }, 0);\r\n        },\r\n\r\n        typeOf: function (value) {\r\n            if (value === null) {\r\n                return \"null\";\r\n            }\r\n            else if (value === undefined) {\r\n                return \"undefined\";\r\n            }\r\n            var string = Object.prototype.toString.call(value);\r\n            return string.substring(8, string.length - 1).toLowerCase();\r\n        },\r\n\r\n        createStubInstance: function (constructor) {\r\n            if (typeof constructor !== \"function\") {\r\n                throw new TypeError(\"The constructor should be a function.\");\r\n            }\r\n            return sinon.stub(sinon.create(constructor.prototype));\r\n        }\r\n    };\r\n\r\n    var isNode = typeof module == \"object\" && typeof require == \"function\";\r\n\r\n    if (isNode) {\r\n        try {\r\n            buster = { format: require(\"buster-format\") };\r\n        } catch (e) {}\r\n        module.exports = sinon;\r\n        module.exports.spy = require(\"./sinon/spy\");\r\n        module.exports.stub = require(\"./sinon/stub\");\r\n        module.exports.mock = require(\"./sinon/mock\");\r\n        module.exports.collection = require(\"./sinon/collection\");\r\n        module.exports.assert = require(\"./sinon/assert\");\r\n        module.exports.sandbox = require(\"./sinon/sandbox\");\r\n        module.exports.test = require(\"./sinon/test\");\r\n        module.exports.testCase = require(\"./sinon/test_case\");\r\n        module.exports.assert = require(\"./sinon/assert\");\r\n        module.exports.match = require(\"./sinon/match\");\r\n    }\r\n\r\n    if (buster) {\r\n        var formatter = sinon.create(buster.format);\r\n        formatter.quoteStrings = false;\r\n        sinon.format = function () {\r\n            return formatter.ascii.apply(formatter, arguments);\r\n        };\r\n    } else if (isNode) {\r\n        try {\r\n            var util = require(\"util\");\r\n            sinon.format = function (value) {\r\n                return typeof value == \"object\" && value.toString === Object.prototype.toString ? util.inspect(value) : value;\r\n            };\r\n        } catch (e) {\r\n            /* Node, but no util module - would be very old, but better safe than\r\n             sorry */\r\n        }\r\n    }\r\n\r\n    return sinon;\r\n}(typeof buster == \"object\" && buster));\r\n\r\n/* @depend ../sinon.js */\r\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Match functions\r\n *\r\n * @author Maximilian Antoni (mail@maxantoni.de)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2012 Maximilian Antoni\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function assertType(value, type, name) {\r\n        var actual = sinon.typeOf(value);\r\n        if (actual !== type) {\r\n            throw new TypeError(\"Expected type of \" + name + \" to be \" +\r\n                type + \", but was \" + actual);\r\n        }\r\n    }\r\n\r\n    var matcher = {\r\n        toString: function () {\r\n            return this.message;\r\n        }\r\n    };\r\n\r\n    function isMatcher(object) {\r\n        return matcher.isPrototypeOf(object);\r\n    }\r\n\r\n    function matchObject(expectation, actual) {\r\n        if (actual === null || actual === undefined) {\r\n            return false;\r\n        }\r\n        for (var key in expectation) {\r\n            if (expectation.hasOwnProperty(key)) {\r\n                var exp = expectation[key];\r\n                var act = actual[key];\r\n                if (match.isMatcher(exp)) {\r\n                    if (!exp.test(act)) {\r\n                        return false;\r\n                    }\r\n                } else if (sinon.typeOf(exp) === \"object\") {\r\n                    if (!matchObject(exp, act)) {\r\n                        return false;\r\n                    }\r\n                } else if (!sinon.deepEqual(exp, act)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    matcher.or = function (m2) {\r\n        if (!isMatcher(m2)) {\r\n            throw new TypeError(\"Matcher expected\");\r\n        }\r\n        var m1 = this;\r\n        var or = sinon.create(matcher);\r\n        or.test = function (actual) {\r\n            return m1.test(actual) || m2.test(actual);\r\n        };\r\n        or.message = m1.message + \".or(\" + m2.message + \")\";\r\n        return or;\r\n    };\r\n\r\n    matcher.and = function (m2) {\r\n        if (!isMatcher(m2)) {\r\n            throw new TypeError(\"Matcher expected\");\r\n        }\r\n        var m1 = this;\r\n        var and = sinon.create(matcher);\r\n        and.test = function (actual) {\r\n            return m1.test(actual) && m2.test(actual);\r\n        };\r\n        and.message = m1.message + \".and(\" + m2.message + \")\";\r\n        return and;\r\n    };\r\n\r\n    var match = function (expectation, message) {\r\n        var m = sinon.create(matcher);\r\n        var type = sinon.typeOf(expectation);\r\n        switch (type) {\r\n        case \"object\":\r\n            if (typeof expectation.test === \"function\") {\r\n                m.test = function (actual) {\r\n                    return expectation.test(actual) === true;\r\n                };\r\n                m.message = \"match(\" + sinon.functionName(expectation.test) + \")\";\r\n                return m;\r\n            }\r\n            var str = [];\r\n            for (var key in expectation) {\r\n                if (expectation.hasOwnProperty(key)) {\r\n                    str.push(key + \": \" + expectation[key]);\r\n                }\r\n            }\r\n            m.test = function (actual) {\r\n                return matchObject(expectation, actual);\r\n            };\r\n            m.message = \"match(\" + str.join(\", \") + \")\";\r\n            break;\r\n        case \"number\":\r\n            m.test = function (actual) {\r\n                return expectation == actual;\r\n            };\r\n            break;\r\n        case \"string\":\r\n            m.test = function (actual) {\r\n                if (typeof actual !== \"string\") {\r\n                    return false;\r\n                }\r\n                return actual.indexOf(expectation) !== -1;\r\n            };\r\n            m.message = \"match(\\\"\" + expectation + \"\\\")\";\r\n            break;\r\n        case \"regexp\":\r\n            m.test = function (actual) {\r\n                if (typeof actual !== \"string\") {\r\n                    return false;\r\n                }\r\n                return expectation.test(actual);\r\n            };\r\n            break;\r\n        case \"function\":\r\n            m.test = expectation;\r\n            if (message) {\r\n                m.message = message;\r\n            } else {\r\n                m.message = \"match(\" + sinon.functionName(expectation) + \")\";\r\n            }\r\n            break;\r\n        default:\r\n            m.test = function (actual) {\r\n              return sinon.deepEqual(expectation, actual);\r\n            };\r\n        }\r\n        if (!m.message) {\r\n            m.message = \"match(\" + expectation + \")\";\r\n        }\r\n        return m;\r\n    };\r\n\r\n    match.isMatcher = isMatcher;\r\n\r\n    match.any = match(function () {\r\n        return true;\r\n    }, \"any\");\r\n\r\n    match.defined = match(function (actual) {\r\n        return actual !== null && actual !== undefined;\r\n    }, \"defined\");\r\n\r\n    match.truthy = match(function (actual) {\r\n        return !!actual;\r\n    }, \"truthy\");\r\n\r\n    match.falsy = match(function (actual) {\r\n        return !actual;\r\n    }, \"falsy\");\r\n\r\n    match.same = function (expectation) {\r\n        return match(function (actual) {\r\n            return expectation === actual;\r\n        }, \"same(\" + expectation + \")\");\r\n    };\r\n\r\n    match.typeOf = function (type) {\r\n        assertType(type, \"string\", \"type\");\r\n        return match(function (actual) {\r\n            return sinon.typeOf(actual) === type;\r\n        }, \"typeOf(\\\"\" + type + \"\\\")\");\r\n    };\r\n\r\n    match.instanceOf = function (type) {\r\n        assertType(type, \"function\", \"type\");\r\n        return match(function (actual) {\r\n            return actual instanceof type;\r\n        }, \"instanceOf(\" + sinon.functionName(type) + \")\");\r\n    };\r\n\r\n    function createPropertyMatcher(propertyTest, messagePrefix) {\r\n        return function (property, value) {\r\n            assertType(property, \"string\", \"property\");\r\n            var onlyProperty = arguments.length === 1;\r\n            var message = messagePrefix + \"(\\\"\" + property + \"\\\"\";\r\n            if (!onlyProperty) {\r\n                message += \", \" + value;\r\n            }\r\n            message += \")\";\r\n            return match(function (actual) {\r\n                if (actual === undefined || actual === null ||\r\n                        !propertyTest(actual, property)) {\r\n                    return false;\r\n                }\r\n                return onlyProperty || sinon.deepEqual(value, actual[property]);\r\n            }, message);\r\n        };\r\n    }\r\n\r\n    match.has = createPropertyMatcher(function (actual, property) {\r\n        if (typeof actual === \"object\") {\r\n            return property in actual;\r\n        }\r\n        return actual[property] !== undefined;\r\n    }, \"has\");\r\n\r\n    match.hasOwn = createPropertyMatcher(function (actual, property) {\r\n        return actual.hasOwnProperty(property);\r\n    }, \"hasOwn\");\r\n\r\n    match.bool = match.typeOf(\"boolean\");\r\n    match.number = match.typeOf(\"number\");\r\n    match.string = match.typeOf(\"string\");\r\n    match.object = match.typeOf(\"object\");\r\n    match.func = match.typeOf(\"function\");\r\n    match.array = match.typeOf(\"array\");\r\n    match.regexp = match.typeOf(\"regexp\");\r\n    match.date = match.typeOf(\"date\");\r\n\r\n    if (commonJSModule) {\r\n        module.exports = match;\r\n    } else {\r\n        sinon.match = match;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n  * @depend ../sinon.js\r\n  * @depend match.js\r\n  */\r\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n  * Spy functions\r\n  *\r\n  * @author Christian Johansen (christian@cjohansen.no)\r\n  * @license BSD\r\n  *\r\n  * Copyright (c) 2010-2013 Christian Johansen\r\n  */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n    var spyCall;\r\n    var callId = 0;\r\n    var push = [].push;\r\n    var slice = Array.prototype.slice;\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function spy(object, property) {\r\n        if (!property && typeof object == \"function\") {\r\n            return spy.create(object);\r\n        }\r\n\r\n        if (!object && !property) {\r\n            return spy.create(function () { });\r\n        }\r\n\r\n        var method = object[property];\r\n        return sinon.wrapMethod(object, property, spy.create(method));\r\n    }\r\n\r\n    sinon.extend(spy, (function () {\r\n\r\n        function delegateToCalls(api, method, matchAny, actual, notCalled) {\r\n            api[method] = function () {\r\n                if (!this.called) {\r\n                    if (notCalled) {\r\n                        return notCalled.apply(this, arguments);\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                var currentCall;\r\n                var matches = 0;\r\n\r\n                for (var i = 0, l = this.callCount; i < l; i += 1) {\r\n                    currentCall = this.getCall(i);\r\n\r\n                    if (currentCall[actual || method].apply(currentCall, arguments)) {\r\n                        matches += 1;\r\n\r\n                        if (matchAny) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return matches === this.callCount;\r\n            };\r\n        }\r\n\r\n        function matchingFake(fakes, args, strict) {\r\n            if (!fakes) {\r\n                return;\r\n            }\r\n\r\n            var alen = args.length;\r\n\r\n            for (var i = 0, l = fakes.length; i < l; i++) {\r\n                if (fakes[i].matches(args, strict)) {\r\n                    return fakes[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        function incrementCallCount() {\r\n            this.called = true;\r\n            this.callCount += 1;\r\n            this.notCalled = false;\r\n            this.calledOnce = this.callCount == 1;\r\n            this.calledTwice = this.callCount == 2;\r\n            this.calledThrice = this.callCount == 3;\r\n        }\r\n\r\n        function createCallProperties() {\r\n            this.firstCall = this.getCall(0);\r\n            this.secondCall = this.getCall(1);\r\n            this.thirdCall = this.getCall(2);\r\n            this.lastCall = this.getCall(this.callCount - 1);\r\n        }\r\n\r\n        var vars = \"a,b,c,d,e,f,g,h,i,j,k,l\";\r\n        function createProxy(func) {\r\n            // Retain the function length:\r\n            var p;\r\n            if (func.length) {\r\n                eval(\"p = (function proxy(\" + vars.substring(0, func.length * 2 - 1) +\r\n                    \") { return p.invoke(func, this, slice.call(arguments)); });\");\r\n            }\r\n            else {\r\n                p = function proxy() {\r\n                    return p.invoke(func, this, slice.call(arguments));\r\n                };\r\n            }\r\n            return p;\r\n        }\r\n\r\n        var uuid = 0;\r\n\r\n        // Public API\r\n        var spyApi = {\r\n            reset: function () {\r\n                this.called = false;\r\n                this.notCalled = true;\r\n                this.calledOnce = false;\r\n                this.calledTwice = false;\r\n                this.calledThrice = false;\r\n                this.callCount = 0;\r\n                this.firstCall = null;\r\n                this.secondCall = null;\r\n                this.thirdCall = null;\r\n                this.lastCall = null;\r\n                this.args = [];\r\n                this.returnValues = [];\r\n                this.thisValues = [];\r\n                this.exceptions = [];\r\n                this.callIds = [];\r\n                if (this.fakes) {\r\n                    for (var i = 0; i < this.fakes.length; i++) {\r\n                        this.fakes[i].reset();\r\n                    }\r\n                }\r\n            },\r\n\r\n            create: function create(func) {\r\n                var name;\r\n\r\n                if (typeof func != \"function\") {\r\n                    func = function () { };\r\n                } else {\r\n                    name = sinon.functionName(func);\r\n                }\r\n\r\n                var proxy = createProxy(func);\r\n\r\n                sinon.extend(proxy, spy);\r\n                delete proxy.create;\r\n                sinon.extend(proxy, func);\r\n\r\n                proxy.reset();\r\n                proxy.prototype = func.prototype;\r\n                proxy.displayName = name || \"spy\";\r\n                proxy.toString = sinon.functionToString;\r\n                proxy._create = sinon.spy.create;\r\n                proxy.id = \"spy#\" + uuid++;\r\n\r\n                return proxy;\r\n            },\r\n\r\n            invoke: function invoke(func, thisValue, args) {\r\n                var matching = matchingFake(this.fakes, args);\r\n                var exception, returnValue;\r\n\r\n                incrementCallCount.call(this);\r\n                push.call(this.thisValues, thisValue);\r\n                push.call(this.args, args);\r\n                push.call(this.callIds, callId++);\r\n\r\n                try {\r\n                    if (matching) {\r\n                        returnValue = matching.invoke(func, thisValue, args);\r\n                    } else {\r\n                        returnValue = (this.func || func).apply(thisValue, args);\r\n                    }\r\n                } catch (e) {\r\n                    push.call(this.returnValues, undefined);\r\n                    exception = e;\r\n                    throw e;\r\n                } finally {\r\n                    push.call(this.exceptions, exception);\r\n                }\r\n\r\n                push.call(this.returnValues, returnValue);\r\n\r\n                createCallProperties.call(this);\r\n\r\n                return returnValue;\r\n            },\r\n\r\n            getCall: function getCall(i) {\r\n                if (i < 0 || i >= this.callCount) {\r\n                    return null;\r\n                }\r\n\r\n                return spyCall.create(this, this.thisValues[i], this.args[i],\r\n                                        this.returnValues[i], this.exceptions[i],\r\n                                        this.callIds[i]);\r\n            },\r\n\r\n            calledBefore: function calledBefore(spyFn) {\r\n                if (!this.called) {\r\n                    return false;\r\n                }\r\n\r\n                if (!spyFn.called) {\r\n                    return true;\r\n                }\r\n\r\n                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\r\n            },\r\n\r\n            calledAfter: function calledAfter(spyFn) {\r\n                if (!this.called || !spyFn.called) {\r\n                    return false;\r\n                }\r\n\r\n                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\r\n            },\r\n\r\n            withArgs: function () {\r\n                var args = slice.call(arguments);\r\n\r\n                if (this.fakes) {\r\n                    var match = matchingFake(this.fakes, args, true);\r\n\r\n                    if (match) {\r\n                        return match;\r\n                    }\r\n                } else {\r\n                    this.fakes = [];\r\n                }\r\n\r\n                var original = this;\r\n                var fake = this._create();\r\n                fake.matchingAguments = args;\r\n                push.call(this.fakes, fake);\r\n\r\n                fake.withArgs = function () {\r\n                    return original.withArgs.apply(original, arguments);\r\n                };\r\n\r\n                for (var i = 0; i < this.args.length; i++) {\r\n                    if (fake.matches(this.args[i])) {\r\n                        incrementCallCount.call(fake);\r\n                        push.call(fake.thisValues, this.thisValues[i]);\r\n                        push.call(fake.args, this.args[i]);\r\n                        push.call(fake.returnValues, this.returnValues[i]);\r\n                        push.call(fake.exceptions, this.exceptions[i]);\r\n                        push.call(fake.callIds, this.callIds[i]);\r\n                    }\r\n                }\r\n                createCallProperties.call(fake);\r\n\r\n                return fake;\r\n            },\r\n\r\n            matches: function (args, strict) {\r\n                var margs = this.matchingAguments;\r\n\r\n                if (margs.length <= args.length &&\r\n                    sinon.deepEqual(margs, args.slice(0, margs.length))) {\r\n                    return !strict || margs.length == args.length;\r\n                }\r\n            },\r\n\r\n            printf: function (format) {\r\n                var spy = this;\r\n                var args = slice.call(arguments, 1);\r\n                var formatter;\r\n\r\n                return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\r\n                    formatter = spyApi.formatters[specifyer];\r\n\r\n                    if (typeof formatter == \"function\") {\r\n                        return formatter.call(null, spy, args);\r\n                    } else if (!isNaN(parseInt(specifyer), 10)) {\r\n                        return sinon.format(args[specifyer - 1]);\r\n                    }\r\n\r\n                    return \"%\" + specifyer;\r\n                });\r\n            }\r\n        };\r\n\r\n        delegateToCalls(spyApi, \"calledOn\", true);\r\n        delegateToCalls(spyApi, \"alwaysCalledOn\", false, \"calledOn\");\r\n        delegateToCalls(spyApi, \"calledWith\", true);\r\n        delegateToCalls(spyApi, \"calledWithMatch\", true);\r\n        delegateToCalls(spyApi, \"alwaysCalledWith\", false, \"calledWith\");\r\n        delegateToCalls(spyApi, \"alwaysCalledWithMatch\", false, \"calledWithMatch\");\r\n        delegateToCalls(spyApi, \"calledWithExactly\", true);\r\n        delegateToCalls(spyApi, \"alwaysCalledWithExactly\", false, \"calledWithExactly\");\r\n        delegateToCalls(spyApi, \"neverCalledWith\", false, \"notCalledWith\",\r\n            function () { return true; });\r\n        delegateToCalls(spyApi, \"neverCalledWithMatch\", false, \"notCalledWithMatch\",\r\n            function () { return true; });\r\n        delegateToCalls(spyApi, \"threw\", true);\r\n        delegateToCalls(spyApi, \"alwaysThrew\", false, \"threw\");\r\n        delegateToCalls(spyApi, \"returned\", true);\r\n        delegateToCalls(spyApi, \"alwaysReturned\", false, \"returned\");\r\n        delegateToCalls(spyApi, \"calledWithNew\", true);\r\n        delegateToCalls(spyApi, \"alwaysCalledWithNew\", false, \"calledWithNew\");\r\n        delegateToCalls(spyApi, \"callArg\", false, \"callArgWith\", function () {\r\n            throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\r\n        });\r\n        spyApi.callArgWith = spyApi.callArg;\r\n        delegateToCalls(spyApi, \"callArgOn\", false, \"callArgOnWith\", function () {\r\n            throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\r\n        });\r\n        spyApi.callArgOnWith = spyApi.callArgOn;\r\n        delegateToCalls(spyApi, \"yield\", false, \"yield\", function () {\r\n            throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\r\n        });\r\n        // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\r\n        spyApi.invokeCallback = spyApi.yield;\r\n        delegateToCalls(spyApi, \"yieldOn\", false, \"yieldOn\", function () {\r\n            throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\r\n        });\r\n        delegateToCalls(spyApi, \"yieldTo\", false, \"yieldTo\", function (property) {\r\n            throw new Error(this.toString() + \" cannot yield to '\" + property +\r\n                \"' since it was not yet invoked.\");\r\n        });\r\n        delegateToCalls(spyApi, \"yieldToOn\", false, \"yieldToOn\", function (property) {\r\n            throw new Error(this.toString() + \" cannot yield to '\" + property +\r\n                \"' since it was not yet invoked.\");\r\n        });\r\n\r\n        spyApi.formatters = {\r\n            \"c\": function (spy) {\r\n                return sinon.timesInWords(spy.callCount);\r\n            },\r\n\r\n            \"n\": function (spy) {\r\n                return spy.toString();\r\n            },\r\n\r\n            \"C\": function (spy) {\r\n                var calls = [];\r\n\r\n                for (var i = 0, l = spy.callCount; i < l; ++i) {\r\n                    var stringifiedCall = \"    \" + spy.getCall(i).toString();\r\n                    if (/\\n/.test(calls[i - 1])) {\r\n                        stringifiedCall = \"\\n\" + stringifiedCall;\r\n                    }\r\n                    push.call(calls, stringifiedCall);\r\n                }\r\n\r\n                return calls.length > 0 ? \"\\n\" + calls.join(\"\\n\") : \"\";\r\n            },\r\n\r\n            \"t\": function (spy) {\r\n                var objects = [];\r\n\r\n                for (var i = 0, l = spy.callCount; i < l; ++i) {\r\n                    push.call(objects, sinon.format(spy.thisValues[i]));\r\n                }\r\n\r\n                return objects.join(\", \");\r\n            },\r\n\r\n            \"*\": function (spy, args) {\r\n                var formatted = [];\r\n\r\n                for (var i = 0, l = args.length; i < l; ++i) {\r\n                    push.call(formatted, sinon.format(args[i]));\r\n                }\r\n\r\n                return formatted.join(\", \");\r\n            }\r\n        };\r\n\r\n        return spyApi;\r\n    }()));\r\n\r\n    spyCall = (function () {\r\n\r\n        function throwYieldError(proxy, text, args) {\r\n            var msg = sinon.functionName(proxy) + text;\r\n            if (args.length) {\r\n                msg += \" Received [\" + slice.call(args).join(\", \") + \"]\";\r\n            }\r\n            throw new Error(msg);\r\n        }\r\n\r\n        var callApi = {\r\n            create: function create(spy, thisValue, args, returnValue, exception, id) {\r\n                var proxyCall = sinon.create(spyCall);\r\n                delete proxyCall.create;\r\n                proxyCall.proxy = spy;\r\n                proxyCall.thisValue = thisValue;\r\n                proxyCall.args = args;\r\n                proxyCall.returnValue = returnValue;\r\n                proxyCall.exception = exception;\r\n                proxyCall.callId = typeof id == \"number\" && id || callId++;\r\n\r\n                return proxyCall;\r\n            },\r\n\r\n            calledOn: function calledOn(thisValue) {\r\n                if (sinon.match && sinon.match.isMatcher(thisValue)) {\r\n                    return thisValue.test(this.thisValue);\r\n                }\r\n                return this.thisValue === thisValue;\r\n            },\r\n\r\n            calledWith: function calledWith() {\r\n                for (var i = 0, l = arguments.length; i < l; i += 1) {\r\n                    if (!sinon.deepEqual(arguments[i], this.args[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            },\r\n\r\n            calledWithMatch: function calledWithMatch() {\r\n                for (var i = 0, l = arguments.length; i < l; i += 1) {\r\n                    var actual = this.args[i];\r\n                    var expectation = arguments[i];\r\n                    if (!sinon.match || !sinon.match(expectation).test(actual)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            },\r\n\r\n            calledWithExactly: function calledWithExactly() {\r\n                return arguments.length == this.args.length &&\r\n                    this.calledWith.apply(this, arguments);\r\n            },\r\n\r\n            notCalledWith: function notCalledWith() {\r\n                return !this.calledWith.apply(this, arguments);\r\n            },\r\n\r\n            notCalledWithMatch: function notCalledWithMatch() {\r\n                return !this.calledWithMatch.apply(this, arguments);\r\n            },\r\n\r\n            returned: function returned(value) {\r\n                return sinon.deepEqual(value, this.returnValue);\r\n            },\r\n\r\n            threw: function threw(error) {\r\n                if (typeof error == \"undefined\" || !this.exception) {\r\n                    return !!this.exception;\r\n                }\r\n\r\n                if (typeof error == \"string\") {\r\n                    return this.exception.name == error;\r\n                }\r\n\r\n                return this.exception === error;\r\n            },\r\n\r\n            calledWithNew: function calledWithNew(thisValue) {\r\n                return this.thisValue instanceof this.proxy;\r\n            },\r\n\r\n            calledBefore: function (other) {\r\n                return this.callId < other.callId;\r\n            },\r\n\r\n            calledAfter: function (other) {\r\n                return this.callId > other.callId;\r\n            },\r\n\r\n            callArg: function (pos) {\r\n                this.args[pos]();\r\n            },\r\n\r\n            callArgOn: function (pos, thisValue) {\r\n                this.args[pos].apply(thisValue);\r\n            },\r\n\r\n            callArgWith: function (pos) {\r\n                this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));\r\n            },\r\n\r\n            callArgOnWith: function (pos, thisValue) {\r\n                var args = slice.call(arguments, 2);\r\n                this.args[pos].apply(thisValue, args);\r\n            },\r\n\r\n            \"yield\": function () {\r\n                this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));\r\n            },\r\n\r\n            yieldOn: function (thisValue) {\r\n                var args = this.args;\r\n                for (var i = 0, l = args.length; i < l; ++i) {\r\n                    if (typeof args[i] === \"function\") {\r\n                        args[i].apply(thisValue, slice.call(arguments, 1));\r\n                        return;\r\n                    }\r\n                }\r\n                throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\r\n            },\r\n\r\n            yieldTo: function (prop) {\r\n                this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));\r\n            },\r\n\r\n            yieldToOn: function (prop, thisValue) {\r\n                var args = this.args;\r\n                for (var i = 0, l = args.length; i < l; ++i) {\r\n                    if (args[i] && typeof args[i][prop] === \"function\") {\r\n                        args[i][prop].apply(thisValue, slice.call(arguments, 2));\r\n                        return;\r\n                    }\r\n                }\r\n                throwYieldError(this.proxy, \" cannot yield to '\" + prop +\r\n                    \"' since no callback was passed.\", args);\r\n            },\r\n\r\n            toString: function () {\r\n                var callStr = this.proxy.toString() + \"(\";\r\n                var args = [];\r\n\r\n                for (var i = 0, l = this.args.length; i < l; ++i) {\r\n                    push.call(args, sinon.format(this.args[i]));\r\n                }\r\n\r\n                callStr = callStr + args.join(\", \") + \")\";\r\n\r\n                if (typeof this.returnValue != \"undefined\") {\r\n                    callStr += \" => \" + sinon.format(this.returnValue);\r\n                }\r\n\r\n                if (this.exception) {\r\n                    callStr += \" !\" + this.exception.name;\r\n\r\n                    if (this.exception.message) {\r\n                        callStr += \"(\" + this.exception.message + \")\";\r\n                    }\r\n                }\r\n\r\n                return callStr;\r\n            }\r\n        };\r\n        callApi.invokeCallback = callApi.yield;\r\n        return callApi;\r\n    }());\r\n\r\n    spy.spyCall = spyCall;\r\n\r\n    // This steps outside the module sandbox and will be removed\r\n    sinon.spyCall = spyCall;\r\n\r\n    if (commonJSModule) {\r\n        module.exports = spy;\r\n    } else {\r\n        sinon.spy = spy;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend spy.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Stub functions\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function stub(object, property, func) {\r\n        if (!!func && typeof func != \"function\") {\r\n            throw new TypeError(\"Custom stub should be function\");\r\n        }\r\n\r\n        var wrapper;\r\n\r\n        if (func) {\r\n            wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;\r\n        } else {\r\n            wrapper = stub.create();\r\n        }\r\n\r\n        if (!object && !property) {\r\n            return sinon.stub.create();\r\n        }\r\n\r\n        if (!property && !!object && typeof object == \"object\") {\r\n            for (var prop in object) {\r\n                if (typeof object[prop] === \"function\") {\r\n                    stub(object, prop);\r\n                }\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        return sinon.wrapMethod(object, property, wrapper);\r\n    }\r\n\r\n    function getChangingValue(stub, property) {\r\n        var index = stub.callCount - 1;\r\n        var values = stub[property];\r\n        var prop = index in values ? values[index] : values[values.length - 1];\r\n        stub[property + \"Last\"] = prop;\r\n\r\n        return prop;\r\n    }\r\n\r\n    function getCallback(stub, args) {\r\n        var callArgAt = getChangingValue(stub, \"callArgAts\");\r\n\r\n        if (callArgAt < 0) {\r\n            var callArgProp = getChangingValue(stub, \"callArgProps\");\r\n\r\n            for (var i = 0, l = args.length; i < l; ++i) {\r\n                if (!callArgProp && typeof args[i] == \"function\") {\r\n                    return args[i];\r\n                }\r\n\r\n                if (callArgProp && args[i] &&\r\n                    typeof args[i][callArgProp] == \"function\") {\r\n                    return args[i][callArgProp];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        return args[callArgAt];\r\n    }\r\n\r\n    var join = Array.prototype.join;\r\n\r\n    function getCallbackError(stub, func, args) {\r\n        if (stub.callArgAtsLast < 0) {\r\n            var msg;\r\n\r\n            if (stub.callArgPropsLast) {\r\n                msg = sinon.functionName(stub) +\r\n                    \" expected to yield to '\" + stub.callArgPropsLast +\r\n                    \"', but no object with such a property was passed.\"\r\n            } else {\r\n                msg = sinon.functionName(stub) +\r\n                            \" expected to yield, but no callback was passed.\"\r\n            }\r\n\r\n            if (args.length > 0) {\r\n                msg += \" Received [\" + join.call(args, \", \") + \"]\";\r\n            }\r\n\r\n            return msg;\r\n        }\r\n\r\n        return \"argument at index \" + stub.callArgAtsLast + \" is not a function: \" + func;\r\n    }\r\n\r\n    var nextTick = (function () {\r\n        if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\r\n            return process.nextTick;\r\n        } else if (typeof setImmediate === \"function\") {\r\n            return setImmediate;\r\n        } else {\r\n            return function (callback) {\r\n                setTimeout(callback, 0);\r\n            };\r\n        }\r\n    })();\r\n\r\n    function callCallback(stub, args) {\r\n        if (stub.callArgAts.length > 0) {\r\n            var func = getCallback(stub, args);\r\n\r\n            if (typeof func != \"function\") {\r\n                throw new TypeError(getCallbackError(stub, func, args));\r\n            }\r\n\r\n            var callbackArguments = getChangingValue(stub, \"callbackArguments\");\r\n            var callbackContext = getChangingValue(stub, \"callbackContexts\");\r\n\r\n            if (stub.callbackAsync) {\r\n                nextTick(function() {\r\n                    func.apply(callbackContext, callbackArguments);\r\n                });\r\n            } else {\r\n                func.apply(callbackContext, callbackArguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    var uuid = 0;\r\n\r\n    sinon.extend(stub, (function () {\r\n        var slice = Array.prototype.slice, proto;\r\n\r\n        function throwsException(error, message) {\r\n            if (typeof error == \"string\") {\r\n                this.exception = new Error(message || \"\");\r\n                this.exception.name = error;\r\n            } else if (!error) {\r\n                this.exception = new Error(\"Error\");\r\n            } else {\r\n                this.exception = error;\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        proto = {\r\n            create: function create() {\r\n                var functionStub = function () {\r\n\r\n                    callCallback(functionStub, arguments);\r\n\r\n                    if (functionStub.exception) {\r\n                        throw functionStub.exception;\r\n                    } else if (typeof functionStub.returnArgAt == 'number') {\r\n                        return arguments[functionStub.returnArgAt];\r\n                    } else if (functionStub.returnThis) {\r\n                        return this;\r\n                    }\r\n                    return functionStub.returnValue;\r\n                };\r\n\r\n                functionStub.id = \"stub#\" + uuid++;\r\n                var orig = functionStub;\r\n                functionStub = sinon.spy.create(functionStub);\r\n                functionStub.func = orig;\r\n\r\n                functionStub.callArgAts = [];\r\n                functionStub.callbackArguments = [];\r\n                functionStub.callbackContexts = [];\r\n                functionStub.callArgProps = [];\r\n\r\n                sinon.extend(functionStub, stub);\r\n                functionStub._create = sinon.stub.create;\r\n                functionStub.displayName = \"stub\";\r\n                functionStub.toString = sinon.functionToString;\r\n\r\n                return functionStub;\r\n            },\r\n\r\n            resetBehavior: function () {\r\n                var i;\r\n\r\n                this.callArgAts = [];\r\n                this.callbackArguments = [];\r\n                this.callbackContexts = [];\r\n                this.callArgProps = [];\r\n\r\n                delete this.returnValue;\r\n                delete this.returnArgAt;\r\n                this.returnThis = false;\r\n\r\n                if (this.fakes) {\r\n                    for (i = 0; i < this.fakes.length; i++) {\r\n                        this.fakes[i].resetBehavior();\r\n                    }\r\n                }\r\n            },\r\n\r\n            returns: function returns(value) {\r\n                this.returnValue = value;\r\n\r\n                return this;\r\n            },\r\n\r\n            returnsArg: function returnsArg(pos) {\r\n                if (typeof pos != \"number\") {\r\n                    throw new TypeError(\"argument index is not number\");\r\n                }\r\n\r\n                this.returnArgAt = pos;\r\n\r\n                return this;\r\n            },\r\n\r\n            returnsThis: function returnsThis() {\r\n                this.returnThis = true;\r\n\r\n                return this;\r\n            },\r\n\r\n            \"throws\": throwsException,\r\n            throwsException: throwsException,\r\n\r\n            callsArg: function callsArg(pos) {\r\n                if (typeof pos != \"number\") {\r\n                    throw new TypeError(\"argument index is not number\");\r\n                }\r\n\r\n                this.callArgAts.push(pos);\r\n                this.callbackArguments.push([]);\r\n                this.callbackContexts.push(undefined);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            callsArgOn: function callsArgOn(pos, context) {\r\n                if (typeof pos != \"number\") {\r\n                    throw new TypeError(\"argument index is not number\");\r\n                }\r\n                if (typeof context != \"object\") {\r\n                    throw new TypeError(\"argument context is not an object\");\r\n                }\r\n\r\n                this.callArgAts.push(pos);\r\n                this.callbackArguments.push([]);\r\n                this.callbackContexts.push(context);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            callsArgWith: function callsArgWith(pos) {\r\n                if (typeof pos != \"number\") {\r\n                    throw new TypeError(\"argument index is not number\");\r\n                }\r\n\r\n                this.callArgAts.push(pos);\r\n                this.callbackArguments.push(slice.call(arguments, 1));\r\n                this.callbackContexts.push(undefined);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            callsArgOnWith: function callsArgWith(pos, context) {\r\n                if (typeof pos != \"number\") {\r\n                    throw new TypeError(\"argument index is not number\");\r\n                }\r\n                if (typeof context != \"object\") {\r\n                    throw new TypeError(\"argument context is not an object\");\r\n                }\r\n\r\n                this.callArgAts.push(pos);\r\n                this.callbackArguments.push(slice.call(arguments, 2));\r\n                this.callbackContexts.push(context);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            yields: function () {\r\n                this.callArgAts.push(-1);\r\n                this.callbackArguments.push(slice.call(arguments, 0));\r\n                this.callbackContexts.push(undefined);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            yieldsOn: function (context) {\r\n                if (typeof context != \"object\") {\r\n                    throw new TypeError(\"argument context is not an object\");\r\n                }\r\n\r\n                this.callArgAts.push(-1);\r\n                this.callbackArguments.push(slice.call(arguments, 1));\r\n                this.callbackContexts.push(context);\r\n                this.callArgProps.push(undefined);\r\n\r\n                return this;\r\n            },\r\n\r\n            yieldsTo: function (prop) {\r\n                this.callArgAts.push(-1);\r\n                this.callbackArguments.push(slice.call(arguments, 1));\r\n                this.callbackContexts.push(undefined);\r\n                this.callArgProps.push(prop);\r\n\r\n                return this;\r\n            },\r\n\r\n            yieldsToOn: function (prop, context) {\r\n                if (typeof context != \"object\") {\r\n                    throw new TypeError(\"argument context is not an object\");\r\n                }\r\n\r\n                this.callArgAts.push(-1);\r\n                this.callbackArguments.push(slice.call(arguments, 2));\r\n                this.callbackContexts.push(context);\r\n                this.callArgProps.push(prop);\r\n\r\n                return this;\r\n            }\r\n        };\r\n\r\n        // create asynchronous versions of callsArg* and yields* methods\r\n        for (var method in proto) {\r\n            // need to avoid creating anotherasync versions of the newly added async methods\r\n            if (proto.hasOwnProperty(method) &&\r\n                method.match(/^(callsArg|yields|thenYields$)/) &&\r\n                !method.match(/Async/)) {\r\n                proto[method + 'Async'] = (function (syncFnName) {\r\n                    return function () {\r\n                        this.callbackAsync = true;\r\n                        return this[syncFnName].apply(this, arguments);\r\n                    };\r\n                })(method);\r\n            }\r\n        }\r\n\r\n        return proto;\r\n\r\n    }()));\r\n\r\n    if (commonJSModule) {\r\n        module.exports = stub;\r\n    } else {\r\n        sinon.stub = stub;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend stub.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, nomen: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Mock functions.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n    var push = [].push;\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function mock(object) {\r\n        if (!object) {\r\n            return sinon.expectation.create(\"Anonymous mock\");\r\n        }\r\n\r\n        return mock.create(object);\r\n    }\r\n\r\n    sinon.mock = mock;\r\n\r\n    sinon.extend(mock, (function () {\r\n        function each(collection, callback) {\r\n            if (!collection) {\r\n                return;\r\n            }\r\n\r\n            for (var i = 0, l = collection.length; i < l; i += 1) {\r\n                callback(collection[i]);\r\n            }\r\n        }\r\n\r\n        return {\r\n            create: function create(object) {\r\n                if (!object) {\r\n                    throw new TypeError(\"object is null\");\r\n                }\r\n\r\n                var mockObject = sinon.extend({}, mock);\r\n                mockObject.object = object;\r\n                delete mockObject.create;\r\n\r\n                return mockObject;\r\n            },\r\n\r\n            expects: function expects(method) {\r\n                if (!method) {\r\n                    throw new TypeError(\"method is falsy\");\r\n                }\r\n\r\n                if (!this.expectations) {\r\n                    this.expectations = {};\r\n                    this.proxies = [];\r\n                }\r\n\r\n                if (!this.expectations[method]) {\r\n                    this.expectations[method] = [];\r\n                    var mockObject = this;\r\n\r\n                    sinon.wrapMethod(this.object, method, function () {\r\n                        return mockObject.invokeMethod(method, this, arguments);\r\n                    });\r\n\r\n                    push.call(this.proxies, method);\r\n                }\r\n\r\n                var expectation = sinon.expectation.create(method);\r\n                push.call(this.expectations[method], expectation);\r\n\r\n                return expectation;\r\n            },\r\n\r\n            restore: function restore() {\r\n                var object = this.object;\r\n\r\n                each(this.proxies, function (proxy) {\r\n                    if (typeof object[proxy].restore == \"function\") {\r\n                        object[proxy].restore();\r\n                    }\r\n                });\r\n            },\r\n\r\n            verify: function verify() {\r\n                var expectations = this.expectations || {};\r\n                var messages = [], met = [];\r\n\r\n                each(this.proxies, function (proxy) {\r\n                    each(expectations[proxy], function (expectation) {\r\n                        if (!expectation.met()) {\r\n                            push.call(messages, expectation.toString());\r\n                        } else {\r\n                            push.call(met, expectation.toString());\r\n                        }\r\n                    });\r\n                });\r\n\r\n                this.restore();\r\n\r\n                if (messages.length > 0) {\r\n                    sinon.expectation.fail(messages.concat(met).join(\"\\n\"));\r\n                } else {\r\n                    sinon.expectation.pass(messages.concat(met).join(\"\\n\"));\r\n                }\r\n\r\n                return true;\r\n            },\r\n\r\n            invokeMethod: function invokeMethod(method, thisValue, args) {\r\n                var expectations = this.expectations && this.expectations[method];\r\n                var length = expectations && expectations.length || 0, i;\r\n\r\n                for (i = 0; i < length; i += 1) {\r\n                    if (!expectations[i].met() &&\r\n                        expectations[i].allowsCall(thisValue, args)) {\r\n                        return expectations[i].apply(thisValue, args);\r\n                    }\r\n                }\r\n\r\n                var messages = [], available, exhausted = 0;\r\n\r\n                for (i = 0; i < length; i += 1) {\r\n                    if (expectations[i].allowsCall(thisValue, args)) {\r\n                        available = available || expectations[i];\r\n                    } else {\r\n                        exhausted += 1;\r\n                    }\r\n                    push.call(messages, \"    \" + expectations[i].toString());\r\n                }\r\n\r\n                if (exhausted === 0) {\r\n                    return available.apply(thisValue, args);\r\n                }\r\n\r\n                messages.unshift(\"Unexpected call: \" + sinon.spyCall.toString.call({\r\n                    proxy: method,\r\n                    args: args\r\n                }));\r\n\r\n                sinon.expectation.fail(messages.join(\"\\n\"));\r\n            }\r\n        };\r\n    }()));\r\n\r\n    var times = sinon.timesInWords;\r\n\r\n    sinon.expectation = (function () {\r\n        var slice = Array.prototype.slice;\r\n        var _invoke = sinon.spy.invoke;\r\n\r\n        function callCountInWords(callCount) {\r\n            if (callCount == 0) {\r\n                return \"never called\";\r\n            } else {\r\n                return \"called \" + times(callCount);\r\n            }\r\n        }\r\n\r\n        function expectedCallCountInWords(expectation) {\r\n            var min = expectation.minCalls;\r\n            var max = expectation.maxCalls;\r\n\r\n            if (typeof min == \"number\" && typeof max == \"number\") {\r\n                var str = times(min);\r\n\r\n                if (min != max) {\r\n                    str = \"at least \" + str + \" and at most \" + times(max);\r\n                }\r\n\r\n                return str;\r\n            }\r\n\r\n            if (typeof min == \"number\") {\r\n                return \"at least \" + times(min);\r\n            }\r\n\r\n            return \"at most \" + times(max);\r\n        }\r\n\r\n        function receivedMinCalls(expectation) {\r\n            var hasMinLimit = typeof expectation.minCalls == \"number\";\r\n            return !hasMinLimit || expectation.callCount >= expectation.minCalls;\r\n        }\r\n\r\n        function receivedMaxCalls(expectation) {\r\n            if (typeof expectation.maxCalls != \"number\") {\r\n                return false;\r\n            }\r\n\r\n            return expectation.callCount == expectation.maxCalls;\r\n        }\r\n\r\n        return {\r\n            minCalls: 1,\r\n            maxCalls: 1,\r\n\r\n            create: function create(methodName) {\r\n                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);\r\n                delete expectation.create;\r\n                expectation.method = methodName;\r\n\r\n                return expectation;\r\n            },\r\n\r\n            invoke: function invoke(func, thisValue, args) {\r\n                this.verifyCallAllowed(thisValue, args);\r\n\r\n                return _invoke.apply(this, arguments);\r\n            },\r\n\r\n            atLeast: function atLeast(num) {\r\n                if (typeof num != \"number\") {\r\n                    throw new TypeError(\"'\" + num + \"' is not number\");\r\n                }\r\n\r\n                if (!this.limitsSet) {\r\n                    this.maxCalls = null;\r\n                    this.limitsSet = true;\r\n                }\r\n\r\n                this.minCalls = num;\r\n\r\n                return this;\r\n            },\r\n\r\n            atMost: function atMost(num) {\r\n                if (typeof num != \"number\") {\r\n                    throw new TypeError(\"'\" + num + \"' is not number\");\r\n                }\r\n\r\n                if (!this.limitsSet) {\r\n                    this.minCalls = null;\r\n                    this.limitsSet = true;\r\n                }\r\n\r\n                this.maxCalls = num;\r\n\r\n                return this;\r\n            },\r\n\r\n            never: function never() {\r\n                return this.exactly(0);\r\n            },\r\n\r\n            once: function once() {\r\n                return this.exactly(1);\r\n            },\r\n\r\n            twice: function twice() {\r\n                return this.exactly(2);\r\n            },\r\n\r\n            thrice: function thrice() {\r\n                return this.exactly(3);\r\n            },\r\n\r\n            exactly: function exactly(num) {\r\n                if (typeof num != \"number\") {\r\n                    throw new TypeError(\"'\" + num + \"' is not a number\");\r\n                }\r\n\r\n                this.atLeast(num);\r\n                return this.atMost(num);\r\n            },\r\n\r\n            met: function met() {\r\n                return !this.failed && receivedMinCalls(this);\r\n            },\r\n\r\n            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\r\n                if (receivedMaxCalls(this)) {\r\n                    this.failed = true;\r\n                    sinon.expectation.fail(this.method + \" already called \" + times(this.maxCalls));\r\n                }\r\n\r\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\r\n                    sinon.expectation.fail(this.method + \" called with \" + thisValue + \" as thisValue, expected \" +\r\n                        this.expectedThis);\r\n                }\r\n\r\n                if (!(\"expectedArguments\" in this)) {\r\n                    return;\r\n                }\r\n\r\n                if (!args) {\r\n                    sinon.expectation.fail(this.method + \" received no arguments, expected \" +\r\n                        sinon.format(this.expectedArguments));\r\n                }\r\n\r\n                if (args.length < this.expectedArguments.length) {\r\n                    sinon.expectation.fail(this.method + \" received too few arguments (\" + sinon.format(args) +\r\n                        \"), expected \" + sinon.format(this.expectedArguments));\r\n                }\r\n\r\n                if (this.expectsExactArgCount &&\r\n                    args.length != this.expectedArguments.length) {\r\n                    sinon.expectation.fail(this.method + \" received too many arguments (\" + sinon.format(args) +\r\n                        \"), expected \" + sinon.format(this.expectedArguments));\r\n                }\r\n\r\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\r\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\r\n                        sinon.expectation.fail(this.method + \" received wrong arguments \" + sinon.format(args) +\r\n                            \", expected \" + sinon.format(this.expectedArguments));\r\n                    }\r\n                }\r\n            },\r\n\r\n            allowsCall: function allowsCall(thisValue, args) {\r\n                if (this.met() && receivedMaxCalls(this)) {\r\n                    return false;\r\n                }\r\n\r\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\r\n                    return false;\r\n                }\r\n\r\n                if (!(\"expectedArguments\" in this)) {\r\n                    return true;\r\n                }\r\n\r\n                args = args || [];\r\n\r\n                if (args.length < this.expectedArguments.length) {\r\n                    return false;\r\n                }\r\n\r\n                if (this.expectsExactArgCount &&\r\n                    args.length != this.expectedArguments.length) {\r\n                    return false;\r\n                }\r\n\r\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\r\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            },\r\n\r\n            withArgs: function withArgs() {\r\n                this.expectedArguments = slice.call(arguments);\r\n                return this;\r\n            },\r\n\r\n            withExactArgs: function withExactArgs() {\r\n                this.withArgs.apply(this, arguments);\r\n                this.expectsExactArgCount = true;\r\n                return this;\r\n            },\r\n\r\n            on: function on(thisValue) {\r\n                this.expectedThis = thisValue;\r\n                return this;\r\n            },\r\n\r\n            toString: function () {\r\n                var args = (this.expectedArguments || []).slice();\r\n\r\n                if (!this.expectsExactArgCount) {\r\n                    push.call(args, \"[...]\");\r\n                }\r\n\r\n                var callStr = sinon.spyCall.toString.call({\r\n                    proxy: this.method || \"anonymous mock expectation\",\r\n                    args: args\r\n                });\r\n\r\n                var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\r\n                    expectedCallCountInWords(this);\r\n\r\n                if (this.met()) {\r\n                    return \"Expectation met: \" + message;\r\n                }\r\n\r\n                return \"Expected \" + message + \" (\" +\r\n                    callCountInWords(this.callCount) + \")\";\r\n            },\r\n\r\n            verify: function verify() {\r\n                if (!this.met()) {\r\n                    sinon.expectation.fail(this.toString());\r\n                } else {\r\n                    sinon.expectation.pass(this.toString());\r\n                }\r\n\r\n                return true;\r\n            },\r\n\r\n            pass: function(message) {\r\n              sinon.assert.pass(message);\r\n            },\r\n            fail: function (message) {\r\n                var exception = new Error(message);\r\n                exception.name = \"ExpectationError\";\r\n\r\n                throw exception;\r\n            }\r\n        };\r\n    }());\r\n\r\n    if (commonJSModule) {\r\n        module.exports = mock;\r\n    } else {\r\n        sinon.mock = mock;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend stub.js\r\n * @depend mock.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, forin: true*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Collections of stubs, spies and mocks.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n    var push = [].push;\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function getFakes(fakeCollection) {\r\n        if (!fakeCollection.fakes) {\r\n            fakeCollection.fakes = [];\r\n        }\r\n\r\n        return fakeCollection.fakes;\r\n    }\r\n\r\n    function each(fakeCollection, method) {\r\n        var fakes = getFakes(fakeCollection);\r\n\r\n        for (var i = 0, l = fakes.length; i < l; i += 1) {\r\n            if (typeof fakes[i][method] == \"function\") {\r\n                fakes[i][method]();\r\n            }\r\n        }\r\n    }\r\n\r\n    function compact(fakeCollection) {\r\n        var fakes = getFakes(fakeCollection);\r\n        var i = 0;\r\n        while (i < fakes.length) {\r\n          fakes.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    var collection = {\r\n        verify: function resolve() {\r\n            each(this, \"verify\");\r\n        },\r\n\r\n        restore: function restore() {\r\n            each(this, \"restore\");\r\n            compact(this);\r\n        },\r\n\r\n        verifyAndRestore: function verifyAndRestore() {\r\n            var exception;\r\n\r\n            try {\r\n                this.verify();\r\n            } catch (e) {\r\n                exception = e;\r\n            }\r\n\r\n            this.restore();\r\n\r\n            if (exception) {\r\n                throw exception;\r\n            }\r\n        },\r\n\r\n        add: function add(fake) {\r\n            push.call(getFakes(this), fake);\r\n            return fake;\r\n        },\r\n\r\n        spy: function spy() {\r\n            return this.add(sinon.spy.apply(sinon, arguments));\r\n        },\r\n\r\n        stub: function stub(object, property, value) {\r\n            if (property) {\r\n                var original = object[property];\r\n\r\n                if (typeof original != \"function\") {\r\n                    if (!hasOwnProperty.call(object, property)) {\r\n                        throw new TypeError(\"Cannot stub non-existent own property \" + property);\r\n                    }\r\n\r\n                    object[property] = value;\r\n\r\n                    return this.add({\r\n                        restore: function () {\r\n                            object[property] = original;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (!property && !!object && typeof object == \"object\") {\r\n                var stubbedObj = sinon.stub.apply(sinon, arguments);\r\n\r\n                for (var prop in stubbedObj) {\r\n                    if (typeof stubbedObj[prop] === \"function\") {\r\n                        this.add(stubbedObj[prop]);\r\n                    }\r\n                }\r\n\r\n                return stubbedObj;\r\n            }\r\n\r\n            return this.add(sinon.stub.apply(sinon, arguments));\r\n        },\r\n\r\n        mock: function mock() {\r\n            return this.add(sinon.mock.apply(sinon, arguments));\r\n        },\r\n\r\n        inject: function inject(obj) {\r\n            var col = this;\r\n\r\n            obj.spy = function () {\r\n                return col.spy.apply(col, arguments);\r\n            };\r\n\r\n            obj.stub = function () {\r\n                return col.stub.apply(col, arguments);\r\n            };\r\n\r\n            obj.mock = function () {\r\n                return col.mock.apply(col, arguments);\r\n            };\r\n\r\n            return obj;\r\n        }\r\n    };\r\n\r\n    if (commonJSModule) {\r\n        module.exports = collection;\r\n    } else {\r\n        sinon.collection = collection;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/\r\n/*global module, require, window*/\r\n/**\r\n * Fake timer API\r\n * setTimeout\r\n * setInterval\r\n * clearTimeout\r\n * clearInterval\r\n * tick\r\n * reset\r\n * Date\r\n *\r\n * Inspired by jsUnitMockTimeOut from JsUnit\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\nif (typeof sinon == \"undefined\") {\r\n    var sinon = {};\r\n}\r\n\r\n(function (global) {\r\n    var id = 1;\r\n\r\n    function addTimer(args, recurring) {\r\n        if (args.length === 0) {\r\n            throw new Error(\"Function requires at least 1 parameter\");\r\n        }\r\n\r\n        var toId = id++;\r\n        var delay = args[1] || 0;\r\n\r\n        if (!this.timeouts) {\r\n            this.timeouts = {};\r\n        }\r\n\r\n        this.timeouts[toId] = {\r\n            id: toId,\r\n            func: args[0],\r\n            callAt: this.now + delay,\r\n            invokeArgs: Array.prototype.slice.call(args, 2)\r\n        };\r\n\r\n        if (recurring === true) {\r\n            this.timeouts[toId].interval = delay;\r\n        }\r\n\r\n        return toId;\r\n    }\r\n\r\n    function parseTime(str) {\r\n        if (!str) {\r\n            return 0;\r\n        }\r\n\r\n        var strings = str.split(\":\");\r\n        var l = strings.length, i = l;\r\n        var ms = 0, parsed;\r\n\r\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\r\n            throw new Error(\"tick only understands numbers and 'h:m:s'\");\r\n        }\r\n\r\n        while (i--) {\r\n            parsed = parseInt(strings[i], 10);\r\n\r\n            if (parsed >= 60) {\r\n                throw new Error(\"Invalid time \" + str);\r\n            }\r\n\r\n            ms += parsed * Math.pow(60, (l - i - 1));\r\n        }\r\n\r\n        return ms * 1000;\r\n    }\r\n\r\n    function createObject(object) {\r\n        var newObject;\r\n\r\n        if (Object.create) {\r\n            newObject = Object.create(object);\r\n        } else {\r\n            var F = function () {};\r\n            F.prototype = object;\r\n            newObject = new F();\r\n        }\r\n\r\n        newObject.Date.clock = newObject;\r\n        return newObject;\r\n    }\r\n\r\n    sinon.clock = {\r\n        now: 0,\r\n\r\n        create: function create(now) {\r\n            var clock = createObject(this);\r\n\r\n            if (typeof now == \"number\") {\r\n                clock.now = now;\r\n            }\r\n\r\n            if (!!now && typeof now == \"object\") {\r\n                throw new TypeError(\"now should be milliseconds since UNIX epoch\");\r\n            }\r\n\r\n            return clock;\r\n        },\r\n\r\n        setTimeout: function setTimeout(callback, timeout) {\r\n            return addTimer.call(this, arguments, false);\r\n        },\r\n\r\n        clearTimeout: function clearTimeout(timerId) {\r\n            if (!this.timeouts) {\r\n                this.timeouts = [];\r\n            }\r\n\r\n            if (timerId in this.timeouts) {\r\n                delete this.timeouts[timerId];\r\n            }\r\n        },\r\n\r\n        setInterval: function setInterval(callback, timeout) {\r\n            return addTimer.call(this, arguments, true);\r\n        },\r\n\r\n        clearInterval: function clearInterval(timerId) {\r\n            this.clearTimeout(timerId);\r\n        },\r\n\r\n        tick: function tick(ms) {\r\n            ms = typeof ms == \"number\" ? ms : parseTime(ms);\r\n            var tickFrom = this.now, tickTo = this.now + ms, previous = this.now;\r\n            var timer = this.firstTimerInRange(tickFrom, tickTo);\r\n\r\n            var firstException;\r\n            while (timer && tickFrom <= tickTo) {\r\n                if (this.timeouts[timer.id]) {\r\n                    tickFrom = this.now = timer.callAt;\r\n                    try {\r\n                      this.callTimer(timer);\r\n                    } catch (e) {\r\n                      firstException = firstException || e;\r\n                    }\r\n                }\r\n\r\n                timer = this.firstTimerInRange(previous, tickTo);\r\n                previous = tickFrom;\r\n            }\r\n\r\n            this.now = tickTo;\r\n\r\n            if (firstException) {\r\n              throw firstException;\r\n            }\r\n\r\n            return this.now;\r\n        },\r\n\r\n        firstTimerInRange: function (from, to) {\r\n            var timer, smallest, originalTimer;\r\n\r\n            for (var id in this.timeouts) {\r\n                if (this.timeouts.hasOwnProperty(id)) {\r\n                    if (this.timeouts[id].callAt < from || this.timeouts[id].callAt > to) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!smallest || this.timeouts[id].callAt < smallest) {\r\n                        originalTimer = this.timeouts[id];\r\n                        smallest = this.timeouts[id].callAt;\r\n\r\n                        timer = {\r\n                            func: this.timeouts[id].func,\r\n                            callAt: this.timeouts[id].callAt,\r\n                            interval: this.timeouts[id].interval,\r\n                            id: this.timeouts[id].id,\r\n                            invokeArgs: this.timeouts[id].invokeArgs\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            return timer || null;\r\n        },\r\n\r\n        callTimer: function (timer) {\r\n            if (typeof timer.interval == \"number\") {\r\n                this.timeouts[timer.id].callAt += timer.interval;\r\n            } else {\r\n                delete this.timeouts[timer.id];\r\n            }\r\n\r\n            try {\r\n                if (typeof timer.func == \"function\") {\r\n                    timer.func.apply(null, timer.invokeArgs);\r\n                } else {\r\n                    eval(timer.func);\r\n                }\r\n            } catch (e) {\r\n              var exception = e;\r\n            }\r\n\r\n            if (!this.timeouts[timer.id]) {\r\n                if (exception) {\r\n                  throw exception;\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (exception) {\r\n              throw exception;\r\n            }\r\n        },\r\n\r\n        reset: function reset() {\r\n            this.timeouts = {};\r\n        },\r\n\r\n        Date: (function () {\r\n            var NativeDate = Date;\r\n\r\n            function ClockDate(year, month, date, hour, minute, second, ms) {\r\n                // Defensive and verbose to avoid potential harm in passing\r\n                // explicit undefined when user does not pass argument\r\n                switch (arguments.length) {\r\n                case 0:\r\n                    return new NativeDate(ClockDate.clock.now);\r\n                case 1:\r\n                    return new NativeDate(year);\r\n                case 2:\r\n                    return new NativeDate(year, month);\r\n                case 3:\r\n                    return new NativeDate(year, month, date);\r\n                case 4:\r\n                    return new NativeDate(year, month, date, hour);\r\n                case 5:\r\n                    return new NativeDate(year, month, date, hour, minute);\r\n                case 6:\r\n                    return new NativeDate(year, month, date, hour, minute, second);\r\n                default:\r\n                    return new NativeDate(year, month, date, hour, minute, second, ms);\r\n                }\r\n            }\r\n\r\n            return mirrorDateProperties(ClockDate, NativeDate);\r\n        }())\r\n    };\r\n\r\n    function mirrorDateProperties(target, source) {\r\n        if (source.now) {\r\n            target.now = function now() {\r\n                return target.clock.now;\r\n            };\r\n        } else {\r\n            delete target.now;\r\n        }\r\n\r\n        if (source.toSource) {\r\n            target.toSource = function toSource() {\r\n                return source.toSource();\r\n            };\r\n        } else {\r\n            delete target.toSource;\r\n        }\r\n\r\n        target.toString = function toString() {\r\n            return source.toString();\r\n        };\r\n\r\n        target.prototype = source.prototype;\r\n        target.parse = source.parse;\r\n        target.UTC = source.UTC;\r\n        target.prototype.toUTCString = source.prototype.toUTCString;\r\n        return target;\r\n    }\r\n\r\n    var methods = [\"Date\", \"setTimeout\", \"setInterval\",\r\n                   \"clearTimeout\", \"clearInterval\"];\r\n\r\n    function restore() {\r\n        var method;\r\n\r\n        for (var i = 0, l = this.methods.length; i < l; i++) {\r\n            method = this.methods[i];\r\n            if (global[method].hadOwnProperty) {\r\n                global[method] = this[\"_\" + method];\r\n            } else {\r\n                delete global[method];\r\n            }\r\n        }\r\n\r\n        // Prevent multiple executions which will completely remove these props\r\n        this.methods = [];\r\n    }\r\n\r\n    function stubGlobal(method, clock) {\r\n        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(global, method);\r\n        clock[\"_\" + method] = global[method];\r\n\r\n        if (method == \"Date\") {\r\n            var date = mirrorDateProperties(clock[method], global[method]);\r\n            global[method] = date;\r\n        } else {\r\n            global[method] = function () {\r\n                return clock[method].apply(clock, arguments);\r\n            };\r\n\r\n            for (var prop in clock[method]) {\r\n                if (clock[method].hasOwnProperty(prop)) {\r\n                    global[method][prop] = clock[method][prop];\r\n                }\r\n            }\r\n        }\r\n\r\n        global[method].clock = clock;\r\n    }\r\n\r\n    sinon.useFakeTimers = function useFakeTimers(now) {\r\n        var clock = sinon.clock.create(now);\r\n        clock.restore = restore;\r\n        clock.methods = Array.prototype.slice.call(arguments,\r\n                                                   typeof now == \"number\" ? 1 : 0);\r\n\r\n        if (clock.methods.length === 0) {\r\n            clock.methods = methods;\r\n        }\r\n\r\n        for (var i = 0, l = clock.methods.length; i < l; i++) {\r\n            stubGlobal(clock.methods[i], clock);\r\n        }\r\n\r\n        return clock;\r\n    };\r\n}(typeof global != \"undefined\" && typeof global !== \"function\" ? global : this));\r\n\r\nsinon.timers = {\r\n    setTimeout: setTimeout,\r\n    clearTimeout: clearTimeout,\r\n    setInterval: setInterval,\r\n    clearInterval: clearInterval,\r\n    Date: Date\r\n};\r\n\r\nif (typeof module == \"object\" && typeof require == \"function\") {\r\n    module.exports = sinon;\r\n}\r\n\r\n/*jslint eqeqeq: false, onevar: false*/\r\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\r\n/**\r\n * Minimal Event interface implementation\r\n *\r\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\r\n * Modifications and tests by Christian Johansen.\r\n *\r\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\r\n */\r\n\r\nif (typeof sinon == \"undefined\") {\r\n    this.sinon = {};\r\n}\r\n\r\n(function () {\r\n    var push = [].push;\r\n\r\n    sinon.Event = function Event(type, bubbles, cancelable) {\r\n        this.initEvent(type, bubbles, cancelable);\r\n    };\r\n\r\n    sinon.Event.prototype = {\r\n        initEvent: function(type, bubbles, cancelable) {\r\n            this.type = type;\r\n            this.bubbles = bubbles;\r\n            this.cancelable = cancelable;\r\n        },\r\n\r\n        stopPropagation: function () {},\r\n\r\n        preventDefault: function () {\r\n            this.defaultPrevented = true;\r\n        }\r\n    };\r\n\r\n    sinon.EventTarget = {\r\n        addEventListener: function addEventListener(event, listener, useCapture) {\r\n            this.eventListeners = this.eventListeners || {};\r\n            this.eventListeners[event] = this.eventListeners[event] || [];\r\n            push.call(this.eventListeners[event], listener);\r\n        },\r\n\r\n        removeEventListener: function removeEventListener(event, listener, useCapture) {\r\n            var listeners = this.eventListeners && this.eventListeners[event] || [];\r\n\r\n            for (var i = 0, l = listeners.length; i < l; ++i) {\r\n                if (listeners[i] == listener) {\r\n                    return listeners.splice(i, 1);\r\n                }\r\n            }\r\n        },\r\n\r\n        dispatchEvent: function dispatchEvent(event) {\r\n            var type = event.type;\r\n            var listeners = this.eventListeners && this.eventListeners[type] || [];\r\n\r\n            for (var i = 0; i < listeners.length; i++) {\r\n                if (typeof listeners[i] == \"function\") {\r\n                    listeners[i].call(this, event);\r\n                } else {\r\n                    listeners[i].handleEvent(event);\r\n                }\r\n            }\r\n\r\n            return !!event.defaultPrevented;\r\n        }\r\n    };\r\n}());\r\n\r\n/**\r\n * @depend ../../sinon.js\r\n * @depend event.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false*/\r\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\r\n/**\r\n * Fake XMLHttpRequest object\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\nif (typeof sinon == \"undefined\") {\r\n    this.sinon = {};\r\n}\r\nsinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };\r\n\r\n// wrapper for global\r\n(function(global) {\r\n    var xhr = sinon.xhr;\r\n    xhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\r\n    xhr.GlobalActiveXObject = global.ActiveXObject;\r\n    xhr.supportsActiveX = typeof xhr.GlobalActiveXObject != \"undefined\";\r\n    xhr.supportsXHR = typeof xhr.GlobalXMLHttpRequest != \"undefined\";\r\n    xhr.workingXHR = xhr.supportsXHR ? xhr.GlobalXMLHttpRequest : xhr.supportsActiveX\r\n                                     ? function() { return new xhr.GlobalActiveXObject(\"MSXML2.XMLHTTP.3.0\") } : false;\r\n\r\n    /*jsl:ignore*/\r\n    var unsafeHeaders = {\r\n        \"Accept-Charset\": true,\r\n        \"Accept-Encoding\": true,\r\n        \"Connection\": true,\r\n        \"Content-Length\": true,\r\n        \"Cookie\": true,\r\n        \"Cookie2\": true,\r\n        \"Content-Transfer-Encoding\": true,\r\n        \"Date\": true,\r\n        \"Expect\": true,\r\n        \"Host\": true,\r\n        \"Keep-Alive\": true,\r\n        \"Referer\": true,\r\n        \"TE\": true,\r\n        \"Trailer\": true,\r\n        \"Transfer-Encoding\": true,\r\n        \"Upgrade\": true,\r\n        \"User-Agent\": true,\r\n        \"Via\": true\r\n    };\r\n    /*jsl:end*/\r\n\r\n    function FakeXMLHttpRequest() {\r\n        this.readyState = FakeXMLHttpRequest.UNSENT;\r\n        this.requestHeaders = {};\r\n        this.requestBody = null;\r\n        this.status = 0;\r\n        this.statusText = \"\";\r\n\r\n        if (typeof FakeXMLHttpRequest.onCreate == \"function\") {\r\n            FakeXMLHttpRequest.onCreate(this);\r\n        }\r\n    }\r\n\r\n    function verifyState(xhr) {\r\n        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\r\n            throw new Error(\"INVALID_STATE_ERR\");\r\n        }\r\n\r\n        if (xhr.sendFlag) {\r\n            throw new Error(\"INVALID_STATE_ERR\");\r\n        }\r\n    }\r\n\r\n    // filtering to enable a white-list version of Sinon FakeXhr,\r\n    // where whitelisted requests are passed through to real XHR\r\n    function each(collection, callback) {\r\n        if (!collection) return;\r\n        for (var i = 0, l = collection.length; i < l; i += 1) {\r\n            callback(collection[i]);\r\n        }\r\n    }\r\n    function some(collection, callback) {\r\n        for (var index = 0; index < collection.length; index++) {\r\n            if(callback(collection[index]) === true) return true;\r\n        };\r\n        return false;\r\n    }\r\n    // largest arity in XHR is 5 - XHR#open\r\n    var apply = function(obj,method,args) {\r\n        switch(args.length) {\r\n        case 0: return obj[method]();\r\n        case 1: return obj[method](args[0]);\r\n        case 2: return obj[method](args[0],args[1]);\r\n        case 3: return obj[method](args[0],args[1],args[2]);\r\n        case 4: return obj[method](args[0],args[1],args[2],args[3]);\r\n        case 5: return obj[method](args[0],args[1],args[2],args[3],args[4]);\r\n        };\r\n    };\r\n\r\n    FakeXMLHttpRequest.filters = [];\r\n    FakeXMLHttpRequest.addFilter = function(fn) {\r\n        this.filters.push(fn)\r\n    };\r\n    var IE6Re = /MSIE 6/;\r\n    FakeXMLHttpRequest.defake = function(fakeXhr,xhrArgs) {\r\n        var xhr = new sinon.xhr.workingXHR();\r\n        each([\"open\",\"setRequestHeader\",\"send\",\"abort\",\"getResponseHeader\",\r\n              \"getAllResponseHeaders\",\"addEventListener\",\"overrideMimeType\",\"removeEventListener\"],\r\n             function(method) {\r\n                 fakeXhr[method] = function() {\r\n                   return apply(xhr,method,arguments);\r\n                 };\r\n             });\r\n\r\n        var copyAttrs = function(args) {\r\n            each(args, function(attr) {\r\n              try {\r\n                fakeXhr[attr] = xhr[attr]\r\n              } catch(e) {\r\n                if(!IE6Re.test(navigator.userAgent)) throw e;\r\n              }\r\n            });\r\n        };\r\n\r\n        var stateChange = function() {\r\n            fakeXhr.readyState = xhr.readyState;\r\n            if(xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\r\n                copyAttrs([\"status\",\"statusText\"]);\r\n            }\r\n            if(xhr.readyState >= FakeXMLHttpRequest.LOADING) {\r\n                copyAttrs([\"responseText\"]);\r\n            }\r\n            if(xhr.readyState === FakeXMLHttpRequest.DONE) {\r\n                copyAttrs([\"responseXML\"]);\r\n            }\r\n            if(fakeXhr.onreadystatechange) fakeXhr.onreadystatechange.call(fakeXhr);\r\n        };\r\n        if(xhr.addEventListener) {\r\n          for(var event in fakeXhr.eventListeners) {\r\n              if(fakeXhr.eventListeners.hasOwnProperty(event)) {\r\n                  each(fakeXhr.eventListeners[event],function(handler) {\r\n                      xhr.addEventListener(event, handler);\r\n                  });\r\n              }\r\n          }\r\n          xhr.addEventListener(\"readystatechange\",stateChange);\r\n        } else {\r\n          xhr.onreadystatechange = stateChange;\r\n        }\r\n        apply(xhr,\"open\",xhrArgs);\r\n    };\r\n    FakeXMLHttpRequest.useFilters = false;\r\n\r\n    function verifyRequestSent(xhr) {\r\n        if (xhr.readyState == FakeXMLHttpRequest.DONE) {\r\n            throw new Error(\"Request done\");\r\n        }\r\n    }\r\n\r\n    function verifyHeadersReceived(xhr) {\r\n        if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\r\n            throw new Error(\"No headers received\");\r\n        }\r\n    }\r\n\r\n    function verifyResponseBodyType(body) {\r\n        if (typeof body != \"string\") {\r\n            var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\r\n                                 body + \", which is not a string.\");\r\n            error.name = \"InvalidBodyException\";\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {\r\n        async: true,\r\n\r\n        open: function open(method, url, async, username, password) {\r\n            this.method = method;\r\n            this.url = url;\r\n            this.async = typeof async == \"boolean\" ? async : true;\r\n            this.username = username;\r\n            this.password = password;\r\n            this.responseText = null;\r\n            this.responseXML = null;\r\n            this.requestHeaders = {};\r\n            this.sendFlag = false;\r\n            if(sinon.FakeXMLHttpRequest.useFilters === true) {\r\n                var xhrArgs = arguments;\r\n                var defake = some(FakeXMLHttpRequest.filters,function(filter) {\r\n                    return filter.apply(this,xhrArgs)\r\n                });\r\n                if (defake) {\r\n                  return sinon.FakeXMLHttpRequest.defake(this,arguments);\r\n                }\r\n            }\r\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\r\n        },\r\n\r\n        readyStateChange: function readyStateChange(state) {\r\n            this.readyState = state;\r\n\r\n            if (typeof this.onreadystatechange == \"function\") {\r\n                try {\r\n                    this.onreadystatechange();\r\n                } catch (e) {\r\n                    sinon.logError(\"Fake XHR onreadystatechange handler\", e);\r\n                }\r\n            }\r\n\r\n            this.dispatchEvent(new sinon.Event(\"readystatechange\"));\r\n        },\r\n\r\n        setRequestHeader: function setRequestHeader(header, value) {\r\n            verifyState(this);\r\n\r\n            if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\r\n                throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\r\n            }\r\n\r\n            if (this.requestHeaders[header]) {\r\n                this.requestHeaders[header] += \",\" + value;\r\n            } else {\r\n                this.requestHeaders[header] = value;\r\n            }\r\n        },\r\n\r\n        // Helps testing\r\n        setResponseHeaders: function setResponseHeaders(headers) {\r\n            this.responseHeaders = {};\r\n\r\n            for (var header in headers) {\r\n                if (headers.hasOwnProperty(header)) {\r\n                    this.responseHeaders[header] = headers[header];\r\n                }\r\n            }\r\n\r\n            if (this.async) {\r\n                this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\r\n            } else {\r\n                this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\r\n            }\r\n        },\r\n\r\n        // Currently treats ALL data as a DOMString (i.e. no Document)\r\n        send: function send(data) {\r\n            verifyState(this);\r\n\r\n            if (!/^(get|head)$/i.test(this.method)) {\r\n                if (this.requestHeaders[\"Content-Type\"]) {\r\n                    var value = this.requestHeaders[\"Content-Type\"].split(\";\");\r\n                    this.requestHeaders[\"Content-Type\"] = value[0] + \";charset=utf-8\";\r\n                } else {\r\n                    this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\r\n                }\r\n\r\n                this.requestBody = data;\r\n            }\r\n\r\n            this.errorFlag = false;\r\n            this.sendFlag = this.async;\r\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\r\n\r\n            if (typeof this.onSend == \"function\") {\r\n                this.onSend(this);\r\n            }\r\n        },\r\n\r\n        abort: function abort() {\r\n            this.aborted = true;\r\n            this.responseText = null;\r\n            this.errorFlag = true;\r\n            this.requestHeaders = {};\r\n\r\n            if (this.readyState > sinon.FakeXMLHttpRequest.UNSENT && this.sendFlag) {\r\n                this.readyStateChange(sinon.FakeXMLHttpRequest.DONE);\r\n                this.sendFlag = false;\r\n            }\r\n\r\n            this.readyState = sinon.FakeXMLHttpRequest.UNSENT;\r\n        },\r\n\r\n        getResponseHeader: function getResponseHeader(header) {\r\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\r\n                return null;\r\n            }\r\n\r\n            if (/^Set-Cookie2?$/i.test(header)) {\r\n                return null;\r\n            }\r\n\r\n            header = header.toLowerCase();\r\n\r\n            for (var h in this.responseHeaders) {\r\n                if (h.toLowerCase() == header) {\r\n                    return this.responseHeaders[h];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        },\r\n\r\n        getAllResponseHeaders: function getAllResponseHeaders() {\r\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\r\n                return \"\";\r\n            }\r\n\r\n            var headers = \"\";\r\n\r\n            for (var header in this.responseHeaders) {\r\n                if (this.responseHeaders.hasOwnProperty(header) &&\r\n                    !/^Set-Cookie2?$/i.test(header)) {\r\n                    headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\r\n                }\r\n            }\r\n\r\n            return headers;\r\n        },\r\n\r\n        setResponseBody: function setResponseBody(body) {\r\n            verifyRequestSent(this);\r\n            verifyHeadersReceived(this);\r\n            verifyResponseBodyType(body);\r\n\r\n            var chunkSize = this.chunkSize || 10;\r\n            var index = 0;\r\n            this.responseText = \"\";\r\n\r\n            do {\r\n                if (this.async) {\r\n                    this.readyStateChange(FakeXMLHttpRequest.LOADING);\r\n                }\r\n\r\n                this.responseText += body.substring(index, index + chunkSize);\r\n                index += chunkSize;\r\n            } while (index < body.length);\r\n\r\n            var type = this.getResponseHeader(\"Content-Type\");\r\n\r\n            if (this.responseText &&\r\n                (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\r\n                try {\r\n                    this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\r\n                } catch (e) {\r\n                    // Unable to parse XML - no biggie\r\n                }\r\n            }\r\n\r\n            if (this.async) {\r\n                this.readyStateChange(FakeXMLHttpRequest.DONE);\r\n            } else {\r\n                this.readyState = FakeXMLHttpRequest.DONE;\r\n            }\r\n        },\r\n\r\n        respond: function respond(status, headers, body) {\r\n            this.setResponseHeaders(headers || {});\r\n            this.status = typeof status == \"number\" ? status : 200;\r\n            this.statusText = FakeXMLHttpRequest.statusCodes[this.status];\r\n            this.setResponseBody(body || \"\");\r\n        }\r\n    });\r\n\r\n    sinon.extend(FakeXMLHttpRequest, {\r\n        UNSENT: 0,\r\n        OPENED: 1,\r\n        HEADERS_RECEIVED: 2,\r\n        LOADING: 3,\r\n        DONE: 4\r\n    });\r\n\r\n    // Borrowed from JSpec\r\n    FakeXMLHttpRequest.parseXML = function parseXML(text) {\r\n        var xmlDoc;\r\n\r\n        if (typeof DOMParser != \"undefined\") {\r\n            var parser = new DOMParser();\r\n            xmlDoc = parser.parseFromString(text, \"text/xml\");\r\n        } else {\r\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\r\n            xmlDoc.async = \"false\";\r\n            xmlDoc.loadXML(text);\r\n        }\r\n\r\n        return xmlDoc;\r\n    };\r\n\r\n    FakeXMLHttpRequest.statusCodes = {\r\n        100: \"Continue\",\r\n        101: \"Switching Protocols\",\r\n        200: \"OK\",\r\n        201: \"Created\",\r\n        202: \"Accepted\",\r\n        203: \"Non-Authoritative Information\",\r\n        204: \"No Content\",\r\n        205: \"Reset Content\",\r\n        206: \"Partial Content\",\r\n        300: \"Multiple Choice\",\r\n        301: \"Moved Permanently\",\r\n        302: \"Found\",\r\n        303: \"See Other\",\r\n        304: \"Not Modified\",\r\n        305: \"Use Proxy\",\r\n        307: \"Temporary Redirect\",\r\n        400: \"Bad Request\",\r\n        401: \"Unauthorized\",\r\n        402: \"Payment Required\",\r\n        403: \"Forbidden\",\r\n        404: \"Not Found\",\r\n        405: \"Method Not Allowed\",\r\n        406: \"Not Acceptable\",\r\n        407: \"Proxy Authentication Required\",\r\n        408: \"Request Timeout\",\r\n        409: \"Conflict\",\r\n        410: \"Gone\",\r\n        411: \"Length Required\",\r\n        412: \"Precondition Failed\",\r\n        413: \"Request Entity Too Large\",\r\n        414: \"Request-URI Too Long\",\r\n        415: \"Unsupported Media Type\",\r\n        416: \"Requested Range Not Satisfiable\",\r\n        417: \"Expectation Failed\",\r\n        422: \"Unprocessable Entity\",\r\n        500: \"Internal Server Error\",\r\n        501: \"Not Implemented\",\r\n        502: \"Bad Gateway\",\r\n        503: \"Service Unavailable\",\r\n        504: \"Gateway Timeout\",\r\n        505: \"HTTP Version Not Supported\"\r\n    };\r\n\r\n    sinon.useFakeXMLHttpRequest = function () {\r\n        sinon.FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\r\n            if (xhr.supportsXHR) {\r\n                global.XMLHttpRequest = xhr.GlobalXMLHttpRequest;\r\n            }\r\n\r\n            if (xhr.supportsActiveX) {\r\n                global.ActiveXObject = xhr.GlobalActiveXObject;\r\n            }\r\n\r\n            delete sinon.FakeXMLHttpRequest.restore;\r\n\r\n            if (keepOnCreate !== true) {\r\n                delete sinon.FakeXMLHttpRequest.onCreate;\r\n            }\r\n        };\r\n        if (xhr.supportsXHR) {\r\n            global.XMLHttpRequest = sinon.FakeXMLHttpRequest;\r\n        }\r\n\r\n        if (xhr.supportsActiveX) {\r\n            global.ActiveXObject = function ActiveXObject(objId) {\r\n                if (objId == \"Microsoft.XMLHTTP\" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\r\n\r\n                    return new sinon.FakeXMLHttpRequest();\r\n                }\r\n\r\n                return new xhr.GlobalActiveXObject(objId);\r\n            };\r\n        }\r\n\r\n        return sinon.FakeXMLHttpRequest;\r\n    };\r\n\r\n    sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;\r\n})(this);\r\n\r\nif (typeof module == \"object\" && typeof require == \"function\") {\r\n    module.exports = sinon;\r\n}\r\n\r\n/**\r\n * @depend fake_xml_http_request.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, regexp: false, plusplus: false*/\r\n/*global module, require, window*/\r\n/**\r\n * The Sinon \"server\" mimics a web server that receives requests from\r\n * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,\r\n * both synchronously and asynchronously. To respond synchronuously, canned\r\n * answers have to be provided upfront.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\nif (typeof sinon == \"undefined\") {\r\n    var sinon = {};\r\n}\r\n\r\nsinon.fakeServer = (function () {\r\n    var push = [].push;\r\n    function F() {}\r\n\r\n    function create(proto) {\r\n        F.prototype = proto;\r\n        return new F();\r\n    }\r\n\r\n    function responseArray(handler) {\r\n        var response = handler;\r\n\r\n        if (Object.prototype.toString.call(handler) != \"[object Array]\") {\r\n            response = [200, {}, handler];\r\n        }\r\n\r\n        if (typeof response[2] != \"string\") {\r\n            throw new TypeError(\"Fake server response body should be string, but was \" +\r\n                                typeof response[2]);\r\n        }\r\n\r\n        return response;\r\n    }\r\n\r\n    var wloc = typeof window !== \"undefined\" ? window.location : {};\r\n    var rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\r\n\r\n    function matchOne(response, reqMethod, reqUrl) {\r\n        var rmeth = response.method;\r\n        var matchMethod = !rmeth || rmeth.toLowerCase() == reqMethod.toLowerCase();\r\n        var url = response.url;\r\n        var matchUrl = !url || url == reqUrl || (typeof url.test == \"function\" && url.test(reqUrl));\r\n\r\n        return matchMethod && matchUrl;\r\n    }\r\n\r\n    function match(response, request) {\r\n        var requestMethod = this.getHTTPMethod(request);\r\n        var requestUrl = request.url;\r\n\r\n        if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\r\n            requestUrl = requestUrl.replace(rCurrLoc, \"\");\r\n        }\r\n\r\n        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\r\n            if (typeof response.response == \"function\") {\r\n                var ru = response.url;\r\n                var args = [request].concat(!ru ? [] : requestUrl.match(ru).slice(1));\r\n                return response.response.apply(response, args);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function log(response, request) {\r\n        var str;\r\n\r\n        str =  \"Request:\\n\"  + sinon.format(request)  + \"\\n\\n\";\r\n        str += \"Response:\\n\" + sinon.format(response) + \"\\n\\n\";\r\n\r\n        sinon.log(str);\r\n    }\r\n\r\n    return {\r\n        create: function () {\r\n            var server = create(this);\r\n            this.xhr = sinon.useFakeXMLHttpRequest();\r\n            server.requests = [];\r\n\r\n            this.xhr.onCreate = function (xhrObj) {\r\n                server.addRequest(xhrObj);\r\n            };\r\n\r\n            return server;\r\n        },\r\n\r\n        addRequest: function addRequest(xhrObj) {\r\n            var server = this;\r\n            push.call(this.requests, xhrObj);\r\n\r\n            xhrObj.onSend = function () {\r\n                server.handleRequest(this);\r\n            };\r\n\r\n            if (this.autoRespond && !this.responding) {\r\n                setTimeout(function () {\r\n                    server.responding = false;\r\n                    server.respond();\r\n                }, this.autoRespondAfter || 10);\r\n\r\n                this.responding = true;\r\n            }\r\n        },\r\n\r\n        getHTTPMethod: function getHTTPMethod(request) {\r\n            if (this.fakeHTTPMethods && /post/i.test(request.method)) {\r\n                var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\r\n                return !!matches ? matches[1] : request.method;\r\n            }\r\n\r\n            return request.method;\r\n        },\r\n\r\n        handleRequest: function handleRequest(xhr) {\r\n            if (xhr.async) {\r\n                if (!this.queue) {\r\n                    this.queue = [];\r\n                }\r\n\r\n                push.call(this.queue, xhr);\r\n            } else {\r\n                this.processRequest(xhr);\r\n            }\r\n        },\r\n\r\n        respondWith: function respondWith(method, url, body) {\r\n            if (arguments.length == 1 && typeof method != \"function\") {\r\n                this.response = responseArray(method);\r\n                return;\r\n            }\r\n\r\n            if (!this.responses) { this.responses = []; }\r\n\r\n            if (arguments.length == 1) {\r\n                body = method;\r\n                url = method = null;\r\n            }\r\n\r\n            if (arguments.length == 2) {\r\n                body = url;\r\n                url = method;\r\n                method = null;\r\n            }\r\n\r\n            push.call(this.responses, {\r\n                method: method,\r\n                url: url,\r\n                response: typeof body == \"function\" ? body : responseArray(body)\r\n            });\r\n        },\r\n\r\n        respond: function respond() {\r\n            if (arguments.length > 0) this.respondWith.apply(this, arguments);\r\n            var queue = this.queue || [];\r\n            var request;\r\n\r\n            while(request = queue.shift()) {\r\n                this.processRequest(request);\r\n            }\r\n        },\r\n\r\n        processRequest: function processRequest(request) {\r\n            try {\r\n                if (request.aborted) {\r\n                    return;\r\n                }\r\n\r\n                var response = this.response || [404, {}, \"\"];\r\n\r\n                if (this.responses) {\r\n                    for (var i = 0, l = this.responses.length; i < l; i++) {\r\n                        if (match.call(this, this.responses[i], request)) {\r\n                            response = this.responses[i].response;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (request.readyState != 4) {\r\n                    log(response, request);\r\n\r\n                    request.respond(response[0], response[1], response[2]);\r\n                }\r\n            } catch (e) {\r\n                sinon.logError(\"Fake server request processing\", e);\r\n            }\r\n        },\r\n\r\n        restore: function restore() {\r\n            return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\r\n        }\r\n    };\r\n}());\r\n\r\nif (typeof module == \"object\" && typeof require == \"function\") {\r\n    module.exports = sinon;\r\n}\r\n\r\n/**\r\n * @depend fake_server.js\r\n * @depend fake_timers.js\r\n */\r\n/*jslint browser: true, eqeqeq: false, onevar: false*/\r\n/*global sinon*/\r\n/**\r\n * Add-on for sinon.fakeServer that automatically handles a fake timer along with\r\n * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery\r\n * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,\r\n * it polls the object for completion with setInterval. Dispite the direct\r\n * motivation, there is nothing jQuery-specific in this file, so it can be used\r\n * in any environment where the ajax implementation depends on setInterval or\r\n * setTimeout.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function () {\r\n    function Server() {}\r\n    Server.prototype = sinon.fakeServer;\r\n\r\n    sinon.fakeServerWithClock = new Server();\r\n\r\n    sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {\r\n        if (xhr.async) {\r\n            if (typeof setTimeout.clock == \"object\") {\r\n                this.clock = setTimeout.clock;\r\n            } else {\r\n                this.clock = sinon.useFakeTimers();\r\n                this.resetClock = true;\r\n            }\r\n\r\n            if (!this.longestTimeout) {\r\n                var clockSetTimeout = this.clock.setTimeout;\r\n                var clockSetInterval = this.clock.setInterval;\r\n                var server = this;\r\n\r\n                this.clock.setTimeout = function (fn, timeout) {\r\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\r\n\r\n                    return clockSetTimeout.apply(this, arguments);\r\n                };\r\n\r\n                this.clock.setInterval = function (fn, timeout) {\r\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\r\n\r\n                    return clockSetInterval.apply(this, arguments);\r\n                };\r\n            }\r\n        }\r\n\r\n        return sinon.fakeServer.addRequest.call(this, xhr);\r\n    };\r\n\r\n    sinon.fakeServerWithClock.respond = function respond() {\r\n        var returnVal = sinon.fakeServer.respond.apply(this, arguments);\r\n\r\n        if (this.clock) {\r\n            this.clock.tick(this.longestTimeout || 0);\r\n            this.longestTimeout = 0;\r\n\r\n            if (this.resetClock) {\r\n                this.clock.restore();\r\n                this.resetClock = false;\r\n            }\r\n        }\r\n\r\n        return returnVal;\r\n    };\r\n\r\n    sinon.fakeServerWithClock.restore = function restore() {\r\n        if (this.clock) {\r\n            this.clock.restore();\r\n        }\r\n\r\n        return sinon.fakeServer.restore.apply(this, arguments);\r\n    };\r\n}());\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend collection.js\r\n * @depend util/fake_timers.js\r\n * @depend util/fake_server_with_clock.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\r\n/*global require, module*/\r\n/**\r\n * Manages fake collections as well as fake utilities such as Sinon's\r\n * timers and fake XHR implementation in one convenient object.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\nif (typeof module == \"object\" && typeof require == \"function\") {\r\n    var sinon = require(\"../sinon\");\r\n    sinon.extend(sinon, require(\"./util/fake_timers\"));\r\n}\r\n\r\n(function () {\r\n    var push = [].push;\r\n\r\n    function exposeValue(sandbox, config, key, value) {\r\n        if (!value) {\r\n            return;\r\n        }\r\n\r\n        if (config.injectInto) {\r\n            config.injectInto[key] = value;\r\n        } else {\r\n            push.call(sandbox.args, value);\r\n        }\r\n    }\r\n\r\n    function prepareSandboxFromConfig(config) {\r\n        var sandbox = sinon.create(sinon.sandbox);\r\n\r\n        if (config.useFakeServer) {\r\n            if (typeof config.useFakeServer == \"object\") {\r\n                sandbox.serverPrototype = config.useFakeServer;\r\n            }\r\n\r\n            sandbox.useFakeServer();\r\n        }\r\n\r\n        if (config.useFakeTimers) {\r\n            if (typeof config.useFakeTimers == \"object\") {\r\n                sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\r\n            } else {\r\n                sandbox.useFakeTimers();\r\n            }\r\n        }\r\n\r\n        return sandbox;\r\n    }\r\n\r\n    sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {\r\n        useFakeTimers: function useFakeTimers() {\r\n            this.clock = sinon.useFakeTimers.apply(sinon, arguments);\r\n\r\n            return this.add(this.clock);\r\n        },\r\n\r\n        serverPrototype: sinon.fakeServer,\r\n\r\n        useFakeServer: function useFakeServer() {\r\n            var proto = this.serverPrototype || sinon.fakeServer;\r\n\r\n            if (!proto || !proto.create) {\r\n                return null;\r\n            }\r\n\r\n            this.server = proto.create();\r\n            return this.add(this.server);\r\n        },\r\n\r\n        inject: function (obj) {\r\n            sinon.collection.inject.call(this, obj);\r\n\r\n            if (this.clock) {\r\n                obj.clock = this.clock;\r\n            }\r\n\r\n            if (this.server) {\r\n                obj.server = this.server;\r\n                obj.requests = this.server.requests;\r\n            }\r\n\r\n            return obj;\r\n        },\r\n\r\n        create: function (config) {\r\n            if (!config) {\r\n                return sinon.create(sinon.sandbox);\r\n            }\r\n\r\n            var sandbox = prepareSandboxFromConfig(config);\r\n            sandbox.args = sandbox.args || [];\r\n            var prop, value, exposed = sandbox.inject({});\r\n\r\n            if (config.properties) {\r\n                for (var i = 0, l = config.properties.length; i < l; i++) {\r\n                    prop = config.properties[i];\r\n                    value = exposed[prop] || prop == \"sandbox\" && sandbox;\r\n                    exposeValue(sandbox, config, prop, value);\r\n                }\r\n            } else {\r\n                exposeValue(sandbox, config, \"sandbox\", value);\r\n            }\r\n\r\n            return sandbox;\r\n        }\r\n    });\r\n\r\n    sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;\r\n\r\n    if (typeof module == \"object\" && typeof require == \"function\") {\r\n        module.exports = sinon.sandbox;\r\n    }\r\n}());\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend stub.js\r\n * @depend mock.js\r\n * @depend sandbox.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, forin: true, plusplus: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Test function, sandboxes fakes\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function test(callback) {\r\n        var type = typeof callback;\r\n\r\n        if (type != \"function\") {\r\n            throw new TypeError(\"sinon.test needs to wrap a test function, got \" + type);\r\n        }\r\n\r\n        return function () {\r\n            var config = sinon.getConfig(sinon.config);\r\n            config.injectInto = config.injectIntoThis && this || config.injectInto;\r\n            var sandbox = sinon.sandbox.create(config);\r\n            var exception, result;\r\n            var args = Array.prototype.slice.call(arguments).concat(sandbox.args);\r\n\r\n            try {\r\n                result = callback.apply(this, args);\r\n            } catch (e) {\r\n                exception = e;\r\n            }\r\n\r\n            if (typeof exception !== \"undefined\") {\r\n                sandbox.restore();\r\n                throw exception;\r\n            }\r\n            else {\r\n                sandbox.verifyAndRestore();\r\n            }\r\n\r\n            return result;\r\n        };\r\n    }\r\n\r\n    test.config = {\r\n        injectIntoThis: true,\r\n        injectInto: null,\r\n        properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\r\n        useFakeTimers: true,\r\n        useFakeServer: true\r\n    };\r\n\r\n    if (commonJSModule) {\r\n        module.exports = test;\r\n    } else {\r\n        sinon.test = test;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend test.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, eqeqeq: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Test case, sandboxes all test functions\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon || !Object.prototype.hasOwnProperty) {\r\n        return;\r\n    }\r\n\r\n    function createTest(property, setUp, tearDown) {\r\n        return function () {\r\n            if (setUp) {\r\n                setUp.apply(this, arguments);\r\n            }\r\n\r\n            var exception, result;\r\n\r\n            try {\r\n                result = property.apply(this, arguments);\r\n            } catch (e) {\r\n                exception = e;\r\n            }\r\n\r\n            if (tearDown) {\r\n                tearDown.apply(this, arguments);\r\n            }\r\n\r\n            if (exception) {\r\n                throw exception;\r\n            }\r\n\r\n            return result;\r\n        };\r\n    }\r\n\r\n    function testCase(tests, prefix) {\r\n        /*jsl:ignore*/\r\n        if (!tests || typeof tests != \"object\") {\r\n            throw new TypeError(\"sinon.testCase needs an object with test functions\");\r\n        }\r\n        /*jsl:end*/\r\n\r\n        prefix = prefix || \"test\";\r\n        var rPrefix = new RegExp(\"^\" + prefix);\r\n        var methods = {}, testName, property, method;\r\n        var setUp = tests.setUp;\r\n        var tearDown = tests.tearDown;\r\n\r\n        for (testName in tests) {\r\n            if (tests.hasOwnProperty(testName)) {\r\n                property = tests[testName];\r\n\r\n                if (/^(setUp|tearDown)$/.test(testName)) {\r\n                    continue;\r\n                }\r\n\r\n                if (typeof property == \"function\" && rPrefix.test(testName)) {\r\n                    method = property;\r\n\r\n                    if (setUp || tearDown) {\r\n                        method = createTest(property, setUp, tearDown);\r\n                    }\r\n\r\n                    methods[testName] = sinon.test(method);\r\n                } else {\r\n                    methods[testName] = tests[testName];\r\n                }\r\n            }\r\n        }\r\n\r\n        return methods;\r\n    }\r\n\r\n    if (commonJSModule) {\r\n        module.exports = testCase;\r\n    } else {\r\n        sinon.testCase = testCase;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null));\r\n\r\n/**\r\n * @depend ../sinon.js\r\n * @depend stub.js\r\n */\r\n/*jslint eqeqeq: false, onevar: false, nomen: false, plusplus: false*/\r\n/*global module, require, sinon*/\r\n/**\r\n * Assertions matching the test spy retrieval interface.\r\n *\r\n * @author Christian Johansen (christian@cjohansen.no)\r\n * @license BSD\r\n *\r\n * Copyright (c) 2010-2013 Christian Johansen\r\n */\r\n\r\n(function (sinon, global) {\r\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\r\n    var slice = Array.prototype.slice;\r\n    var assert;\r\n\r\n    if (!sinon && commonJSModule) {\r\n        sinon = require(\"../sinon\");\r\n    }\r\n\r\n    if (!sinon) {\r\n        return;\r\n    }\r\n\r\n    function verifyIsStub() {\r\n        var method;\r\n\r\n        for (var i = 0, l = arguments.length; i < l; ++i) {\r\n            method = arguments[i];\r\n\r\n            if (!method) {\r\n                assert.fail(\"fake is not a spy\");\r\n            }\r\n\r\n            if (typeof method != \"function\") {\r\n                assert.fail(method + \" is not a function\");\r\n            }\r\n\r\n            if (typeof method.getCall != \"function\") {\r\n                assert.fail(method + \" is not stubbed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function failAssertion(object, msg) {\r\n        object = object || global;\r\n        var failMethod = object.fail || assert.fail;\r\n        failMethod.call(object, msg);\r\n    }\r\n\r\n    function mirrorPropAsAssertion(name, method, message) {\r\n        if (arguments.length == 2) {\r\n            message = method;\r\n            method = name;\r\n        }\r\n\r\n        assert[name] = function (fake) {\r\n            verifyIsStub(fake);\r\n\r\n            var args = slice.call(arguments, 1);\r\n            var failed = false;\r\n\r\n            if (typeof method == \"function\") {\r\n                failed = !method(fake);\r\n            } else {\r\n                failed = typeof fake[method] == \"function\" ?\r\n                    !fake[method].apply(fake, args) : !fake[method];\r\n            }\r\n\r\n            if (failed) {\r\n                failAssertion(this, fake.printf.apply(fake, [message].concat(args)));\r\n            } else {\r\n                assert.pass(name);\r\n            }\r\n        };\r\n    }\r\n\r\n    function exposedName(prefix, prop) {\r\n        return !prefix || /^fail/.test(prop) ? prop :\r\n            prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\r\n    };\r\n\r\n    assert = {\r\n        failException: \"AssertError\",\r\n\r\n        fail: function fail(message) {\r\n            var error = new Error(message);\r\n            error.name = this.failException || assert.failException;\r\n\r\n            throw error;\r\n        },\r\n\r\n        pass: function pass(assertion) {},\r\n\r\n        callOrder: function assertCallOrder() {\r\n            verifyIsStub.apply(null, arguments);\r\n            var expected = \"\", actual = \"\";\r\n\r\n            if (!sinon.calledInOrder(arguments)) {\r\n                try {\r\n                    expected = [].join.call(arguments, \", \");\r\n                    actual = sinon.orderByFirstCall(slice.call(arguments)).join(\", \");\r\n                } catch (e) {\r\n                    // If this fails, we'll just fall back to the blank string\r\n                }\r\n\r\n                failAssertion(this, \"expected \" + expected + \" to be \" +\r\n                              \"called in order but were called as \" + actual);\r\n            } else {\r\n                assert.pass(\"callOrder\");\r\n            }\r\n        },\r\n\r\n        callCount: function assertCallCount(method, count) {\r\n            verifyIsStub(method);\r\n\r\n            if (method.callCount != count) {\r\n                var msg = \"expected %n to be called \" + sinon.timesInWords(count) +\r\n                    \" but was called %c%C\";\r\n                failAssertion(this, method.printf(msg));\r\n            } else {\r\n                assert.pass(\"callCount\");\r\n            }\r\n        },\r\n\r\n        expose: function expose(target, options) {\r\n            if (!target) {\r\n                throw new TypeError(\"target is null or undefined\");\r\n            }\r\n\r\n            var o = options || {};\r\n            var prefix = typeof o.prefix == \"undefined\" && \"assert\" || o.prefix;\r\n            var includeFail = typeof o.includeFail == \"undefined\" || !!o.includeFail;\r\n\r\n            for (var method in this) {\r\n                if (method != \"export\" && (includeFail || !/^(fail)/.test(method))) {\r\n                    target[exposedName(prefix, method)] = this[method];\r\n                }\r\n            }\r\n\r\n            return target;\r\n        }\r\n    };\r\n\r\n    mirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\r\n    mirrorPropAsAssertion(\"notCalled\", function (spy) { return !spy.called; },\r\n                          \"expected %n to not have been called but was called %c%C\");\r\n    mirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\r\n    mirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\r\n    mirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\r\n    mirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\r\n    mirrorPropAsAssertion(\"alwaysCalledOn\", \"expected %n to always be called with %1 as this but was called with %t\");\r\n    mirrorPropAsAssertion(\"calledWithNew\", \"expected %n to be called with new\");\r\n    mirrorPropAsAssertion(\"alwaysCalledWithNew\", \"expected %n to always be called with new\");\r\n    mirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %*%C\");\r\n    mirrorPropAsAssertion(\"calledWithMatch\", \"expected %n to be called with match %*%C\");\r\n    mirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %*%C\");\r\n    mirrorPropAsAssertion(\"alwaysCalledWithMatch\", \"expected %n to always be called with match %*%C\");\r\n    mirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %*%C\");\r\n    mirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %*%C\");\r\n    mirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\r\n    mirrorPropAsAssertion(\"neverCalledWithMatch\", \"expected %n to never be called with match %*%C\");\r\n    mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\r\n    mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\r\n\r\n    if (commonJSModule) {\r\n        module.exports = assert;\r\n    } else {\r\n        sinon.assert = assert;\r\n    }\r\n}(typeof sinon == \"object\" && sinon || null, typeof window != \"undefined\" ? window : global));\r\n\r\nreturn sinon;}.call(typeof window != 'undefined' && window || {}));\r\n","(function (sinonChai) {\r\n    \"use strict\";\r\n\r\n    // Module systems magic dance.\r\n\r\n    if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\r\n        // NodeJS\r\n        module.exports = sinonChai;\r\n    } else if (typeof define === \"function\" && define.amd) {\r\n        // AMD\r\n        define(function () {\r\n            return sinonChai;\r\n        });\r\n    } else {\r\n        // Other environment (usually <script> tag): plug in to global chai instance directly.\r\n        chai.use(sinonChai);\r\n    }\r\n}(function sinonChai(chai, utils) {\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice;\r\n\r\n    function isSpy(putativeSpy) {\r\n        return typeof putativeSpy === \"function\" &&\r\n               typeof putativeSpy.getCall === \"function\" &&\r\n               typeof putativeSpy.calledWithExactly === \"function\";\r\n    }\r\n\r\n    function isCall(putativeCall) {\r\n        return putativeCall && isSpy(putativeCall.proxy);\r\n    }\r\n\r\n    function assertCanWorkWith(assertion) {\r\n        if (!isSpy(assertion._obj) && !isCall(assertion._obj)) {\r\n            throw new TypeError(utils.inspect(assertion._obj) + \" is not a spy or a call to a spy!\");\r\n        }\r\n    }\r\n\r\n    function getMessages(spy, action, nonNegatedSuffix, always, args) {\r\n        var verbPhrase = always ? \"always have \" : \"have \";\r\n        nonNegatedSuffix = nonNegatedSuffix || \"\";\r\n        if (isSpy(spy.proxy)) {\r\n            spy = spy.proxy;\r\n        }\r\n\r\n        function printfArray(array) {\r\n            return spy.printf.apply(spy, array);\r\n        }\r\n\r\n        return {\r\n            affirmative: printfArray([\"expected %n to \" + verbPhrase + action + nonNegatedSuffix].concat(args)),\r\n            negative: printfArray([\"expected %n to not \" + verbPhrase + action].concat(args))\r\n        };\r\n    }\r\n\r\n    function sinonProperty(name, action, nonNegatedSuffix) {\r\n        utils.addProperty(chai.Assertion.prototype, name, function () {\r\n            assertCanWorkWith(this);\r\n\r\n            var messages = getMessages(this._obj, action, nonNegatedSuffix, false);\r\n            this.assert(this._obj[name], messages.affirmative, messages.negative);\r\n        });\r\n    }\r\n\r\n    function createSinonMethodHandler(sinonName, action, nonNegatedSuffix) {\r\n        return function () {\r\n            assertCanWorkWith(this);\r\n\r\n            var alwaysSinonMethod = \"always\" + sinonName[0].toUpperCase() + sinonName.substring(1);\r\n            var shouldBeAlways = utils.flag(this, \"always\") && typeof this._obj[alwaysSinonMethod] === \"function\";\r\n            var sinonMethod = shouldBeAlways ? alwaysSinonMethod : sinonName;\r\n\r\n            var messages = getMessages(this._obj, action, nonNegatedSuffix, shouldBeAlways, slice.call(arguments));\r\n            this.assert(this._obj[sinonMethod].apply(this._obj, arguments), messages.affirmative, messages.negative);\r\n        };\r\n    }\r\n\r\n    function sinonMethodAsProperty(name, action, nonNegatedSuffix) {\r\n        var handler = createSinonMethodHandler(name, action, nonNegatedSuffix);\r\n        utils.addProperty(chai.Assertion.prototype, name, handler);\r\n    }\r\n\r\n    function exceptionalSinonMethod(chaiName, sinonName, action, nonNegatedSuffix) {\r\n        var handler = createSinonMethodHandler(sinonName, action, nonNegatedSuffix);\r\n        utils.addMethod(chai.Assertion.prototype, chaiName, handler);\r\n    }\r\n\r\n    function sinonMethod(name, action, nonNegatedSuffix) {\r\n        exceptionalSinonMethod(name, name, action, nonNegatedSuffix);\r\n    }\r\n\r\n    utils.addProperty(chai.Assertion.prototype, \"always\", function () {\r\n        utils.flag(this, \"always\", true);\r\n    });\r\n\r\n    sinonProperty(\"called\", \"been called\", \" at least once, but it was never called\");\r\n    sinonProperty(\"calledOnce\", \"been called exactly once\", \", but it was called %c%C\");\r\n    sinonProperty(\"calledTwice\", \"been called exactly twice\", \", but it was called %c%C\");\r\n    sinonProperty(\"calledThrice\", \"been called exactly thrice\", \", but it was called %c%C\");\r\n    sinonMethodAsProperty(\"calledWithNew\", \"been called with new\");\r\n    sinonMethod(\"calledBefore\", \"been called before %1\");\r\n    sinonMethod(\"calledAfter\", \"been called after %1\");\r\n    sinonMethod(\"calledOn\", \"been called with %1 as this\", \", but it was called with %t instead\");\r\n    sinonMethod(\"calledWith\", \"been called with arguments %*\", \"%C\");\r\n    sinonMethod(\"calledWithExactly\", \"been called with exact arguments %*\", \"%C\");\r\n    sinonMethod(\"calledWithMatch\", \"been called with arguments matching %*\", \"%C\");\r\n    sinonMethod(\"returned\", \"returned %1\");\r\n    exceptionalSinonMethod(\"thrown\", \"threw\", \"thrown %1\");\r\n}));\r\n","// Create `window.describe` etc. for our BDD-like tests.\r\nmocha.setup({ui: 'bdd'});\r\n\r\n// Create another global variable for simpler syntax.\r\nwindow.expect = chai.expect;\r\n","var test, tests, _i, _len;\n\ntests = ['./views/header-view-test', './views/home-page-view-test', './views/site-view-test'];\n\nfor (_i = 0, _len = tests.length; _i < _len; _i++) {\n  test = tests[_i];\n  require(test);\n}\n","var HeaderView, HeaderViewTest, _ref,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nHeaderView = require('views/header-view');\n\nHeaderViewTest = (function(_super) {\n  __extends(HeaderViewTest, _super);\n\n  function HeaderViewTest() {\n    _ref = HeaderViewTest.__super__.constructor.apply(this, arguments);\n    return _ref;\n  }\n\n  HeaderViewTest.prototype.renderTimes = 0;\n\n  HeaderViewTest.prototype.render = function() {\n    HeaderViewTest.__super__.render.apply(this, arguments);\n    return this.renderTimes += 1;\n  };\n\n  return HeaderViewTest;\n\n})(HeaderView);\n\ndescribe('HeaderView', function() {\n  beforeEach(function() {\n    return this.view = new HeaderViewTest;\n  });\n  afterEach(function() {\n    return this.view.dispose();\n  });\n  return it('should display 4 links', function() {\n    return expect(this.view.$el.find('a')).to.have.length(4);\n  });\n});\n","var HomePageView;\n\nHomePageView = require('views/home-page-view');\n\ndescribe('HomePageView', function() {\n  beforeEach(function() {\n    return this.view = new HomePageView;\n  });\n  afterEach(function() {\n    return this.view.dispose();\n  });\n  return it('should auto-render', function() {\n    return expect(this.view.$el.find('img')).to.have.length(1);\n  });\n});\n","var SiteView;\n\nSiteView = require('views/site-view');\n\ndescribe('SiteView', function() {\n  return beforeEach(function() {\n    return this.view = new SiteView();\n  });\n});\n"]}