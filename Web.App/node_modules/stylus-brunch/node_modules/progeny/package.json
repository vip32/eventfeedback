{
  "name": "progeny",
  "version": "0.1.3",
  "description": "Recursively finds dependencies of style and template source files",
  "author": {
    "name": "Elan Shanker",
    "url": "http://github.com/es128"
  },
  "homepage": "https://github.com/es128/progeny",
  "repository": {
    "type": "git",
    "url": "git@github.com:es128/progeny.git"
  },
  "bugs": {
    "url": "https://github.com/es128/progeny/issues"
  },
  "main": "./lib/index",
  "scripts": {
    "prepublish": "rm -rf lib && coffee --bare --output lib/ src/"
  },
  "dependencies": {
    "async-each": "~0.1.3"
  },
  "devDependencies": {},
  "readme": "Progeny\n=======\nRecursively finds dependencies of style and template source files.\n\nOr configure it to do the same kind of thing with any other type of text file.\n\n\nUsage\n-----\nCall **Progeny** with an optional configuration object, it returns a reusable\nfunction. There are built-in configurations already for `jade`, `stylus`,\n`less`, and `sass`. Call that function with a path to a source file (and its\nsource code if you already have it handy), and it will figure out all of that\nfile's dependencies and sub-dependencies, passing an array of them to your\ncallback.\n\nExamples using `path` assume you already have `var path = require('path');`.\nYou _could_ just use strings like `'/path/to/project'`, but you may run into\ncross-compatibility issues.\n\n##### Quick and Simple\nYou can skip the config object and the source code, letting **Progeny** read\nthe source from the file itself and apply a built-in configuration based on the file extension.\n\n```javascript\nvar filePath = path.join('path', 'to', 'project', 'style-or-template.jade');\nrequire('progeny')()(null, filePath, function (err, dependencies) {\n    // use the dependencies array in here\n});\n```\n\n##### Optional Configuration Attributes\n\n```javascript\nvar progenyConfig = {\n    // The file extension for the source code you want parsed\n    // Will be derived from the source file path if not specified\n    extension: 'styl',\n\n    // Array of multiple file extensions to try when looking for dependencies\n    extensionsList: ['scss', 'sass'],\n\n    // Regexp to run on each line of source code to match dependency references\n    // Make sure you wrap the file name part in (parentheses)\n    regexp: /^\\s*@import\\s+['\"]?([^'\"]+)['\"]?/,\n\n    // File prefix to try (in addition to the raw value matched in the regexp)\n    prefix: '_',\n\n    // Matched stuff to exclude, string or regex\n    exclusion: /^compass/,\n\n    // In case a match starts with a slash, the absolute path to apply\n    rootPath: path.join('path', 'to', 'project')\n};\n```\n\n##### More Examples\nProcess a list of files:\n\n```javascript\nvar progeny = require('progeny');\nvar getDependencies = progeny(progenyConfig);\nmyFiles.forEach( function (file) {\n    getDependencies(file.source, file.path, function (err, deps) {\n        if (err) throw new Error(err);\n        file.dependencies = deps;\n    });\n});\n```\n\nMultiple configs:\n\n```javascript\nvar getDefaultDependencies = progeny();\nvar getCustomDependencies = progeny({\n    extension: 'foo',\n    regexp: /([^\\s,]+)/\n});\n```\n\nProcess source code from a string without its file path:\n\n```javascript\nvar mySourceString; // assume this contains valid source code\nprogeny({\n    // extension and rootPath must be specified for this to work\n    // also need regexp if extension not one of the predefined ones\n    extension: 'jade',\n    rootPath: path.join('path', 'to', 'project')\n})(mySourceString, null, function (err, deps) {});\n```\n\n\nLicense\n-------\n[MIT](https://raw.github.com/es128/progeny/master/LICENSE)\n",
  "readmeFilename": "README.md",
  "_id": "progeny@0.1.3",
  "_from": "progeny@~0.1.1"
}
